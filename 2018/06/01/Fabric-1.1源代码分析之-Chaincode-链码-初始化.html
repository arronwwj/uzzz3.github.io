<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Fabric 1.1源代码分析之 Chaincode（链码）初始化 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Fabric 1.1源代码分析之 Chaincode（链码）初始化" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="# Fabric 1.1源代码分析之 Chaincode（链码）初始化 #ChaincodeSupport（链码支持服务端） ## 1、Endorser概述 1、Endorser相关代码分布在protos/peer/peer.pb.go和core/endorser目录。 * 在peer/node/start.go的serve（） 方法中注册了 endoser服务 serverEndorser := endorser.NewEndorserServer(privDataDist, &amp;endorser.SupportImpl{}) &nbsp;&nbsp;&nbsp;&nbsp;libConf := library.Config{} &nbsp;&nbsp;&nbsp;&nbsp;if err = viperutil.EnhancedExactUnmarshalKey(&quot;peer.handlers&quot;, &amp;libConf); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors.WithMessage(err, &quot;could not load YAML config&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;authFilters := library.InitRegistry(libConf).Lookup(library.Auth).([]authHandler.Filter) &nbsp;&nbsp;&nbsp;&nbsp;auth := authHandler.ChainFilters(serverEndorser, authFilters...) &nbsp;&nbsp;&nbsp;&nbsp;// Register the Endorser server &nbsp;&nbsp;&nbsp;&nbsp;pb.RegisterEndorserServer(peerServer.Server(), auth) * protos/peer/peer.pb.go，EndorserServer接口定义。 type EndorserServer interface { &nbsp;&nbsp;&nbsp;&nbsp;ProcessProposal(context.Context, *SignedProposal) (*ProposalResponse, error) } * core/endorser目录： * endorser.go，EndorserServer接口实现，即Endorser结构体及方法，以及EndorserServer服务端 ProcessProposal处理流程。 * endorser.go，Support接口定义及实现 type SupportImpl struct(support.go)。 ## 2、endorser中的EndorserServer接口实现方法 * // ProcessProposal process the Proposal 处理客户端传过来的提案。peer chaincode instantiate初始化合约命令也是一种提案，最终服务端此处是入口 ```go func (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error) { &nbsp;&nbsp;&nbsp;&nbsp;addr := util.ExtractRemoteAddress(ctx) &nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debug( &quot;Entering: Got request from&quot;, addr) &nbsp;&nbsp;&nbsp;&nbsp; defer endorserLogger.Debugf( &quot;Exit: request from&quot;, addr) &nbsp;&nbsp;&nbsp;&nbsp; //0 -- check and validate 对提案进行预处理，检查消息有校性及其权限 &nbsp;&nbsp;&nbsp;&nbsp;vr, err := e.preProcess(signedProp) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp := vr.resp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resp, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid &nbsp;&nbsp;&nbsp;&nbsp; // obtaining once the tx simulator for this proposal. This will be nil &nbsp;&nbsp;&nbsp;&nbsp; // for chainless proposals &nbsp;&nbsp;&nbsp;&nbsp; // Also obtain a history query executor for history queries, since tx simulator does not cover history &nbsp;&nbsp;&nbsp;&nbsp; var txsim ledger.TxSimulator &nbsp;&nbsp;&nbsp;&nbsp; var historyQueryExecutor ledger.HistoryQueryExecutor &nbsp;&nbsp;&nbsp;&nbsp; if chainID != &quot;&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if txsim, err = e.s.GetTxSimulator(chainID, txid); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the historyQueryExecutor to context &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO shouldn&#39;t we also add txsim to context here as well? Rather than passing txsim parameter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // around separately, since eventually it gets added to context anyways &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx = context.WithValue(ctx, chaincode.HistoryQueryExecutorKey, historyQueryExecutor) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defer txsim.Done() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //this could be a request to a chainless SysCC &nbsp;&nbsp;&nbsp;&nbsp; // TODO: if the proposal has an extension, it will be of type ChaincodeAction; &nbsp;&nbsp;&nbsp;&nbsp; // if it&#39;s present it means that no simulation is to be performed because &nbsp;&nbsp;&nbsp;&nbsp; // we&#39;re trying to emulate a submitting peer. On the other hand, we need &nbsp;&nbsp;&nbsp;&nbsp; // to validate the supplied action before endorsing it &nbsp;&nbsp;&nbsp;&nbsp; /*1 -- simulate //如果是扩展提案，可能是一个链码操作 调用本文件中的simulateProposal()-&gt;callChaincode()-&gt;Execute()(core/endorser/support.go switch spec.(type) {&nbsp;&nbsp;&nbsp;case *pb.ChaincodeDeploymentSpec:return chaincode.Execute(ctxt, cccid, spec)) &nbsp;&nbsp;&nbsp;&nbsp;support.go中的逻辑判断如果是初始化合约命令最终执行 core/chaincode/chaincode_support.go中的 Execute方法 &nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if res != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res.Status &gt;= shim.ERROR { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Errorf( &quot;[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s&quot;, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var cceventBytes []byte &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ccevent != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, errors.Wrap(err, &quot;failed to marshal event bytes&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} return pResp, &amp;chaincodeError{res.Status, res.Message} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //2 -- endorse and get a marshalled ProposalResponse message &nbsp;&nbsp;&nbsp;&nbsp; var pResp *pb.ProposalResponse &nbsp;&nbsp;&nbsp;&nbsp; //TODO till we implement global ESCC, CSCC for system chaincodes &nbsp;&nbsp;&nbsp;&nbsp; //chainless proposals (such as CSCC) don&#39;t have to be endorsed &nbsp;&nbsp;&nbsp;&nbsp; if chainID == &quot;&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp = &amp;pb.ProposalResponse{Response: res} &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if pResp != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res.Status &gt;= shim.ERRORTHRESHOLD { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debugf( &quot;[%s][%s] endorseProposal() resulted in chaincode %s error for txid: %s&quot;, chainID, shorttxid(txid), hdrExt.ChaincodeId, txid) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pResp, &amp;chaincodeError{res.Status, res.Message} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // Set the proposal response payload - it &nbsp;&nbsp;&nbsp;&nbsp; // contains the &quot;return value&quot; from the &nbsp;&nbsp;&nbsp;&nbsp; // chaincode invocation &nbsp;&nbsp;&nbsp;&nbsp;pResp.Response.Payload = res.Payload &nbsp;&nbsp;&nbsp;&nbsp; return pResp, nil } ``` ## 2、链码相关处理 * 在core/endorser/support.go 文件中 Execute方法判断是初始化还是执行合约。 ```go //Execute - execute proposal, return original response of chaincode func (s *SupportImpl) Execute(ctxt context.Context, cid, name, version, txid string, syscc bool, signedProp *pb.SignedProposal, prop *pb.Proposal, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) { &nbsp;&nbsp;&nbsp;&nbsp;cccid := ccprovider.NewCCContext(cid, name, version, txid, syscc, signedProp, prop) &nbsp;&nbsp;&nbsp;&nbsp; switch spec.(type) { &nbsp;&nbsp;&nbsp;&nbsp; case *pb.ChaincodeDeploymentSpec: &nbsp;&nbsp;&nbsp;&nbsp; //初始化 core/chaincode/exectransaction.go Execute() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chaincode.Execute(ctxt, cccid, spec) &nbsp;&nbsp;&nbsp;&nbsp; case *pb.ChaincodeInvocationSpec: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis := spec.(*pb.ChaincodeInvocationSpec) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // decorate the chaincode input &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decorators := library.InitRegistry(library.Config{}).Lookup(library.Decoration).([]decoration.Decorator) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input.Decorations = make( map[ string][] byte) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input = decoration.Apply(prop, cis.ChaincodeSpec.Input, decorators...) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cccid.ProposalDecorations = cis.ChaincodeSpec.Input.Decorations //执行合约 core/chaincode/chaincodeexec.go ExecuteChaincode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chaincode.ExecuteChaincode(ctxt, cccid, cis.ChaincodeSpec.Input.Args) &nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;programming error, unkwnown spec type&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} } ``` ## 3、初始化链码方法 core/chaincode/exectransaction.go 文件中的Execute() ```go //Execute - execute proposal, return original response of chaincode func Execute(ctxt context.Context, cccid *ccprovider.CCContext, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) { &nbsp;&nbsp;&nbsp;&nbsp; var err error &nbsp;&nbsp;&nbsp;&nbsp; var cds *pb.ChaincodeDeploymentSpec &nbsp;&nbsp;&nbsp;&nbsp; var ci *pb.ChaincodeInvocationSpec &nbsp;&nbsp;&nbsp;&nbsp; //init will call the Init method of a on a chain &nbsp;&nbsp;&nbsp;&nbsp;cctyp := pb.ChaincodeMessage_INIT &nbsp;&nbsp;&nbsp;&nbsp; if cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;Execute should be called with deployment or invocation spec&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cctyp = pb.ChaincodeMessage_TRANSACTION &nbsp;&nbsp;&nbsp;&nbsp;} //调用 core/chaincode/upchaincode_sport.go中的launch方法 &nbsp;&nbsp;&nbsp;&nbsp;_, cMsg, err := theChaincodeSupport.Launch(ctxt, cccid, spec) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cMsg.Decorations = cccid.ProposalDecorations &nbsp;&nbsp;&nbsp;&nbsp; var ccMsg *pb.ChaincodeMessage &nbsp;&nbsp;&nbsp;&nbsp;ccMsg, err = createCCMessage(cctyp, cccid.ChainID, cccid.TxID, cMsg) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.WithMessage(err, &quot;failed to create chaincode message&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} //判断chaincode是否启动，是否超时，返回结果给客户端 &nbsp;&nbsp;&nbsp;&nbsp;resp, err := theChaincodeSupport.Execute(ctxt, cccid, ccMsg, theChaincodeSupport.executetimeout) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.WithMessage(err, &quot;failed to execute transaction&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} else if resp == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Errorf( &quot;failed to receive a response for txid (%s)&quot;, cccid.TxID) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if resp.ChaincodeEvent != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.ChaincodeId = cccid.Name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.TxId = cccid.TxID &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if resp.Type == pb.ChaincodeMessage_COMPLETED { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res := &amp;pb.Response{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmarshalErr := proto.Unmarshal(resp.Payload, res) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if unmarshalErr != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Wrap(unmarshalErr, fmt.Sprintf( &quot;failed to unmarshal response for txid (%s)&quot;, cccid.TxID)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Success &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res, resp.ChaincodeEvent, nil &nbsp;&nbsp;&nbsp;&nbsp;} else if resp.Type == pb.ChaincodeMessage_ERROR { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, resp.ChaincodeEvent, errors.Errorf( &quot;transaction returned with failure: %s&quot;, string(resp.Payload)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //TODO - this should never happen ... a panic is more appropriate but will save that for future &nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Errorf( &quot;receive a response for txid (%s) but in invalid state (%d)&quot;, cccid.TxID, resp.Type) } ``` ## 4、 core/chaincode/upchaincode_sport.go 的Launch() ```go // Launch will launch the chaincode if not running (if running return nil) and will wait for handler of the chaincode to get into FSM ready state. 启动链码成功后FSM状态机推到ready状态 func (chaincodeSupport *ChaincodeSupport) Launch(context context.Context, cccid *ccprovider.CCContext, spec interface{}) (*pb.ChaincodeID, *pb.ChaincodeInput, error) { &nbsp;&nbsp;&nbsp;&nbsp; //build the chaincode &nbsp;&nbsp;&nbsp;&nbsp; var cID *pb.ChaincodeID &nbsp;&nbsp;&nbsp;&nbsp; var cMsg *pb.ChaincodeInput &nbsp;&nbsp;&nbsp;&nbsp; var cds *pb.ChaincodeDeploymentSpec &nbsp;&nbsp;&nbsp;&nbsp; var ci *pb.ChaincodeInvocationSpec &nbsp;&nbsp;&nbsp;&nbsp; if cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;Launch should be called with deployment or invocation spec&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if cds != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = cds.ChaincodeSpec.ChaincodeId &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = cds.ChaincodeSpec.Input &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = ci.ChaincodeSpec.ChaincodeId &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = ci.ChaincodeSpec.Input &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;canName := cccid.GetCanonicalName() &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Lock() &nbsp;&nbsp;&nbsp;&nbsp; var chrte *chaincodeRTEnv &nbsp;&nbsp;&nbsp;&nbsp; var ok bool &nbsp;&nbsp;&nbsp;&nbsp; var err error &nbsp;&nbsp;&nbsp;&nbsp; //if its in the map, there must be a connected stream...nothing to do &nbsp;&nbsp;&nbsp;&nbsp; if chrte, ok = chaincodeSupport.chaincodeHasBeenLaunched(canName); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !chrte.handler.registered { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf( &quot;premature execution - chaincode (%s) launched and waiting for registration&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;%+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chrte.handler.isRunning() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeLogger.IsEnabledFor(logging.DEBUG) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;chaincode is running(no need to launch) : %s&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;Container not in READY state(%s)...send init/ready&quot;, chrte.handler.FSM.Current()) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //chaincode is not up... but is the launch process underway? this is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //strictly not necessary as the actual launch process will catch this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(in launchAndWaitForRegister), just a bit of optimization for thundering &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //herds 判断链码是否启动 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeSupport.launchStarted(canName) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf( &quot;premature execution - chaincode (%s) is being launched&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp; if cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cccid.Syscc { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.Errorf( &quot;a syscc should be running (it cannot be launched) %s&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeSupport.userRunsCC { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Error( &quot;You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode. Did you forget to Deploy your chaincode?&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var depPayload []byte &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hopefully we are restarting from existing image and the deployed transaction exists &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(this will also validate the ID from the LSCC if we&#39;re not using the config-tree approach) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depPayload, err = GetCDS(context, cccid.TxID, cccid.SignedProposal, cccid.Proposal, cccid.ChainID, cID.Name) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.WithMessage(err, fmt.Sprintf( &quot;could not get ChaincodeDeploymentSpec for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if depPayload == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.WithMessage(err, fmt.Sprintf( &quot;nil ChaincodeDeploymentSpec for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = &amp;pb.ChaincodeDeploymentSpec{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get lang from original deployment &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = proto.Unmarshal(depPayload, cds) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.Wrap(err, fmt.Sprintf( &quot;failed to unmarshal deployment transactions for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //from here on : if we launch the container and get an error, we need to stop the container &nbsp;&nbsp;&nbsp;&nbsp; //launch container if it is a System container or not in dev mode &nbsp;&nbsp;&nbsp;&nbsp; if (!chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) &amp;&amp; (chrte == nil || chrte.handler == nil) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //NOTE-We need to streamline code a bit so the data from LSCC gets passed to this thus &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //avoiding the need to go to the FS. In particular, we should use cdsfs completely. It is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //just a vestige of old protocol that we continue to use ChaincodeDeploymentSpec for &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //anything other than Install. In particular, instantiate, invoke, upgrade should be using &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //just some form of ChaincodeInvocationSpec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //But for now, if we are invoking we have gone through the LSCC path above. If instantiating &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //or upgrading currently we send a CDS with nil CodePackage. In this case the codepath &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in the endorser has gone through LSCC validation. Just get the code from the FS. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cds.CodePackage == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no code bytes for these situations &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !(chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccpack, err := ccprovider.GetChaincodeFromFS(cID.Name, cID.Version) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = ccpack.GetDepSpec() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;launchAndWaitForRegister fetched %d bytes from file system&quot;, len(cds.CodePackage)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //_platforms.go中的GenerateDockerBuild作为返回值作为core.go中的BuildSpecFactory()的实现_ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder := func() (io.Reader, error) { return platforms.GenerateDockerBuild(cds) } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.launchAndWaitForRegister(context, cccid, cds, &amp;ccLauncherImpl{context, chaincodeSupport, cccid, cds, builder}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;launchAndWaitForRegister failed: %+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if err == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //launch will set the chaincode in Ready state &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.sendReady(context, cccid, chaincodeSupport.ccStartupTimeout) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.WithMessage(err, &quot;failed to init chaincode&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;%+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errIgnore := chaincodeSupport.Stop(context, cccid, cds) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if errIgnore != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;stop failed: %+v&quot;, errIgnore) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug( &quot;sending init completed&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug( &quot;LaunchChaincode complete&quot;) &nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err } ``` * 经过调用 launchAndWaitForRegister()-&gt;launch()-&gt;core/container/controller.go VMCProcess() 因为controller.go中有好几个 do() 但是在launch中传进来的确是 ```go sir := container.StartImageReq{CCID: ccid, Builder: ccl.builder, Args: args, Env: env, FilesToUpload: filesToUpload, PrelaunchFunc: preLaunchFunc} ``` ## 所以下面的VMCProcess中的 req.do 是执行的func (si StartImageReq) do(ctxt context.Context, v api.VM)VMCResp VMCReqIntf是接口定义 ccLauncherImpl结构体中的builder就是platforms.go中的GenerateDockerBuild() &nbsp;&nbsp;&nbsp;&nbsp; func VMCProcess(ctxt context.Context, vmtype string, req VMCReqIntf) (interface{}, error) VMCProcess中调用 了v.Start() //core.go中的接口vm中定义的方法，其实现在dockercontroller.go中 ## 4、 core/container包 * core/container包提供了对容器的操作 core/container/api/core.go中提供接口及函数类型定义 ```go type BuildSpecFactory func() (io.Reader, error) //坑 type PrelaunchFunc func() error type VM interface { &nbsp;&nbsp;&nbsp;&nbsp;Deploy(ctxt context.Context, ccid ccintf.CCID, args [] string, env [] string, reader io.Reader) error &nbsp;&nbsp;&nbsp;&nbsp;Start(ctxt context.Context, ccid ccintf.CCID, args [] string, env [] string, filesToUpload map[ string][] byte, builder BuildSpecFactory, preLaunchFunc PrelaunchFunc) error &nbsp;&nbsp;&nbsp;&nbsp;Stop(ctxt context.Context, ccid ccintf.CCID, timeout uint, dontkill bool, dontremove bool) error &nbsp;&nbsp;&nbsp;&nbsp;Destroy(ctxt context.Context, ccid ccintf.CCID, force bool, noprune bool) error &nbsp;&nbsp;&nbsp;&nbsp;GetVMName(ccID ccintf.CCID, format func( string) ( string, error)) ( string, error) } ``` core/container/dockercontroller/dockercontroller.go提供了对上面接口的实现,并且定义如下接口 ```go type dockerClient interface { &nbsp;&nbsp;&nbsp;&nbsp; // CreateContainer creates a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;CreateContainer(opts docker.CreateContainerOptions) (*docker.Container, error) &nbsp;&nbsp;&nbsp;&nbsp; // UploadToContainer uploads a tar archive to be extracted to a path in the &nbsp;&nbsp;&nbsp;&nbsp; // filesystem of the container. &nbsp;&nbsp;&nbsp;&nbsp;UploadToContainer(id string, opts docker.UploadToContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // StartContainer starts a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;StartContainer(id string, cfg *docker.HostConfig) error &nbsp;&nbsp;&nbsp;&nbsp; // AttachToContainer attaches to a docker container, returns an error in case of &nbsp;&nbsp;&nbsp;&nbsp; // failure &nbsp;&nbsp;&nbsp;&nbsp;AttachToContainer(opts docker.AttachToContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // BuildImage builds an image from a tarball&#39;s url or a Dockerfile in the input &nbsp;&nbsp;&nbsp;&nbsp; // stream, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;BuildImage(opts docker.BuildImageOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // RemoveImageExtended removes a docker image by its name or ID, returns an &nbsp;&nbsp;&nbsp;&nbsp; // error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;RemoveImageExtended(id string, opts docker.RemoveImageOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // StopContainer stops a docker container, killing it after the given timeout &nbsp;&nbsp;&nbsp;&nbsp; // (in seconds). Returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;StopContainer(id string, timeout uint) error &nbsp;&nbsp;&nbsp;&nbsp; // KillContainer sends a signal to a docker container, returns an error in &nbsp;&nbsp;&nbsp;&nbsp; // case of failure &nbsp;&nbsp;&nbsp;&nbsp;KillContainer(opts docker.KillContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // RemoveContainer removes a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;RemoveContainer(opts docker.RemoveContainerOptions) error } ``` * 上面dockerClient接口实现类通过方法 // getClient returns an instance that implements dockerClient interface type getClient func() (dockerClient, error) 返回其实现 类 * dockercontroller.go中的Start方法实现 Start方法控制了合约容器生成到启动的过程 /Start starts a container using a previously created docker image func (vm *DockerVM) Start(ctxt context.Context, ccid ccintf.CCID, &nbsp;&nbsp;&nbsp;&nbsp;args []string, env []string, filesToUpload map[string][]byte, builder container.BuildSpecFactory, prelaunchFunc container.PrelaunchFunc) error { &nbsp;&nbsp;&nbsp;&nbsp;imageID, err := vm.GetVMName(ccid, formatImageName) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;client, err := vm.getClientFnc() &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;start - cannot create client %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} //获取容器名称 规则 peer节点ID+domainname+合约名+随机数 &nbsp;&nbsp;&nbsp;&nbsp;containerID, err := vm.GetVMName(ccid, nil) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;attachStdout := viper.GetBool(&quot;vm.docker.attachStdout&quot;) &nbsp;&nbsp;&nbsp;&nbsp;//stop,force remove if necessary &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Cleanup container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;//根据最后两位参数选择调用 stopContainer或者killcontainer或者removecontainer &nbsp;&nbsp;&nbsp;&nbsp;vm.stopInternal(ctxt, client, containerID, 0, false, false) &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Start container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;//创建合约容器 第一次布署合约创建容器都会失败。err不会为空因为没有合约容器镜像 &nbsp;&nbsp;&nbsp;&nbsp;err = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if image not found try to create image and &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果镜像没找到则重新生成dockerfile文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err == docker.ErrNoSuchImage { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if builder != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;start-could not find image &lt;%s&gt; (container id &lt;%s&gt;), because of &lt;%s&gt;...&quot;+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attempt to recreate image&quot;, imageID, containerID, err) //********此处builder()调用 的是core/chaincdoe/platforms/platforms.go中的GenerateDockerBuild()函数********** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//********产生一个DockerFile并写到reader中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader, err1 := builder() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Error creating image builder for image &lt;%s&gt; (container id &lt;%s&gt;), &quot;+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;because of &lt;%s&gt;&quot;, imageID, containerID, err1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} //根据builder()产生的DockerFile生成一个合约镜像文件.但是在/platforms/node/platform.go中会先根据 ccenv镜像先 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//npm install 安装链码. 此处会从reader中的DockerFile 生成新的镜像(继承自fabric-baseimage) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.deployImage(client, ccid, args, env, reader); err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debug(&quot;start-recreated image successfully&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建容器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout); err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not recreate container post recreate image: %s&quot;, err1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not find image &lt;%s&gt;, because of %s&quot;, imageID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not recreate container &lt;%s&gt;, because of %s&quot;, containerID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if attachStdout { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Launch a few go-threads to manage output streams from the container. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// They will be automatically destroyed when the container exits &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//core.yml配置文件如果vm.docker.attachStdout设置为true 则会输出合约docker容器的日志信息,默认关闭 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached := make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, w := io.Pipe() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// AttachToContainer will fire off a message on the &quot;attached&quot; channel once the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// attachment completes, and then block until the container is terminated. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The returned error is not used outside the scope of this function. Assign the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error to a local variable to prevent clobbering the function variable &#39;err&#39;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := client.AttachToContainer(docker.AttachToContainerOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container: containerID, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: w, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorStream: w, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stdout: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stderr: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Success: attached, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we get here, the container has terminated. Send a signal on the pipe &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// so that downstream may clean up appropriately &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ = w.CloseWithError(err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Block here until the attachment completes or we timeout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-attached: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// successful attach &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-time.After(10 * time.Second): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Timeout while attaching to IO channel in container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acknowledge the attachment? This was included in the gist I followed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (http://bit.ly/2jBrCtM). Not sure it&#39;s actually needed but it doesn&#39;t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// appear to hurt anything. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached &lt;- struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Establish a buffer for our IO channel so that we may do readline-style &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ingestion of the IO, one log entry per line &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is := bufio.NewReader(r) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acquire a custom logger for our chaincode, inheriting the level from the peer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger := flogging.MustGetLogger(containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logging.SetLevel(logging.GetLevel(&quot;peer&quot;), containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop forever dumping lines of text into the containerLogger &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// until the pipe is closed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line, err2 := is.ReadString(&#39;\n&#39;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err2 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch err2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case io.EOF: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Infof(&quot;Container %s has closed its IO channel&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Error reading container output: %s&quot;, err2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger.Info(line) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// upload specified files to the container before starting it &nbsp;&nbsp;&nbsp;&nbsp;// this can be used for configurations such as TLS key and certs &nbsp;&nbsp;&nbsp;&nbsp;//容器启动前上传指定文件到容器内部 如ca证书文件tls证书文件 &nbsp;&nbsp;&nbsp;&nbsp;if len(filesToUpload) != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the docker upload API takes a tar file, so we need to first &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// consolidate the file entries to a tar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload := bytes.NewBuffer(nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(payload) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for path, fileToUpload := range filesToUpload { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cutil.WriteBytesToPackage(path, fileToUpload, tw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write the tar file out &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = tw.Close(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf(&quot;Error writing files to upload to Docker instance into a temporary tar blob: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = client.UploadToContainer(containerID, docker.UploadToContainerOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: bytes.NewReader(payload.Bytes()), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Path: &quot;/&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoOverwriteDirNonDir: false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf(&quot;Error uploading files to the container instance %s: %s&quot;, containerID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} //调用chaincode_support.go中preLaunchSetup() &nbsp;&nbsp;&nbsp;&nbsp;if prelaunchFunc != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = prelaunchFunc(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// start container with HostConfig was deprecated since v1.10 and removed in v1.2 &nbsp;&nbsp;&nbsp;&nbsp;//启动容器 &nbsp;&nbsp;&nbsp;&nbsp;err = client.StartContainer(containerID, nil) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not start container: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Started container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;return nil } ##5、 core/chaincode/platforms包 * core/chaincode/platforms目录，链码的编写语言平台实现，如golang或java。 platforms.go，Platform接口定义，及platforms相关工具函数。 util目录，Docker相关工具函数。 java目录，java语言平台实现。 node目录，nodejs语言平台实现。 * Platform接口定义 ```go type Platform interface { //验证ChaincodeSpec ValidateSpec(spec *pb.ChaincodeSpec) error //验证ChaincodeDeploymentSpec ValidateDeploymentSpec(spec *pb.ChaincodeDeploymentSpec) error //获取部署Payload GetDeploymentPayload(spec *pb.ChaincodeSpec) ([] byte, error) //生成Dockerfile GenerateDockerfile(spec *pb.ChaincodeDeploymentSpec) ( string, error) //生成DockerBuild GenerateDockerBuild(spec *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error } //代码在core/chaincode/platforms/platforms.go ``` ### 5.1、platforms相关工具函数 ```go //按链码类型构造Platform接口实例，如golang.Platform{} func Find(chaincodeType pb.ChaincodeSpec_Type) (Platform, error) //调取platform.GetDeploymentPayload(spec)，获取部署Payload func GetDeploymentPayload(spec *pb.ChaincodeSpec) ([] byte, error) //优先获取tls根证书，如无则获取tls证书 func getPeerTLSCert() ([] byte, error) //调取platform.GenerateDockerfile(cds)，创建Dockerfile func generateDockerfile(platform Platform, cds *pb.ChaincodeDeploymentSpec, tls bool) ([] byte, error) //调取platform.GenerateDockerBuild(cds, tw)，创建DockerBuild func generateDockerBuild(platform Platform, cds *pb.ChaincodeDeploymentSpec, inputFiles InputFiles, tw *tar.Writer) error //调取generateDockerfile(platform, cds, cert != nil) func GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, error) //代码在core/chaincode/platforms/platforms.go ``` ### 5.2 platforms介绍 * dockercontroller.go中的Start()里有build()方法调用 ，前文介绍过会调用platforms.GenerateDockerBuild() ```go func GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, error) { &nbsp;&nbsp;&nbsp;&nbsp;inputFiles := make(InputFiles) &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Determine our platform driver from the spec &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; //查找平台相关实现 Nodejs在 platforms/node/platform.go中 go在platforms/golang/platform.go中 &nbsp;&nbsp;&nbsp;&nbsp;platform, err := _Find(cds.ChaincodeSpec.Type) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, fmt.Errorf( &quot;Failed to determine platform type: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Generate the Dockerfile specific to our context &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; //生成各平台DockerFile(nodejs java go) &nbsp;&nbsp;&nbsp;&nbsp;dockerFile, err := _generateDockerfile(platform, cds) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, fmt.Errorf( &quot;Failed to generate a Dockerfile: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;inputFiles[ &quot;Dockerfile&quot;] = dockerFile &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Finally, launch an asynchronous process to stream all of the above into a docker build context &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp;input, output := io.Pipe() &nbsp;&nbsp;&nbsp;&nbsp; go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(output) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := _generateDockerBuild(platform, cds, inputFiles, tw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Error(err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.CloseWithError(err) &nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp; return input, nil } ``` * platforms/node/platform.go GenerateDockerBuild函数 func (nodePlatform *Platform) GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error { &nbsp;&nbsp;&nbsp;&nbsp;codepackage := bytes.NewReader(cds.CodePackage) &nbsp;&nbsp;&nbsp;&nbsp;binpackage := bytes.NewBuffer(nil) &nbsp;&nbsp;&nbsp;&nbsp;str :=&quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;//此处是自己修改过的代码，目的是如果环境变量里配置了 NODE_REGISTRY 则npm使用这个源 &nbsp;&nbsp;&nbsp;&nbsp;var cusRegisry = os.Getenv(&quot;NODE_REGISTRY&quot;) &nbsp;&nbsp;&nbsp;&nbsp;if cusRegisry !=&quot;&quot;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = &quot;cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm config set registry &quot;+cusRegisry+&quot; &amp;&amp; npm install --production&quot; &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = &quot;cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm install --production&quot; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;cmd........&quot;+str) //把链码传到ccenv镜像的容器里启动并安装 nodejs合约模块.网络的原因，很慢。有些模块还需要编译二进制文件，可能失败(composer 合约是这样) &nbsp;&nbsp;&nbsp;&nbsp;err := util.DockerBuild(util.DockerBuildOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cmd: fmt.Sprint(str), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: codepackage, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: binpackage, &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return cutil.WriteBytesToPackage(&quot;binpackage.tar&quot;, binpackage.Bytes(), tw) } ### 5.3、nodejs合约容器启动编译流程图 * nodejs写合约的话会先启动ccenv镜像，并在这个容器里编译nodejs合约，完成后拿到编译好的文件夹，再启 动baseimage,并且把编译好的文件放到usr/local/src下面.最后才是 npm start ...命令启动.流程图如下 ![]( nodejsdocker.png) 阅读更多" />
<meta property="og:description" content="# Fabric 1.1源代码分析之 Chaincode（链码）初始化 #ChaincodeSupport（链码支持服务端） ## 1、Endorser概述 1、Endorser相关代码分布在protos/peer/peer.pb.go和core/endorser目录。 * 在peer/node/start.go的serve（） 方法中注册了 endoser服务 serverEndorser := endorser.NewEndorserServer(privDataDist, &amp;endorser.SupportImpl{}) &nbsp;&nbsp;&nbsp;&nbsp;libConf := library.Config{} &nbsp;&nbsp;&nbsp;&nbsp;if err = viperutil.EnhancedExactUnmarshalKey(&quot;peer.handlers&quot;, &amp;libConf); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors.WithMessage(err, &quot;could not load YAML config&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;authFilters := library.InitRegistry(libConf).Lookup(library.Auth).([]authHandler.Filter) &nbsp;&nbsp;&nbsp;&nbsp;auth := authHandler.ChainFilters(serverEndorser, authFilters...) &nbsp;&nbsp;&nbsp;&nbsp;// Register the Endorser server &nbsp;&nbsp;&nbsp;&nbsp;pb.RegisterEndorserServer(peerServer.Server(), auth) * protos/peer/peer.pb.go，EndorserServer接口定义。 type EndorserServer interface { &nbsp;&nbsp;&nbsp;&nbsp;ProcessProposal(context.Context, *SignedProposal) (*ProposalResponse, error) } * core/endorser目录： * endorser.go，EndorserServer接口实现，即Endorser结构体及方法，以及EndorserServer服务端 ProcessProposal处理流程。 * endorser.go，Support接口定义及实现 type SupportImpl struct(support.go)。 ## 2、endorser中的EndorserServer接口实现方法 * // ProcessProposal process the Proposal 处理客户端传过来的提案。peer chaincode instantiate初始化合约命令也是一种提案，最终服务端此处是入口 ```go func (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error) { &nbsp;&nbsp;&nbsp;&nbsp;addr := util.ExtractRemoteAddress(ctx) &nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debug( &quot;Entering: Got request from&quot;, addr) &nbsp;&nbsp;&nbsp;&nbsp; defer endorserLogger.Debugf( &quot;Exit: request from&quot;, addr) &nbsp;&nbsp;&nbsp;&nbsp; //0 -- check and validate 对提案进行预处理，检查消息有校性及其权限 &nbsp;&nbsp;&nbsp;&nbsp;vr, err := e.preProcess(signedProp) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp := vr.resp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resp, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid &nbsp;&nbsp;&nbsp;&nbsp; // obtaining once the tx simulator for this proposal. This will be nil &nbsp;&nbsp;&nbsp;&nbsp; // for chainless proposals &nbsp;&nbsp;&nbsp;&nbsp; // Also obtain a history query executor for history queries, since tx simulator does not cover history &nbsp;&nbsp;&nbsp;&nbsp; var txsim ledger.TxSimulator &nbsp;&nbsp;&nbsp;&nbsp; var historyQueryExecutor ledger.HistoryQueryExecutor &nbsp;&nbsp;&nbsp;&nbsp; if chainID != &quot;&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if txsim, err = e.s.GetTxSimulator(chainID, txid); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the historyQueryExecutor to context &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO shouldn&#39;t we also add txsim to context here as well? Rather than passing txsim parameter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // around separately, since eventually it gets added to context anyways &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx = context.WithValue(ctx, chaincode.HistoryQueryExecutorKey, historyQueryExecutor) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defer txsim.Done() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //this could be a request to a chainless SysCC &nbsp;&nbsp;&nbsp;&nbsp; // TODO: if the proposal has an extension, it will be of type ChaincodeAction; &nbsp;&nbsp;&nbsp;&nbsp; // if it&#39;s present it means that no simulation is to be performed because &nbsp;&nbsp;&nbsp;&nbsp; // we&#39;re trying to emulate a submitting peer. On the other hand, we need &nbsp;&nbsp;&nbsp;&nbsp; // to validate the supplied action before endorsing it &nbsp;&nbsp;&nbsp;&nbsp; /*1 -- simulate //如果是扩展提案，可能是一个链码操作 调用本文件中的simulateProposal()-&gt;callChaincode()-&gt;Execute()(core/endorser/support.go switch spec.(type) {&nbsp;&nbsp;&nbsp;case *pb.ChaincodeDeploymentSpec:return chaincode.Execute(ctxt, cccid, spec)) &nbsp;&nbsp;&nbsp;&nbsp;support.go中的逻辑判断如果是初始化合约命令最终执行 core/chaincode/chaincode_support.go中的 Execute方法 &nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if res != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res.Status &gt;= shim.ERROR { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Errorf( &quot;[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s&quot;, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var cceventBytes []byte &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ccevent != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, errors.Wrap(err, &quot;failed to marshal event bytes&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} return pResp, &amp;chaincodeError{res.Status, res.Message} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //2 -- endorse and get a marshalled ProposalResponse message &nbsp;&nbsp;&nbsp;&nbsp; var pResp *pb.ProposalResponse &nbsp;&nbsp;&nbsp;&nbsp; //TODO till we implement global ESCC, CSCC for system chaincodes &nbsp;&nbsp;&nbsp;&nbsp; //chainless proposals (such as CSCC) don&#39;t have to be endorsed &nbsp;&nbsp;&nbsp;&nbsp; if chainID == &quot;&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp = &amp;pb.ProposalResponse{Response: res} &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if pResp != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res.Status &gt;= shim.ERRORTHRESHOLD { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debugf( &quot;[%s][%s] endorseProposal() resulted in chaincode %s error for txid: %s&quot;, chainID, shorttxid(txid), hdrExt.ChaincodeId, txid) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pResp, &amp;chaincodeError{res.Status, res.Message} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // Set the proposal response payload - it &nbsp;&nbsp;&nbsp;&nbsp; // contains the &quot;return value&quot; from the &nbsp;&nbsp;&nbsp;&nbsp; // chaincode invocation &nbsp;&nbsp;&nbsp;&nbsp;pResp.Response.Payload = res.Payload &nbsp;&nbsp;&nbsp;&nbsp; return pResp, nil } ``` ## 2、链码相关处理 * 在core/endorser/support.go 文件中 Execute方法判断是初始化还是执行合约。 ```go //Execute - execute proposal, return original response of chaincode func (s *SupportImpl) Execute(ctxt context.Context, cid, name, version, txid string, syscc bool, signedProp *pb.SignedProposal, prop *pb.Proposal, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) { &nbsp;&nbsp;&nbsp;&nbsp;cccid := ccprovider.NewCCContext(cid, name, version, txid, syscc, signedProp, prop) &nbsp;&nbsp;&nbsp;&nbsp; switch spec.(type) { &nbsp;&nbsp;&nbsp;&nbsp; case *pb.ChaincodeDeploymentSpec: &nbsp;&nbsp;&nbsp;&nbsp; //初始化 core/chaincode/exectransaction.go Execute() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chaincode.Execute(ctxt, cccid, spec) &nbsp;&nbsp;&nbsp;&nbsp; case *pb.ChaincodeInvocationSpec: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis := spec.(*pb.ChaincodeInvocationSpec) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // decorate the chaincode input &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decorators := library.InitRegistry(library.Config{}).Lookup(library.Decoration).([]decoration.Decorator) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input.Decorations = make( map[ string][] byte) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input = decoration.Apply(prop, cis.ChaincodeSpec.Input, decorators...) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cccid.ProposalDecorations = cis.ChaincodeSpec.Input.Decorations //执行合约 core/chaincode/chaincodeexec.go ExecuteChaincode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chaincode.ExecuteChaincode(ctxt, cccid, cis.ChaincodeSpec.Input.Args) &nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;programming error, unkwnown spec type&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} } ``` ## 3、初始化链码方法 core/chaincode/exectransaction.go 文件中的Execute() ```go //Execute - execute proposal, return original response of chaincode func Execute(ctxt context.Context, cccid *ccprovider.CCContext, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) { &nbsp;&nbsp;&nbsp;&nbsp; var err error &nbsp;&nbsp;&nbsp;&nbsp; var cds *pb.ChaincodeDeploymentSpec &nbsp;&nbsp;&nbsp;&nbsp; var ci *pb.ChaincodeInvocationSpec &nbsp;&nbsp;&nbsp;&nbsp; //init will call the Init method of a on a chain &nbsp;&nbsp;&nbsp;&nbsp;cctyp := pb.ChaincodeMessage_INIT &nbsp;&nbsp;&nbsp;&nbsp; if cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;Execute should be called with deployment or invocation spec&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cctyp = pb.ChaincodeMessage_TRANSACTION &nbsp;&nbsp;&nbsp;&nbsp;} //调用 core/chaincode/upchaincode_sport.go中的launch方法 &nbsp;&nbsp;&nbsp;&nbsp;_, cMsg, err := theChaincodeSupport.Launch(ctxt, cccid, spec) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cMsg.Decorations = cccid.ProposalDecorations &nbsp;&nbsp;&nbsp;&nbsp; var ccMsg *pb.ChaincodeMessage &nbsp;&nbsp;&nbsp;&nbsp;ccMsg, err = createCCMessage(cctyp, cccid.ChainID, cccid.TxID, cMsg) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.WithMessage(err, &quot;failed to create chaincode message&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} //判断chaincode是否启动，是否超时，返回结果给客户端 &nbsp;&nbsp;&nbsp;&nbsp;resp, err := theChaincodeSupport.Execute(ctxt, cccid, ccMsg, theChaincodeSupport.executetimeout) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.WithMessage(err, &quot;failed to execute transaction&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} else if resp == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Errorf( &quot;failed to receive a response for txid (%s)&quot;, cccid.TxID) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if resp.ChaincodeEvent != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.ChaincodeId = cccid.Name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.TxId = cccid.TxID &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if resp.Type == pb.ChaincodeMessage_COMPLETED { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res := &amp;pb.Response{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmarshalErr := proto.Unmarshal(resp.Payload, res) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if unmarshalErr != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Wrap(unmarshalErr, fmt.Sprintf( &quot;failed to unmarshal response for txid (%s)&quot;, cccid.TxID)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Success &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res, resp.ChaincodeEvent, nil &nbsp;&nbsp;&nbsp;&nbsp;} else if resp.Type == pb.ChaincodeMessage_ERROR { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, resp.ChaincodeEvent, errors.Errorf( &quot;transaction returned with failure: %s&quot;, string(resp.Payload)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //TODO - this should never happen ... a panic is more appropriate but will save that for future &nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Errorf( &quot;receive a response for txid (%s) but in invalid state (%d)&quot;, cccid.TxID, resp.Type) } ``` ## 4、 core/chaincode/upchaincode_sport.go 的Launch() ```go // Launch will launch the chaincode if not running (if running return nil) and will wait for handler of the chaincode to get into FSM ready state. 启动链码成功后FSM状态机推到ready状态 func (chaincodeSupport *ChaincodeSupport) Launch(context context.Context, cccid *ccprovider.CCContext, spec interface{}) (*pb.ChaincodeID, *pb.ChaincodeInput, error) { &nbsp;&nbsp;&nbsp;&nbsp; //build the chaincode &nbsp;&nbsp;&nbsp;&nbsp; var cID *pb.ChaincodeID &nbsp;&nbsp;&nbsp;&nbsp; var cMsg *pb.ChaincodeInput &nbsp;&nbsp;&nbsp;&nbsp; var cds *pb.ChaincodeDeploymentSpec &nbsp;&nbsp;&nbsp;&nbsp; var ci *pb.ChaincodeInvocationSpec &nbsp;&nbsp;&nbsp;&nbsp; if cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;Launch should be called with deployment or invocation spec&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if cds != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = cds.ChaincodeSpec.ChaincodeId &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = cds.ChaincodeSpec.Input &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = ci.ChaincodeSpec.ChaincodeId &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = ci.ChaincodeSpec.Input &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;canName := cccid.GetCanonicalName() &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Lock() &nbsp;&nbsp;&nbsp;&nbsp; var chrte *chaincodeRTEnv &nbsp;&nbsp;&nbsp;&nbsp; var ok bool &nbsp;&nbsp;&nbsp;&nbsp; var err error &nbsp;&nbsp;&nbsp;&nbsp; //if its in the map, there must be a connected stream...nothing to do &nbsp;&nbsp;&nbsp;&nbsp; if chrte, ok = chaincodeSupport.chaincodeHasBeenLaunched(canName); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !chrte.handler.registered { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf( &quot;premature execution - chaincode (%s) launched and waiting for registration&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;%+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chrte.handler.isRunning() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeLogger.IsEnabledFor(logging.DEBUG) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;chaincode is running(no need to launch) : %s&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;Container not in READY state(%s)...send init/ready&quot;, chrte.handler.FSM.Current()) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //chaincode is not up... but is the launch process underway? this is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //strictly not necessary as the actual launch process will catch this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(in launchAndWaitForRegister), just a bit of optimization for thundering &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //herds 判断链码是否启动 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeSupport.launchStarted(canName) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf( &quot;premature execution - chaincode (%s) is being launched&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp; if cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cccid.Syscc { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.Errorf( &quot;a syscc should be running (it cannot be launched) %s&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeSupport.userRunsCC { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Error( &quot;You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode. Did you forget to Deploy your chaincode?&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var depPayload []byte &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hopefully we are restarting from existing image and the deployed transaction exists &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(this will also validate the ID from the LSCC if we&#39;re not using the config-tree approach) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depPayload, err = GetCDS(context, cccid.TxID, cccid.SignedProposal, cccid.Proposal, cccid.ChainID, cID.Name) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.WithMessage(err, fmt.Sprintf( &quot;could not get ChaincodeDeploymentSpec for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if depPayload == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.WithMessage(err, fmt.Sprintf( &quot;nil ChaincodeDeploymentSpec for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = &amp;pb.ChaincodeDeploymentSpec{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get lang from original deployment &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = proto.Unmarshal(depPayload, cds) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.Wrap(err, fmt.Sprintf( &quot;failed to unmarshal deployment transactions for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //from here on : if we launch the container and get an error, we need to stop the container &nbsp;&nbsp;&nbsp;&nbsp; //launch container if it is a System container or not in dev mode &nbsp;&nbsp;&nbsp;&nbsp; if (!chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) &amp;&amp; (chrte == nil || chrte.handler == nil) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //NOTE-We need to streamline code a bit so the data from LSCC gets passed to this thus &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //avoiding the need to go to the FS. In particular, we should use cdsfs completely. It is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //just a vestige of old protocol that we continue to use ChaincodeDeploymentSpec for &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //anything other than Install. In particular, instantiate, invoke, upgrade should be using &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //just some form of ChaincodeInvocationSpec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //But for now, if we are invoking we have gone through the LSCC path above. If instantiating &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //or upgrading currently we send a CDS with nil CodePackage. In this case the codepath &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in the endorser has gone through LSCC validation. Just get the code from the FS. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cds.CodePackage == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no code bytes for these situations &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !(chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccpack, err := ccprovider.GetChaincodeFromFS(cID.Name, cID.Version) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = ccpack.GetDepSpec() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;launchAndWaitForRegister fetched %d bytes from file system&quot;, len(cds.CodePackage)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //_platforms.go中的GenerateDockerBuild作为返回值作为core.go中的BuildSpecFactory()的实现_ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder := func() (io.Reader, error) { return platforms.GenerateDockerBuild(cds) } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.launchAndWaitForRegister(context, cccid, cds, &amp;ccLauncherImpl{context, chaincodeSupport, cccid, cds, builder}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;launchAndWaitForRegister failed: %+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if err == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //launch will set the chaincode in Ready state &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.sendReady(context, cccid, chaincodeSupport.ccStartupTimeout) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.WithMessage(err, &quot;failed to init chaincode&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;%+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errIgnore := chaincodeSupport.Stop(context, cccid, cds) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if errIgnore != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;stop failed: %+v&quot;, errIgnore) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug( &quot;sending init completed&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug( &quot;LaunchChaincode complete&quot;) &nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err } ``` * 经过调用 launchAndWaitForRegister()-&gt;launch()-&gt;core/container/controller.go VMCProcess() 因为controller.go中有好几个 do() 但是在launch中传进来的确是 ```go sir := container.StartImageReq{CCID: ccid, Builder: ccl.builder, Args: args, Env: env, FilesToUpload: filesToUpload, PrelaunchFunc: preLaunchFunc} ``` ## 所以下面的VMCProcess中的 req.do 是执行的func (si StartImageReq) do(ctxt context.Context, v api.VM)VMCResp VMCReqIntf是接口定义 ccLauncherImpl结构体中的builder就是platforms.go中的GenerateDockerBuild() &nbsp;&nbsp;&nbsp;&nbsp; func VMCProcess(ctxt context.Context, vmtype string, req VMCReqIntf) (interface{}, error) VMCProcess中调用 了v.Start() //core.go中的接口vm中定义的方法，其实现在dockercontroller.go中 ## 4、 core/container包 * core/container包提供了对容器的操作 core/container/api/core.go中提供接口及函数类型定义 ```go type BuildSpecFactory func() (io.Reader, error) //坑 type PrelaunchFunc func() error type VM interface { &nbsp;&nbsp;&nbsp;&nbsp;Deploy(ctxt context.Context, ccid ccintf.CCID, args [] string, env [] string, reader io.Reader) error &nbsp;&nbsp;&nbsp;&nbsp;Start(ctxt context.Context, ccid ccintf.CCID, args [] string, env [] string, filesToUpload map[ string][] byte, builder BuildSpecFactory, preLaunchFunc PrelaunchFunc) error &nbsp;&nbsp;&nbsp;&nbsp;Stop(ctxt context.Context, ccid ccintf.CCID, timeout uint, dontkill bool, dontremove bool) error &nbsp;&nbsp;&nbsp;&nbsp;Destroy(ctxt context.Context, ccid ccintf.CCID, force bool, noprune bool) error &nbsp;&nbsp;&nbsp;&nbsp;GetVMName(ccID ccintf.CCID, format func( string) ( string, error)) ( string, error) } ``` core/container/dockercontroller/dockercontroller.go提供了对上面接口的实现,并且定义如下接口 ```go type dockerClient interface { &nbsp;&nbsp;&nbsp;&nbsp; // CreateContainer creates a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;CreateContainer(opts docker.CreateContainerOptions) (*docker.Container, error) &nbsp;&nbsp;&nbsp;&nbsp; // UploadToContainer uploads a tar archive to be extracted to a path in the &nbsp;&nbsp;&nbsp;&nbsp; // filesystem of the container. &nbsp;&nbsp;&nbsp;&nbsp;UploadToContainer(id string, opts docker.UploadToContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // StartContainer starts a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;StartContainer(id string, cfg *docker.HostConfig) error &nbsp;&nbsp;&nbsp;&nbsp; // AttachToContainer attaches to a docker container, returns an error in case of &nbsp;&nbsp;&nbsp;&nbsp; // failure &nbsp;&nbsp;&nbsp;&nbsp;AttachToContainer(opts docker.AttachToContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // BuildImage builds an image from a tarball&#39;s url or a Dockerfile in the input &nbsp;&nbsp;&nbsp;&nbsp; // stream, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;BuildImage(opts docker.BuildImageOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // RemoveImageExtended removes a docker image by its name or ID, returns an &nbsp;&nbsp;&nbsp;&nbsp; // error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;RemoveImageExtended(id string, opts docker.RemoveImageOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // StopContainer stops a docker container, killing it after the given timeout &nbsp;&nbsp;&nbsp;&nbsp; // (in seconds). Returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;StopContainer(id string, timeout uint) error &nbsp;&nbsp;&nbsp;&nbsp; // KillContainer sends a signal to a docker container, returns an error in &nbsp;&nbsp;&nbsp;&nbsp; // case of failure &nbsp;&nbsp;&nbsp;&nbsp;KillContainer(opts docker.KillContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // RemoveContainer removes a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;RemoveContainer(opts docker.RemoveContainerOptions) error } ``` * 上面dockerClient接口实现类通过方法 // getClient returns an instance that implements dockerClient interface type getClient func() (dockerClient, error) 返回其实现 类 * dockercontroller.go中的Start方法实现 Start方法控制了合约容器生成到启动的过程 /Start starts a container using a previously created docker image func (vm *DockerVM) Start(ctxt context.Context, ccid ccintf.CCID, &nbsp;&nbsp;&nbsp;&nbsp;args []string, env []string, filesToUpload map[string][]byte, builder container.BuildSpecFactory, prelaunchFunc container.PrelaunchFunc) error { &nbsp;&nbsp;&nbsp;&nbsp;imageID, err := vm.GetVMName(ccid, formatImageName) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;client, err := vm.getClientFnc() &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;start - cannot create client %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} //获取容器名称 规则 peer节点ID+domainname+合约名+随机数 &nbsp;&nbsp;&nbsp;&nbsp;containerID, err := vm.GetVMName(ccid, nil) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;attachStdout := viper.GetBool(&quot;vm.docker.attachStdout&quot;) &nbsp;&nbsp;&nbsp;&nbsp;//stop,force remove if necessary &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Cleanup container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;//根据最后两位参数选择调用 stopContainer或者killcontainer或者removecontainer &nbsp;&nbsp;&nbsp;&nbsp;vm.stopInternal(ctxt, client, containerID, 0, false, false) &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Start container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;//创建合约容器 第一次布署合约创建容器都会失败。err不会为空因为没有合约容器镜像 &nbsp;&nbsp;&nbsp;&nbsp;err = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if image not found try to create image and &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果镜像没找到则重新生成dockerfile文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err == docker.ErrNoSuchImage { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if builder != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;start-could not find image &lt;%s&gt; (container id &lt;%s&gt;), because of &lt;%s&gt;...&quot;+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attempt to recreate image&quot;, imageID, containerID, err) //********此处builder()调用 的是core/chaincdoe/platforms/platforms.go中的GenerateDockerBuild()函数********** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//********产生一个DockerFile并写到reader中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader, err1 := builder() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Error creating image builder for image &lt;%s&gt; (container id &lt;%s&gt;), &quot;+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;because of &lt;%s&gt;&quot;, imageID, containerID, err1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} //根据builder()产生的DockerFile生成一个合约镜像文件.但是在/platforms/node/platform.go中会先根据 ccenv镜像先 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//npm install 安装链码. 此处会从reader中的DockerFile 生成新的镜像(继承自fabric-baseimage) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.deployImage(client, ccid, args, env, reader); err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debug(&quot;start-recreated image successfully&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建容器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout); err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not recreate container post recreate image: %s&quot;, err1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not find image &lt;%s&gt;, because of %s&quot;, imageID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not recreate container &lt;%s&gt;, because of %s&quot;, containerID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if attachStdout { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Launch a few go-threads to manage output streams from the container. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// They will be automatically destroyed when the container exits &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//core.yml配置文件如果vm.docker.attachStdout设置为true 则会输出合约docker容器的日志信息,默认关闭 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached := make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, w := io.Pipe() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// AttachToContainer will fire off a message on the &quot;attached&quot; channel once the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// attachment completes, and then block until the container is terminated. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The returned error is not used outside the scope of this function. Assign the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error to a local variable to prevent clobbering the function variable &#39;err&#39;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := client.AttachToContainer(docker.AttachToContainerOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container: containerID, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: w, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorStream: w, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stdout: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stderr: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Success: attached, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we get here, the container has terminated. Send a signal on the pipe &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// so that downstream may clean up appropriately &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ = w.CloseWithError(err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Block here until the attachment completes or we timeout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-attached: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// successful attach &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-time.After(10 * time.Second): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Timeout while attaching to IO channel in container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acknowledge the attachment? This was included in the gist I followed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (http://bit.ly/2jBrCtM). Not sure it&#39;s actually needed but it doesn&#39;t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// appear to hurt anything. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached &lt;- struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Establish a buffer for our IO channel so that we may do readline-style &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ingestion of the IO, one log entry per line &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is := bufio.NewReader(r) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acquire a custom logger for our chaincode, inheriting the level from the peer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger := flogging.MustGetLogger(containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logging.SetLevel(logging.GetLevel(&quot;peer&quot;), containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop forever dumping lines of text into the containerLogger &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// until the pipe is closed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line, err2 := is.ReadString(&#39;\n&#39;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err2 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch err2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case io.EOF: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Infof(&quot;Container %s has closed its IO channel&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Error reading container output: %s&quot;, err2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger.Info(line) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// upload specified files to the container before starting it &nbsp;&nbsp;&nbsp;&nbsp;// this can be used for configurations such as TLS key and certs &nbsp;&nbsp;&nbsp;&nbsp;//容器启动前上传指定文件到容器内部 如ca证书文件tls证书文件 &nbsp;&nbsp;&nbsp;&nbsp;if len(filesToUpload) != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the docker upload API takes a tar file, so we need to first &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// consolidate the file entries to a tar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload := bytes.NewBuffer(nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(payload) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for path, fileToUpload := range filesToUpload { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cutil.WriteBytesToPackage(path, fileToUpload, tw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write the tar file out &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = tw.Close(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf(&quot;Error writing files to upload to Docker instance into a temporary tar blob: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = client.UploadToContainer(containerID, docker.UploadToContainerOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: bytes.NewReader(payload.Bytes()), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Path: &quot;/&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoOverwriteDirNonDir: false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf(&quot;Error uploading files to the container instance %s: %s&quot;, containerID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} //调用chaincode_support.go中preLaunchSetup() &nbsp;&nbsp;&nbsp;&nbsp;if prelaunchFunc != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = prelaunchFunc(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// start container with HostConfig was deprecated since v1.10 and removed in v1.2 &nbsp;&nbsp;&nbsp;&nbsp;//启动容器 &nbsp;&nbsp;&nbsp;&nbsp;err = client.StartContainer(containerID, nil) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not start container: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Started container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;return nil } ##5、 core/chaincode/platforms包 * core/chaincode/platforms目录，链码的编写语言平台实现，如golang或java。 platforms.go，Platform接口定义，及platforms相关工具函数。 util目录，Docker相关工具函数。 java目录，java语言平台实现。 node目录，nodejs语言平台实现。 * Platform接口定义 ```go type Platform interface { //验证ChaincodeSpec ValidateSpec(spec *pb.ChaincodeSpec) error //验证ChaincodeDeploymentSpec ValidateDeploymentSpec(spec *pb.ChaincodeDeploymentSpec) error //获取部署Payload GetDeploymentPayload(spec *pb.ChaincodeSpec) ([] byte, error) //生成Dockerfile GenerateDockerfile(spec *pb.ChaincodeDeploymentSpec) ( string, error) //生成DockerBuild GenerateDockerBuild(spec *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error } //代码在core/chaincode/platforms/platforms.go ``` ### 5.1、platforms相关工具函数 ```go //按链码类型构造Platform接口实例，如golang.Platform{} func Find(chaincodeType pb.ChaincodeSpec_Type) (Platform, error) //调取platform.GetDeploymentPayload(spec)，获取部署Payload func GetDeploymentPayload(spec *pb.ChaincodeSpec) ([] byte, error) //优先获取tls根证书，如无则获取tls证书 func getPeerTLSCert() ([] byte, error) //调取platform.GenerateDockerfile(cds)，创建Dockerfile func generateDockerfile(platform Platform, cds *pb.ChaincodeDeploymentSpec, tls bool) ([] byte, error) //调取platform.GenerateDockerBuild(cds, tw)，创建DockerBuild func generateDockerBuild(platform Platform, cds *pb.ChaincodeDeploymentSpec, inputFiles InputFiles, tw *tar.Writer) error //调取generateDockerfile(platform, cds, cert != nil) func GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, error) //代码在core/chaincode/platforms/platforms.go ``` ### 5.2 platforms介绍 * dockercontroller.go中的Start()里有build()方法调用 ，前文介绍过会调用platforms.GenerateDockerBuild() ```go func GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, error) { &nbsp;&nbsp;&nbsp;&nbsp;inputFiles := make(InputFiles) &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Determine our platform driver from the spec &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; //查找平台相关实现 Nodejs在 platforms/node/platform.go中 go在platforms/golang/platform.go中 &nbsp;&nbsp;&nbsp;&nbsp;platform, err := _Find(cds.ChaincodeSpec.Type) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, fmt.Errorf( &quot;Failed to determine platform type: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Generate the Dockerfile specific to our context &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; //生成各平台DockerFile(nodejs java go) &nbsp;&nbsp;&nbsp;&nbsp;dockerFile, err := _generateDockerfile(platform, cds) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, fmt.Errorf( &quot;Failed to generate a Dockerfile: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;inputFiles[ &quot;Dockerfile&quot;] = dockerFile &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Finally, launch an asynchronous process to stream all of the above into a docker build context &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp;input, output := io.Pipe() &nbsp;&nbsp;&nbsp;&nbsp; go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(output) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := _generateDockerBuild(platform, cds, inputFiles, tw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Error(err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.CloseWithError(err) &nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp; return input, nil } ``` * platforms/node/platform.go GenerateDockerBuild函数 func (nodePlatform *Platform) GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error { &nbsp;&nbsp;&nbsp;&nbsp;codepackage := bytes.NewReader(cds.CodePackage) &nbsp;&nbsp;&nbsp;&nbsp;binpackage := bytes.NewBuffer(nil) &nbsp;&nbsp;&nbsp;&nbsp;str :=&quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;//此处是自己修改过的代码，目的是如果环境变量里配置了 NODE_REGISTRY 则npm使用这个源 &nbsp;&nbsp;&nbsp;&nbsp;var cusRegisry = os.Getenv(&quot;NODE_REGISTRY&quot;) &nbsp;&nbsp;&nbsp;&nbsp;if cusRegisry !=&quot;&quot;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = &quot;cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm config set registry &quot;+cusRegisry+&quot; &amp;&amp; npm install --production&quot; &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = &quot;cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm install --production&quot; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;cmd........&quot;+str) //把链码传到ccenv镜像的容器里启动并安装 nodejs合约模块.网络的原因，很慢。有些模块还需要编译二进制文件，可能失败(composer 合约是这样) &nbsp;&nbsp;&nbsp;&nbsp;err := util.DockerBuild(util.DockerBuildOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cmd: fmt.Sprint(str), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: codepackage, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: binpackage, &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return cutil.WriteBytesToPackage(&quot;binpackage.tar&quot;, binpackage.Bytes(), tw) } ### 5.3、nodejs合约容器启动编译流程图 * nodejs写合约的话会先启动ccenv镜像，并在这个容器里编译nodejs合约，完成后拿到编译好的文件夹，再启 动baseimage,并且把编译好的文件放到usr/local/src下面.最后才是 npm start ...命令启动.流程图如下 ![]( nodejsdocker.png) 阅读更多" />
<link rel="canonical" href="http://0.0.0.0:4000/2018/06/01/Fabric-1.1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-Chaincode-%E9%93%BE%E7%A0%81-%E5%88%9D%E5%A7%8B%E5%8C%96.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2018/06/01/Fabric-1.1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-Chaincode-%E9%93%BE%E7%A0%81-%E5%88%9D%E5%A7%8B%E5%8C%96.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-01T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"# Fabric 1.1源代码分析之 Chaincode（链码）初始化 #ChaincodeSupport（链码支持服务端） ## 1、Endorser概述 1、Endorser相关代码分布在protos/peer/peer.pb.go和core/endorser目录。 * 在peer/node/start.go的serve（） 方法中注册了 endoser服务 serverEndorser := endorser.NewEndorserServer(privDataDist, &amp;endorser.SupportImpl{}) &nbsp;&nbsp;&nbsp;&nbsp;libConf := library.Config{} &nbsp;&nbsp;&nbsp;&nbsp;if err = viperutil.EnhancedExactUnmarshalKey(&quot;peer.handlers&quot;, &amp;libConf); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors.WithMessage(err, &quot;could not load YAML config&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;authFilters := library.InitRegistry(libConf).Lookup(library.Auth).([]authHandler.Filter) &nbsp;&nbsp;&nbsp;&nbsp;auth := authHandler.ChainFilters(serverEndorser, authFilters...) &nbsp;&nbsp;&nbsp;&nbsp;// Register the Endorser server &nbsp;&nbsp;&nbsp;&nbsp;pb.RegisterEndorserServer(peerServer.Server(), auth) * protos/peer/peer.pb.go，EndorserServer接口定义。 type EndorserServer interface { &nbsp;&nbsp;&nbsp;&nbsp;ProcessProposal(context.Context, *SignedProposal) (*ProposalResponse, error) } * core/endorser目录： * endorser.go，EndorserServer接口实现，即Endorser结构体及方法，以及EndorserServer服务端 ProcessProposal处理流程。 * endorser.go，Support接口定义及实现 type SupportImpl struct(support.go)。 ## 2、endorser中的EndorserServer接口实现方法 * // ProcessProposal process the Proposal 处理客户端传过来的提案。peer chaincode instantiate初始化合约命令也是一种提案，最终服务端此处是入口 ```go func (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error) { &nbsp;&nbsp;&nbsp;&nbsp;addr := util.ExtractRemoteAddress(ctx) &nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debug( &quot;Entering: Got request from&quot;, addr) &nbsp;&nbsp;&nbsp;&nbsp; defer endorserLogger.Debugf( &quot;Exit: request from&quot;, addr) &nbsp;&nbsp;&nbsp;&nbsp; //0 -- check and validate 对提案进行预处理，检查消息有校性及其权限 &nbsp;&nbsp;&nbsp;&nbsp;vr, err := e.preProcess(signedProp) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp := vr.resp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resp, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid &nbsp;&nbsp;&nbsp;&nbsp; // obtaining once the tx simulator for this proposal. This will be nil &nbsp;&nbsp;&nbsp;&nbsp; // for chainless proposals &nbsp;&nbsp;&nbsp;&nbsp; // Also obtain a history query executor for history queries, since tx simulator does not cover history &nbsp;&nbsp;&nbsp;&nbsp; var txsim ledger.TxSimulator &nbsp;&nbsp;&nbsp;&nbsp; var historyQueryExecutor ledger.HistoryQueryExecutor &nbsp;&nbsp;&nbsp;&nbsp; if chainID != &quot;&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if txsim, err = e.s.GetTxSimulator(chainID, txid); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the historyQueryExecutor to context &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO shouldn&#39;t we also add txsim to context here as well? Rather than passing txsim parameter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // around separately, since eventually it gets added to context anyways &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx = context.WithValue(ctx, chaincode.HistoryQueryExecutorKey, historyQueryExecutor) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defer txsim.Done() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //this could be a request to a chainless SysCC &nbsp;&nbsp;&nbsp;&nbsp; // TODO: if the proposal has an extension, it will be of type ChaincodeAction; &nbsp;&nbsp;&nbsp;&nbsp; // if it&#39;s present it means that no simulation is to be performed because &nbsp;&nbsp;&nbsp;&nbsp; // we&#39;re trying to emulate a submitting peer. On the other hand, we need &nbsp;&nbsp;&nbsp;&nbsp; // to validate the supplied action before endorsing it &nbsp;&nbsp;&nbsp;&nbsp; /*1 -- simulate //如果是扩展提案，可能是一个链码操作 调用本文件中的simulateProposal()-&gt;callChaincode()-&gt;Execute()(core/endorser/support.go switch spec.(type) {&nbsp;&nbsp;&nbsp;case *pb.ChaincodeDeploymentSpec:return chaincode.Execute(ctxt, cccid, spec)) &nbsp;&nbsp;&nbsp;&nbsp;support.go中的逻辑判断如果是初始化合约命令最终执行 core/chaincode/chaincode_support.go中的 Execute方法 &nbsp;&nbsp;&nbsp;&nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if res != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res.Status &gt;= shim.ERROR { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Errorf( &quot;[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s&quot;, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var cceventBytes []byte &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ccevent != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, errors.Wrap(err, &quot;failed to marshal event bytes&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} return pResp, &amp;chaincodeError{res.Status, res.Message} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //2 -- endorse and get a marshalled ProposalResponse message &nbsp;&nbsp;&nbsp;&nbsp; var pResp *pb.ProposalResponse &nbsp;&nbsp;&nbsp;&nbsp; //TODO till we implement global ESCC, CSCC for system chaincodes &nbsp;&nbsp;&nbsp;&nbsp; //chainless proposals (such as CSCC) don&#39;t have to be endorsed &nbsp;&nbsp;&nbsp;&nbsp; if chainID == &quot;&quot; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp = &amp;pb.ProposalResponse{Response: res} &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if pResp != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if res.Status &gt;= shim.ERRORTHRESHOLD { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debugf( &quot;[%s][%s] endorseProposal() resulted in chaincode %s error for txid: %s&quot;, chainID, shorttxid(txid), hdrExt.ChaincodeId, txid) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pResp, &amp;chaincodeError{res.Status, res.Message} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // Set the proposal response payload - it &nbsp;&nbsp;&nbsp;&nbsp; // contains the &quot;return value&quot; from the &nbsp;&nbsp;&nbsp;&nbsp; // chaincode invocation &nbsp;&nbsp;&nbsp;&nbsp;pResp.Response.Payload = res.Payload &nbsp;&nbsp;&nbsp;&nbsp; return pResp, nil } ``` ## 2、链码相关处理 * 在core/endorser/support.go 文件中 Execute方法判断是初始化还是执行合约。 ```go //Execute - execute proposal, return original response of chaincode func (s *SupportImpl) Execute(ctxt context.Context, cid, name, version, txid string, syscc bool, signedProp *pb.SignedProposal, prop *pb.Proposal, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) { &nbsp;&nbsp;&nbsp;&nbsp;cccid := ccprovider.NewCCContext(cid, name, version, txid, syscc, signedProp, prop) &nbsp;&nbsp;&nbsp;&nbsp; switch spec.(type) { &nbsp;&nbsp;&nbsp;&nbsp; case *pb.ChaincodeDeploymentSpec: &nbsp;&nbsp;&nbsp;&nbsp; //初始化 core/chaincode/exectransaction.go Execute() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chaincode.Execute(ctxt, cccid, spec) &nbsp;&nbsp;&nbsp;&nbsp; case *pb.ChaincodeInvocationSpec: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis := spec.(*pb.ChaincodeInvocationSpec) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // decorate the chaincode input &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decorators := library.InitRegistry(library.Config{}).Lookup(library.Decoration).([]decoration.Decorator) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input.Decorations = make( map[ string][] byte) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input = decoration.Apply(prop, cis.ChaincodeSpec.Input, decorators...) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cccid.ProposalDecorations = cis.ChaincodeSpec.Input.Decorations //执行合约 core/chaincode/chaincodeexec.go ExecuteChaincode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return chaincode.ExecuteChaincode(ctxt, cccid, cis.ChaincodeSpec.Input.Args) &nbsp;&nbsp;&nbsp;&nbsp; default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;programming error, unkwnown spec type&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} } ``` ## 3、初始化链码方法 core/chaincode/exectransaction.go 文件中的Execute() ```go //Execute - execute proposal, return original response of chaincode func Execute(ctxt context.Context, cccid *ccprovider.CCContext, spec interface{}) (*pb.Response, *pb.ChaincodeEvent, error) { &nbsp;&nbsp;&nbsp;&nbsp; var err error &nbsp;&nbsp;&nbsp;&nbsp; var cds *pb.ChaincodeDeploymentSpec &nbsp;&nbsp;&nbsp;&nbsp; var ci *pb.ChaincodeInvocationSpec &nbsp;&nbsp;&nbsp;&nbsp; //init will call the Init method of a on a chain &nbsp;&nbsp;&nbsp;&nbsp;cctyp := pb.ChaincodeMessage_INIT &nbsp;&nbsp;&nbsp;&nbsp; if cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;Execute should be called with deployment or invocation spec&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cctyp = pb.ChaincodeMessage_TRANSACTION &nbsp;&nbsp;&nbsp;&nbsp;} //调用 core/chaincode/upchaincode_sport.go中的launch方法 &nbsp;&nbsp;&nbsp;&nbsp;_, cMsg, err := theChaincodeSupport.Launch(ctxt, cccid, spec) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cMsg.Decorations = cccid.ProposalDecorations &nbsp;&nbsp;&nbsp;&nbsp; var ccMsg *pb.ChaincodeMessage &nbsp;&nbsp;&nbsp;&nbsp;ccMsg, err = createCCMessage(cctyp, cccid.ChainID, cccid.TxID, cMsg) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.WithMessage(err, &quot;failed to create chaincode message&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} //判断chaincode是否启动，是否超时，返回结果给客户端 &nbsp;&nbsp;&nbsp;&nbsp;resp, err := theChaincodeSupport.Execute(ctxt, cccid, ccMsg, theChaincodeSupport.executetimeout) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.WithMessage(err, &quot;failed to execute transaction&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} else if resp == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Errorf( &quot;failed to receive a response for txid (%s)&quot;, cccid.TxID) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if resp.ChaincodeEvent != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.ChaincodeId = cccid.Name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.TxId = cccid.TxID &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if resp.Type == pb.ChaincodeMessage_COMPLETED { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res := &amp;pb.Response{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmarshalErr := proto.Unmarshal(resp.Payload, res) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if unmarshalErr != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Wrap(unmarshalErr, fmt.Sprintf( &quot;failed to unmarshal response for txid (%s)&quot;, cccid.TxID)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Success &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return res, resp.ChaincodeEvent, nil &nbsp;&nbsp;&nbsp;&nbsp;} else if resp.Type == pb.ChaincodeMessage_ERROR { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rollback transaction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, resp.ChaincodeEvent, errors.Errorf( &quot;transaction returned with failure: %s&quot;, string(resp.Payload)) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //TODO - this should never happen ... a panic is more appropriate but will save that for future &nbsp;&nbsp;&nbsp;&nbsp; return nil, nil, errors.Errorf( &quot;receive a response for txid (%s) but in invalid state (%d)&quot;, cccid.TxID, resp.Type) } ``` ## 4、 core/chaincode/upchaincode_sport.go 的Launch() ```go // Launch will launch the chaincode if not running (if running return nil) and will wait for handler of the chaincode to get into FSM ready state. 启动链码成功后FSM状态机推到ready状态 func (chaincodeSupport *ChaincodeSupport) Launch(context context.Context, cccid *ccprovider.CCContext, spec interface{}) (*pb.ChaincodeID, *pb.ChaincodeInput, error) { &nbsp;&nbsp;&nbsp;&nbsp; //build the chaincode &nbsp;&nbsp;&nbsp;&nbsp; var cID *pb.ChaincodeID &nbsp;&nbsp;&nbsp;&nbsp; var cMsg *pb.ChaincodeInput &nbsp;&nbsp;&nbsp;&nbsp; var cds *pb.ChaincodeDeploymentSpec &nbsp;&nbsp;&nbsp;&nbsp; var ci *pb.ChaincodeInvocationSpec &nbsp;&nbsp;&nbsp;&nbsp; if cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; panic( &quot;Launch should be called with deployment or invocation spec&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if cds != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = cds.ChaincodeSpec.ChaincodeId &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = cds.ChaincodeSpec.Input &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = ci.ChaincodeSpec.ChaincodeId &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = ci.ChaincodeSpec.Input &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;canName := cccid.GetCanonicalName() &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Lock() &nbsp;&nbsp;&nbsp;&nbsp; var chrte *chaincodeRTEnv &nbsp;&nbsp;&nbsp;&nbsp; var ok bool &nbsp;&nbsp;&nbsp;&nbsp; var err error &nbsp;&nbsp;&nbsp;&nbsp; //if its in the map, there must be a connected stream...nothing to do &nbsp;&nbsp;&nbsp;&nbsp; if chrte, ok = chaincodeSupport.chaincodeHasBeenLaunched(canName); ok { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !chrte.handler.registered { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf( &quot;premature execution - chaincode (%s) launched and waiting for registration&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;%+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chrte.handler.isRunning() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeLogger.IsEnabledFor(logging.DEBUG) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;chaincode is running(no need to launch) : %s&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;Container not in READY state(%s)...send init/ready&quot;, chrte.handler.FSM.Current()) &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //chaincode is not up... but is the launch process underway? this is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //strictly not necessary as the actual launch process will catch this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(in launchAndWaitForRegister), just a bit of optimization for thundering &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //herds 判断链码是否启动 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeSupport.launchStarted(canName) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf( &quot;premature execution - chaincode (%s) is being launched&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock() &nbsp;&nbsp;&nbsp;&nbsp; if cds == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cccid.Syscc { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.Errorf( &quot;a syscc should be running (it cannot be launched) %s&quot;, canName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if chaincodeSupport.userRunsCC { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Error( &quot;You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode. Did you forget to Deploy your chaincode?&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var depPayload []byte &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //hopefully we are restarting from existing image and the deployed transaction exists &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //(this will also validate the ID from the LSCC if we&#39;re not using the config-tree approach) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depPayload, err = GetCDS(context, cccid.TxID, cccid.SignedProposal, cccid.Proposal, cccid.ChainID, cID.Name) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.WithMessage(err, fmt.Sprintf( &quot;could not get ChaincodeDeploymentSpec for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if depPayload == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.WithMessage(err, fmt.Sprintf( &quot;nil ChaincodeDeploymentSpec for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = &amp;pb.ChaincodeDeploymentSpec{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get lang from original deployment &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = proto.Unmarshal(depPayload, cds) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, errors.Wrap(err, fmt.Sprintf( &quot;failed to unmarshal deployment transactions for %s&quot;, canName)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; //from here on : if we launch the container and get an error, we need to stop the container &nbsp;&nbsp;&nbsp;&nbsp; //launch container if it is a System container or not in dev mode &nbsp;&nbsp;&nbsp;&nbsp; if (!chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) &amp;&amp; (chrte == nil || chrte.handler == nil) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //NOTE-We need to streamline code a bit so the data from LSCC gets passed to this thus &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //avoiding the need to go to the FS. In particular, we should use cdsfs completely. It is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //just a vestige of old protocol that we continue to use ChaincodeDeploymentSpec for &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //anything other than Install. In particular, instantiate, invoke, upgrade should be using &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //just some form of ChaincodeInvocationSpec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //But for now, if we are invoking we have gone through the LSCC path above. If instantiating &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //or upgrading currently we send a CDS with nil CodePackage. In this case the codepath &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //in the endorser has gone through LSCC validation. Just get the code from the FS. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if cds.CodePackage == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //no code bytes for these situations &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !(chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccpack, err := ccprovider.GetChaincodeFromFS(cID.Name, cID.Version) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = ccpack.GetDepSpec() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf( &quot;launchAndWaitForRegister fetched %d bytes from file system&quot;, len(cds.CodePackage)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //_platforms.go中的GenerateDockerBuild作为返回值作为core.go中的BuildSpecFactory()的实现_ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder := func() (io.Reader, error) { return platforms.GenerateDockerBuild(cds) } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.launchAndWaitForRegister(context, cccid, cds, &amp;ccLauncherImpl{context, chaincodeSupport, cccid, cds, builder}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;launchAndWaitForRegister failed: %+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; if err == nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //launch will set the chaincode in Ready state &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.sendReady(context, cccid, chaincodeSupport.ccStartupTimeout) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.WithMessage(err, &quot;failed to init chaincode&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;%+v&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errIgnore := chaincodeSupport.Stop(context, cccid, cds) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if errIgnore != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf( &quot;stop failed: %+v&quot;, errIgnore) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug( &quot;sending init completed&quot;) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug( &quot;LaunchChaincode complete&quot;) &nbsp;&nbsp;&nbsp;&nbsp; return cID, cMsg, err } ``` * 经过调用 launchAndWaitForRegister()-&gt;launch()-&gt;core/container/controller.go VMCProcess() 因为controller.go中有好几个 do() 但是在launch中传进来的确是 ```go sir := container.StartImageReq{CCID: ccid, Builder: ccl.builder, Args: args, Env: env, FilesToUpload: filesToUpload, PrelaunchFunc: preLaunchFunc} ``` ## 所以下面的VMCProcess中的 req.do 是执行的func (si StartImageReq) do(ctxt context.Context, v api.VM)VMCResp VMCReqIntf是接口定义 ccLauncherImpl结构体中的builder就是platforms.go中的GenerateDockerBuild() &nbsp;&nbsp;&nbsp;&nbsp; func VMCProcess(ctxt context.Context, vmtype string, req VMCReqIntf) (interface{}, error) VMCProcess中调用 了v.Start() //core.go中的接口vm中定义的方法，其实现在dockercontroller.go中 ## 4、 core/container包 * core/container包提供了对容器的操作 core/container/api/core.go中提供接口及函数类型定义 ```go type BuildSpecFactory func() (io.Reader, error) //坑 type PrelaunchFunc func() error type VM interface { &nbsp;&nbsp;&nbsp;&nbsp;Deploy(ctxt context.Context, ccid ccintf.CCID, args [] string, env [] string, reader io.Reader) error &nbsp;&nbsp;&nbsp;&nbsp;Start(ctxt context.Context, ccid ccintf.CCID, args [] string, env [] string, filesToUpload map[ string][] byte, builder BuildSpecFactory, preLaunchFunc PrelaunchFunc) error &nbsp;&nbsp;&nbsp;&nbsp;Stop(ctxt context.Context, ccid ccintf.CCID, timeout uint, dontkill bool, dontremove bool) error &nbsp;&nbsp;&nbsp;&nbsp;Destroy(ctxt context.Context, ccid ccintf.CCID, force bool, noprune bool) error &nbsp;&nbsp;&nbsp;&nbsp;GetVMName(ccID ccintf.CCID, format func( string) ( string, error)) ( string, error) } ``` core/container/dockercontroller/dockercontroller.go提供了对上面接口的实现,并且定义如下接口 ```go type dockerClient interface { &nbsp;&nbsp;&nbsp;&nbsp; // CreateContainer creates a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;CreateContainer(opts docker.CreateContainerOptions) (*docker.Container, error) &nbsp;&nbsp;&nbsp;&nbsp; // UploadToContainer uploads a tar archive to be extracted to a path in the &nbsp;&nbsp;&nbsp;&nbsp; // filesystem of the container. &nbsp;&nbsp;&nbsp;&nbsp;UploadToContainer(id string, opts docker.UploadToContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // StartContainer starts a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;StartContainer(id string, cfg *docker.HostConfig) error &nbsp;&nbsp;&nbsp;&nbsp; // AttachToContainer attaches to a docker container, returns an error in case of &nbsp;&nbsp;&nbsp;&nbsp; // failure &nbsp;&nbsp;&nbsp;&nbsp;AttachToContainer(opts docker.AttachToContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // BuildImage builds an image from a tarball&#39;s url or a Dockerfile in the input &nbsp;&nbsp;&nbsp;&nbsp; // stream, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;BuildImage(opts docker.BuildImageOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // RemoveImageExtended removes a docker image by its name or ID, returns an &nbsp;&nbsp;&nbsp;&nbsp; // error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;RemoveImageExtended(id string, opts docker.RemoveImageOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // StopContainer stops a docker container, killing it after the given timeout &nbsp;&nbsp;&nbsp;&nbsp; // (in seconds). Returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;StopContainer(id string, timeout uint) error &nbsp;&nbsp;&nbsp;&nbsp; // KillContainer sends a signal to a docker container, returns an error in &nbsp;&nbsp;&nbsp;&nbsp; // case of failure &nbsp;&nbsp;&nbsp;&nbsp;KillContainer(opts docker.KillContainerOptions) error &nbsp;&nbsp;&nbsp;&nbsp; // RemoveContainer removes a docker container, returns an error in case of failure &nbsp;&nbsp;&nbsp;&nbsp;RemoveContainer(opts docker.RemoveContainerOptions) error } ``` * 上面dockerClient接口实现类通过方法 // getClient returns an instance that implements dockerClient interface type getClient func() (dockerClient, error) 返回其实现 类 * dockercontroller.go中的Start方法实现 Start方法控制了合约容器生成到启动的过程 /Start starts a container using a previously created docker image func (vm *DockerVM) Start(ctxt context.Context, ccid ccintf.CCID, &nbsp;&nbsp;&nbsp;&nbsp;args []string, env []string, filesToUpload map[string][]byte, builder container.BuildSpecFactory, prelaunchFunc container.PrelaunchFunc) error { &nbsp;&nbsp;&nbsp;&nbsp;imageID, err := vm.GetVMName(ccid, formatImageName) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;client, err := vm.getClientFnc() &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;start - cannot create client %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} //获取容器名称 规则 peer节点ID+domainname+合约名+随机数 &nbsp;&nbsp;&nbsp;&nbsp;containerID, err := vm.GetVMName(ccid, nil) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;attachStdout := viper.GetBool(&quot;vm.docker.attachStdout&quot;) &nbsp;&nbsp;&nbsp;&nbsp;//stop,force remove if necessary &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Cleanup container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;//根据最后两位参数选择调用 stopContainer或者killcontainer或者removecontainer &nbsp;&nbsp;&nbsp;&nbsp;vm.stopInternal(ctxt, client, containerID, 0, false, false) &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Start container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;//创建合约容器 第一次布署合约创建容器都会失败。err不会为空因为没有合约容器镜像 &nbsp;&nbsp;&nbsp;&nbsp;err = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if image not found try to create image and &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果镜像没找到则重新生成dockerfile文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err == docker.ErrNoSuchImage { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if builder != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;start-could not find image &lt;%s&gt; (container id &lt;%s&gt;), because of &lt;%s&gt;...&quot;+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attempt to recreate image&quot;, imageID, containerID, err) //********此处builder()调用 的是core/chaincdoe/platforms/platforms.go中的GenerateDockerBuild()函数********** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//********产生一个DockerFile并写到reader中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader, err1 := builder() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Error creating image builder for image &lt;%s&gt; (container id &lt;%s&gt;), &quot;+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;because of &lt;%s&gt;&quot;, imageID, containerID, err1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} //根据builder()产生的DockerFile生成一个合约镜像文件.但是在/platforms/node/platform.go中会先根据 ccenv镜像先 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//npm install 安装链码. 此处会从reader中的DockerFile 生成新的镜像(继承自fabric-baseimage) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.deployImage(client, ccid, args, env, reader); err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debug(&quot;start-recreated image successfully&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建容器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout); err1 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not recreate container post recreate image: %s&quot;, err1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not find image &lt;%s&gt;, because of %s&quot;, imageID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not recreate container &lt;%s&gt;, because of %s&quot;, containerID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;if attachStdout { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Launch a few go-threads to manage output streams from the container. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// They will be automatically destroyed when the container exits &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//core.yml配置文件如果vm.docker.attachStdout设置为true 则会输出合约docker容器的日志信息,默认关闭 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached := make(chan struct{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, w := io.Pipe() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// AttachToContainer will fire off a message on the &quot;attached&quot; channel once the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// attachment completes, and then block until the container is terminated. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The returned error is not used outside the scope of this function. Assign the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error to a local variable to prevent clobbering the function variable &#39;err&#39;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := client.AttachToContainer(docker.AttachToContainerOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container: containerID, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: w, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorStream: w, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stdout: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stderr: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream: true, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Success: attached, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we get here, the container has terminated. Send a signal on the pipe &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// so that downstream may clean up appropriately &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ = w.CloseWithError(err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Block here until the attachment completes or we timeout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-attached: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// successful attach &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-time.After(10 * time.Second): &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Timeout while attaching to IO channel in container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acknowledge the attachment? This was included in the gist I followed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (http://bit.ly/2jBrCtM). Not sure it&#39;s actually needed but it doesn&#39;t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// appear to hurt anything. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached &lt;- struct{}{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Establish a buffer for our IO channel so that we may do readline-style &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ingestion of the IO, one log entry per line &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is := bufio.NewReader(r) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acquire a custom logger for our chaincode, inheriting the level from the peer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger := flogging.MustGetLogger(containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logging.SetLevel(logging.GetLevel(&quot;peer&quot;), containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop forever dumping lines of text into the containerLogger &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// until the pipe is closed &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line, err2 := is.ReadString(&#39;\\n&#39;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err2 != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch err2 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case io.EOF: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Infof(&quot;Container %s has closed its IO channel&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;Error reading container output: %s&quot;, err2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger.Info(line) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// upload specified files to the container before starting it &nbsp;&nbsp;&nbsp;&nbsp;// this can be used for configurations such as TLS key and certs &nbsp;&nbsp;&nbsp;&nbsp;//容器启动前上传指定文件到容器内部 如ca证书文件tls证书文件 &nbsp;&nbsp;&nbsp;&nbsp;if len(filesToUpload) != 0 { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the docker upload API takes a tar file, so we need to first &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// consolidate the file entries to a tar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload := bytes.NewBuffer(nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(payload) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for path, fileToUpload := range filesToUpload { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cutil.WriteBytesToPackage(path, fileToUpload, tw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write the tar file out &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = tw.Close(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf(&quot;Error writing files to upload to Docker instance into a temporary tar blob: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = client.UploadToContainer(containerID, docker.UploadToContainerOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: bytes.NewReader(payload.Bytes()), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Path: &quot;/&quot;, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoOverwriteDirNonDir: false, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf(&quot;Error uploading files to the container instance %s: %s&quot;, containerID, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} //调用chaincode_support.go中preLaunchSetup() &nbsp;&nbsp;&nbsp;&nbsp;if prelaunchFunc != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = prelaunchFunc(); err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;// start container with HostConfig was deprecated since v1.10 and removed in v1.2 &nbsp;&nbsp;&nbsp;&nbsp;//启动容器 &nbsp;&nbsp;&nbsp;&nbsp;err = client.StartContainer(containerID, nil) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf(&quot;start-could not start container: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf(&quot;Started container %s&quot;, containerID) &nbsp;&nbsp;&nbsp;&nbsp;return nil } ##5、 core/chaincode/platforms包 * core/chaincode/platforms目录，链码的编写语言平台实现，如golang或java。 platforms.go，Platform接口定义，及platforms相关工具函数。 util目录，Docker相关工具函数。 java目录，java语言平台实现。 node目录，nodejs语言平台实现。 * Platform接口定义 ```go type Platform interface { //验证ChaincodeSpec ValidateSpec(spec *pb.ChaincodeSpec) error //验证ChaincodeDeploymentSpec ValidateDeploymentSpec(spec *pb.ChaincodeDeploymentSpec) error //获取部署Payload GetDeploymentPayload(spec *pb.ChaincodeSpec) ([] byte, error) //生成Dockerfile GenerateDockerfile(spec *pb.ChaincodeDeploymentSpec) ( string, error) //生成DockerBuild GenerateDockerBuild(spec *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error } //代码在core/chaincode/platforms/platforms.go ``` ### 5.1、platforms相关工具函数 ```go //按链码类型构造Platform接口实例，如golang.Platform{} func Find(chaincodeType pb.ChaincodeSpec_Type) (Platform, error) //调取platform.GetDeploymentPayload(spec)，获取部署Payload func GetDeploymentPayload(spec *pb.ChaincodeSpec) ([] byte, error) //优先获取tls根证书，如无则获取tls证书 func getPeerTLSCert() ([] byte, error) //调取platform.GenerateDockerfile(cds)，创建Dockerfile func generateDockerfile(platform Platform, cds *pb.ChaincodeDeploymentSpec, tls bool) ([] byte, error) //调取platform.GenerateDockerBuild(cds, tw)，创建DockerBuild func generateDockerBuild(platform Platform, cds *pb.ChaincodeDeploymentSpec, inputFiles InputFiles, tw *tar.Writer) error //调取generateDockerfile(platform, cds, cert != nil) func GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, error) //代码在core/chaincode/platforms/platforms.go ``` ### 5.2 platforms介绍 * dockercontroller.go中的Start()里有build()方法调用 ，前文介绍过会调用platforms.GenerateDockerBuild() ```go func GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, error) { &nbsp;&nbsp;&nbsp;&nbsp;inputFiles := make(InputFiles) &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Determine our platform driver from the spec &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; //查找平台相关实现 Nodejs在 platforms/node/platform.go中 go在platforms/golang/platform.go中 &nbsp;&nbsp;&nbsp;&nbsp;platform, err := _Find(cds.ChaincodeSpec.Type) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, fmt.Errorf( &quot;Failed to determine platform type: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Generate the Dockerfile specific to our context &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; //生成各平台DockerFile(nodejs java go) &nbsp;&nbsp;&nbsp;&nbsp;dockerFile, err := _generateDockerfile(platform, cds) &nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nil, fmt.Errorf( &quot;Failed to generate a Dockerfile: %s&quot;, err) &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;inputFiles[ &quot;Dockerfile&quot;] = dockerFile &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp; // Finally, launch an asynchronous process to stream all of the above into a docker build context &nbsp;&nbsp;&nbsp;&nbsp; // ---------------------------------------------------------------------------------------------------- &nbsp;&nbsp;&nbsp;&nbsp;input, output := io.Pipe() &nbsp;&nbsp;&nbsp;&nbsp; go func() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(output) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := _generateDockerBuild(platform, cds, inputFiles, tw) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Error(err) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.CloseWithError(err) &nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp; return input, nil } ``` * platforms/node/platform.go GenerateDockerBuild函数 func (nodePlatform *Platform) GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error { &nbsp;&nbsp;&nbsp;&nbsp;codepackage := bytes.NewReader(cds.CodePackage) &nbsp;&nbsp;&nbsp;&nbsp;binpackage := bytes.NewBuffer(nil) &nbsp;&nbsp;&nbsp;&nbsp;str :=&quot;&quot; &nbsp;&nbsp;&nbsp;&nbsp;//此处是自己修改过的代码，目的是如果环境变量里配置了 NODE_REGISTRY 则npm使用这个源 &nbsp;&nbsp;&nbsp;&nbsp;var cusRegisry = os.Getenv(&quot;NODE_REGISTRY&quot;) &nbsp;&nbsp;&nbsp;&nbsp;if cusRegisry !=&quot;&quot;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = &quot;cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm config set registry &quot;+cusRegisry+&quot; &amp;&amp; npm install --production&quot; &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = &quot;cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm install --production&quot; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;cmd........&quot;+str) //把链码传到ccenv镜像的容器里启动并安装 nodejs合约模块.网络的原因，很慢。有些模块还需要编译二进制文件，可能失败(composer 合约是这样) &nbsp;&nbsp;&nbsp;&nbsp;err := util.DockerBuild(util.DockerBuildOptions{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cmd: fmt.Sprint(str), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: codepackage, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: binpackage, &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;if err != nil { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return cutil.WriteBytesToPackage(&quot;binpackage.tar&quot;, binpackage.Bytes(), tw) } ### 5.3、nodejs合约容器启动编译流程图 * nodejs写合约的话会先启动ccenv镜像，并在这个容器里编译nodejs合约，完成后拿到编译好的文件夹，再启 动baseimage,并且把编译好的文件放到usr/local/src下面.最后才是 npm start ...命令启动.流程图如下 ![]( nodejsdocker.png) 阅读更多","@type":"BlogPosting","url":"http://0.0.0.0:4000/2018/06/01/Fabric-1.1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-Chaincode-%E9%93%BE%E7%A0%81-%E5%88%9D%E5%A7%8B%E5%8C%96.html","headline":"Fabric 1.1源代码分析之 Chaincode（链码）初始化","dateModified":"2018-06-01T00:00:00+08:00","datePublished":"2018-06-01T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2018/06/01/Fabric-1.1%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-Chaincode-%E9%93%BE%E7%A0%81-%E5%88%9D%E5%A7%8B%E5%8C%96.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>

  </head>
  <body>
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Fabric 1.1源代码分析之 Chaincode（链码）初始化</h1>
        
        
        <ul>
            <li><a href="https://blog.uzzz.org/" target="_blank"><strong>柚子社区<br/>(国际版)</strong></a></li>
            <li><a href="https://blog.uzzz.org.cn/" target="_blank"><strong>柚子社区<br/>(国内版)</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

      <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <h1 style="line-height:1.2;border-bottom-width:1px;border-bottom-style:solid;font-weight:normal;color:rgb(0,0,0);font-family:Meiryo, 'Segoe WPC', 'Segoe UI', 'SFUIText-Light', 'HelveticaNeue-Light', sans-serif, 'Droid Sans Fallback';"></h1>
  <div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas, 'Courier New', monospace;font-size:14px;line-height:19px;">
   <div>
    <span style="color:#569cd6;"><strong># Fabric 1.1源代码分析之 Chaincode（链码）初始化 #ChaincodeSupport（链码支持服务端）</strong></span>
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 1、Endorser概述</strong></span>
   </div>
   <br>
   <div>
    1、Endorser相关代码分布在protos/peer/peer.pb.go和core/endorser目录。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> 在peer/node/start.go的serve（） 方法中注册了 endoser服务 
   </div>
   <div>
    serverEndorser := endorser.NewEndorserServer(privDataDist, &amp;endorser.SupportImpl{})
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;libConf := library.Config{}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err = viperutil.EnhancedExactUnmarshalKey("peer.handlers", &amp;libConf); err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors.WithMessage(err, "could not load YAML config")
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;authFilters := library.InitRegistry(libConf).Lookup(library.Auth).([]authHandler.Filter)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;auth := authHandler.ChainFilters(serverEndorser, authFilters...)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;// Register the Endorser server
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;pb.RegisterEndorserServer(peerServer.Server(), auth)
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> protos/peer/peer.pb.go，EndorserServer接口定义。
   </div>
   <div>
     type EndorserServer interface {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;ProcessProposal(context.Context, 
    <span style="font-style:italic;">*SignedProposal) (*</span>ProposalResponse, error)
   </div>
   <div>
     }
   </div>
   <div>
    <span style="color:#6796e6;">*</span> core/endorser目录：
   </div>
   <div> 
    <span style="color:#6796e6;">*</span> endorser.go，EndorserServer接口实现，即Endorser结构体及方法，以及EndorserServer服务端 ProcessProposal处理流程。
   </div>
   <div> 
    <span style="color:#6796e6;">*</span> endorser.go，Support接口定义及实现 type SupportImpl struct(support.go)。
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 2、endorser中的EndorserServer接口实现方法</strong></span>
   </div>
   <div>
    <span style="color:#6796e6;">*</span> // ProcessProposal process the Proposal 处理客户端传过来的提案。peer chaincode instantiate初始化合约命令也是一种提案，最终服务端此处是入口
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#569cd6;">func</span> (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, 
    <span style="color:#569cd6;">error</span>) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;addr := util.ExtractRemoteAddress(ctx)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debug(
    <span style="color:#ce9178;">"Entering: Got request from"</span>, addr)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">defer</span> endorserLogger.Debugf(
    <span style="color:#ce9178;">"Exit: request from"</span>, addr)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//0 -- check and validate 对提案进行预处理，检查消息有校性及其权限</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;vr, err := e.preProcess(signedProp)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp := vr.resp
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> resp, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// obtaining once the tx simulator for this proposal. This will be nil</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// for chainless proposals</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Also obtain a history query executor for history queries, since tx simulator does not cover history</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> txsim ledger.TxSimulator
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> historyQueryExecutor ledger.HistoryQueryExecutor
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chainID != 
    <span style="color:#ce9178;">""</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 
    <span style="color:#b5cea8;">500</span>, Message: err.Error()}}, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 
    <span style="color:#b5cea8;">500</span>, Message: err.Error()}}, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Add the historyQueryExecutor to context</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// TODO shouldn't we also add txsim to context here as well? Rather than passing txsim parameter</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// around separately, since eventually it gets added to context anyways</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx = context.WithValue(ctx, chaincode.HistoryQueryExecutorKey, historyQueryExecutor)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">defer</span> txsim.Done()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//this could be a request to a chainless SysCC</span>
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// TODO: if the proposal has an extension, it will be of type ChaincodeAction;</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// if it's present it means that no simulation is to be performed because</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// we're trying to emulate a submitting peer. On the other hand, we need</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// to validate the supplied action before endorsing it</span>
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">/*1 -- simulate //如果是扩展提案，可能是一个链码操作 调用本文件中的simulateProposal()-&gt;callChaincode()-&gt;Execute()(core/endorser/support.go switch spec.(type) {&nbsp;&nbsp;&nbsp;case *pb.ChaincodeDeploymentSpec:return chaincode.Execute(ctxt, cccid, spec))</span>
   </div>
   <div>
    <span style="color:#608b4e;">&nbsp;&nbsp;&nbsp;&nbsp;support.go中的逻辑判断如果是初始化合约命令最终执行 core/chaincode/chaincode_support.go中的 Execute方法</span>
   </div>
   <div>
    <span style="color:#608b4e;">&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 
    <span style="color:#b5cea8;">500</span>, Message: err.Error()}}, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> res != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> res.Status &gt;= shim.ERROR {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Errorf(
    <span style="color:#ce9178;">"[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s"</span>, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> cceventBytes []byte
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> ccevent != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, errors.Wrap(err, 
    <span style="color:#ce9178;">"failed to marshal event bytes"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 
    <span style="color:#b5cea8;">500</span>, Message: err.Error()}}, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div> 
    <span style="color:#c586c0;">return</span> pResp, &amp;chaincodeError{res.Status, res.Message}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//2 -- endorse and get a marshalled ProposalResponse message</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> pResp *pb.ProposalResponse
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//TODO till we implement global ESCC, CSCC for system chaincodes</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//chainless proposals (such as CSCC) don't have to be endorsed</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chainID == 
    <span style="color:#ce9178;">""</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp = &amp;pb.ProposalResponse{Response: res}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;} 
    <span style="color:#c586c0;">else</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> &amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 
    <span style="color:#b5cea8;">500</span>, Message: err.Error()}}, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> pResp != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> res.Status &gt;= shim.ERRORTHRESHOLD {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endorserLogger.Debugf(
    <span style="color:#ce9178;">"[%s][%s] endorseProposal() resulted in chaincode %s error for txid: %s"</span>, chainID, shorttxid(txid), hdrExt.ChaincodeId, txid)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> pResp, &amp;chaincodeError{res.Status, res.Message}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Set the proposal response payload - it</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// contains the "return value" from the</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// chaincode invocation</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;pResp.Response.Payload = res.Payload
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> pResp, 
    <span style="color:#569cd6;">nil</span>
   </div>
   <div>
    }
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 2、链码相关处理</strong></span>
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 在core/endorser/support.go 文件中 Execute方法判断是初始化还是执行合约。
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#608b4e;">//Execute - execute proposal, return original response of chaincode</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> (s *SupportImpl) Execute(ctxt context.Context, cid, name, version, txid 
    <span style="color:#4ec9b0;">string</span>, syscc 
    <span style="color:#4ec9b0;">bool</span>, signedProp *pb.SignedProposal, prop *pb.Proposal, spec 
    <span style="color:#569cd6;">interface</span>{}) (*pb.Response, *pb.ChaincodeEvent, 
    <span style="color:#569cd6;">error</span>) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;cccid := ccprovider.NewCCContext(cid, name, version, txid, syscc, signedProp, prop)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">switch</span> spec.(type) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">case</span> *pb.ChaincodeDeploymentSpec:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; 
    <span style="color:#608b4e;">//初始化 core/chaincode/exectransaction.go Execute()</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> chaincode.Execute(ctxt, cccid, spec)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">case</span> *pb.ChaincodeInvocationSpec:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis := spec.(*pb.ChaincodeInvocationSpec)
   </div>
   <div> 
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// decorate the chaincode input</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decorators := library.InitRegistry(library.Config{}).Lookup(library.Decoration).([]decoration.Decorator)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input.Decorations = 
    <span style="color:#dcdcaa;">make</span>(
    <span style="color:#569cd6;">map</span>[
    <span style="color:#4ec9b0;">string</span>][]
    <span style="color:#4ec9b0;">byte</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cis.ChaincodeSpec.Input = decoration.Apply(prop, cis.ChaincodeSpec.Input, decorators...)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cccid.ProposalDecorations = cis.ChaincodeSpec.Input.Decorations
   </div>
   <div> 
    <span style="color:#608b4e;">//执行合约 core/chaincode/chaincodeexec.go ExecuteChaincode</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> chaincode.ExecuteChaincode(ctxt, cccid, cis.ChaincodeSpec.Input.Args)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">default</span>:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#dcdcaa;">panic</span>(
    <span style="color:#ce9178;">"programming error, unkwnown spec type"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    }
   </div>
   <br>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 3、初始化链码方法 core/chaincode/exectransaction.go 文件中的Execute()</strong></span>
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#608b4e;">//Execute - execute proposal, return original response of chaincode</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> Execute(ctxt context.Context, cccid *ccprovider.CCContext, spec 
    <span style="color:#569cd6;">interface</span>{}) (*pb.Response, *pb.ChaincodeEvent, 
    <span style="color:#569cd6;">error</span>) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> err error
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> cds *pb.ChaincodeDeploymentSpec
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> ci *pb.ChaincodeInvocationSpec
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//init will call the Init method of a on a chain</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;cctyp := pb.ChaincodeMessage_INIT
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#dcdcaa;">panic</span>(
    <span style="color:#ce9178;">"Execute should be called with deployment or invocation spec"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cctyp = pb.ChaincodeMessage_TRANSACTION
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div> 
    <span style="color:#608b4e;">//调用 core/chaincode/upchaincode_sport.go中的launch方法</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;_, cMsg, err := theChaincodeSupport.Launch(ctxt, cccid, spec)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, 
    <span style="color:#569cd6;">nil</span>, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;cMsg.Decorations = cccid.ProposalDecorations
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> ccMsg *pb.ChaincodeMessage
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;ccMsg, err = createCCMessage(cctyp, cccid.ChainID, cccid.TxID, cMsg)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, 
    <span style="color:#569cd6;">nil</span>, errors.WithMessage(err, 
    <span style="color:#ce9178;">"failed to create chaincode message"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <br>
   <div> 
    <span style="color:#608b4e;">//判断chaincode是否启动，是否超时，返回结果给客户端</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;resp, err := theChaincodeSupport.Execute(ctxt, cccid, ccMsg, theChaincodeSupport.executetimeout)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Rollback transaction</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, 
    <span style="color:#569cd6;">nil</span>, errors.WithMessage(err, 
    <span style="color:#ce9178;">"failed to execute transaction"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;} 
    <span style="color:#c586c0;">else</span> 
    <span style="color:#c586c0;">if</span> resp == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Rollback transaction</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, 
    <span style="color:#569cd6;">nil</span>, errors.Errorf(
    <span style="color:#ce9178;">"failed to receive a response for txid (%s)"</span>, cccid.TxID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> resp.ChaincodeEvent != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.ChaincodeId = cccid.Name
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.ChaincodeEvent.TxId = cccid.TxID
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> resp.Type == pb.ChaincodeMessage_COMPLETED {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res := &amp;pb.Response{}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unmarshalErr := proto.Unmarshal(resp.Payload, res)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> unmarshalErr != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, 
    <span style="color:#569cd6;">nil</span>, errors.Wrap(unmarshalErr, fmt.Sprintf(
    <span style="color:#ce9178;">"failed to unmarshal response for txid (%s)"</span>, cccid.TxID))
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Success</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> res, resp.ChaincodeEvent, 
    <span style="color:#569cd6;">nil</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;} 
    <span style="color:#c586c0;">else</span> 
    <span style="color:#c586c0;">if</span> resp.Type == pb.ChaincodeMessage_ERROR {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Rollback transaction</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, resp.ChaincodeEvent, errors.Errorf(
    <span style="color:#ce9178;">"transaction returned with failure: %s"</span>, string(resp.Payload))
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//TODO - this should never happen ... a panic is more appropriate but will save that for future</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, 
    <span style="color:#569cd6;">nil</span>, errors.Errorf(
    <span style="color:#ce9178;">"receive a response for txid (%s) but in invalid state (%d)"</span>, cccid.TxID, resp.Type)
   </div>
   <div>
    }
   </div>
   <br>
   <br>
   <div>
    ```
   </div>
   <br>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 4、 core/chaincode/upchaincode_sport.go 的Launch()</strong></span>
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#608b4e;">// Launch will launch the chaincode if not running (if running return nil) and will wait for handler of the chaincode to get into FSM ready state. 启动链码成功后FSM状态机推到ready状态</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> (chaincodeSupport *ChaincodeSupport) Launch(context context.Context, cccid *ccprovider.CCContext, spec 
    <span style="color:#569cd6;">interface</span>{}) (*pb.ChaincodeID, *pb.ChaincodeInput, 
    <span style="color:#569cd6;">error</span>) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//build the chaincode</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> cID *pb.ChaincodeID
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> cMsg *pb.ChaincodeInput
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> cds *pb.ChaincodeDeploymentSpec
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> ci *pb.ChaincodeInvocationSpec
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#dcdcaa;">panic</span>(
    <span style="color:#ce9178;">"Launch should be called with deployment or invocation spec"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> cds != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = cds.ChaincodeSpec.ChaincodeId
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = cds.ChaincodeSpec.Input
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;} 
    <span style="color:#c586c0;">else</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cID = ci.ChaincodeSpec.ChaincodeId
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cMsg = ci.ChaincodeSpec.Input
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;canName := cccid.GetCanonicalName()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Lock()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> chrte *chaincodeRTEnv
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> ok bool
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> err error
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//if its in the map, there must be a connected stream...nothing to do</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chrte, ok = chaincodeSupport.chaincodeHasBeenLaunched(canName); ok {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> !chrte.handler.registered {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf(
    <span style="color:#ce9178;">"premature execution - chaincode (%s) launched and waiting for registration"</span>, canName)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf(
    <span style="color:#ce9178;">"%+v"</span>, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chrte.handler.isRunning() {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chaincodeLogger.IsEnabledFor(logging.DEBUG) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf(
    <span style="color:#ce9178;">"chaincode is running(no need to launch) : %s"</span>, canName)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, 
    <span style="color:#569cd6;">nil</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf(
    <span style="color:#ce9178;">"Container not in READY state(%s)...send init/ready"</span>, chrte.handler.FSM.Current())
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;} 
    <span style="color:#c586c0;">else</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//chaincode is not up... but is the launch process underway? this is</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//strictly not necessary as the actual launch process will catch this</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//(in launchAndWaitForRegister), just a bit of optimization for thundering</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//herds 判断链码是否启动</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chaincodeSupport.launchStarted(canName) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.Errorf(
    <span style="color:#ce9178;">"premature execution - chaincode (%s) is being launched"</span>, canName)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;chaincodeSupport.runningChaincodes.Unlock()
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> cds == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> cccid.Syscc {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, errors.Errorf(
    <span style="color:#ce9178;">"a syscc should be running (it cannot be launched) %s"</span>, canName)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> chaincodeSupport.userRunsCC {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Error(
    <span style="color:#ce9178;">"You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode. Did you forget to Deploy your chaincode?"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#569cd6;">var</span> depPayload []byte
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//hopefully we are restarting from existing image and the deployed transaction exists</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//(this will also validate the ID from the LSCC if we're not using the config-tree approach)</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depPayload, err = GetCDS(context, cccid.TxID, cccid.SignedProposal, cccid.Proposal, cccid.ChainID, cID.Name)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, errors.WithMessage(err, fmt.Sprintf(
    <span style="color:#ce9178;">"could not get ChaincodeDeploymentSpec for %s"</span>, canName))
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> depPayload == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, errors.WithMessage(err, fmt.Sprintf(
    <span style="color:#ce9178;">"nil ChaincodeDeploymentSpec for %s"</span>, canName))
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = &amp;pb.ChaincodeDeploymentSpec{}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//Get lang from original deployment</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = proto.Unmarshal(depPayload, cds)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, errors.Wrap(err, fmt.Sprintf(
    <span style="color:#ce9178;">"failed to unmarshal deployment transactions for %s"</span>, canName))
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//from here on : if we launch the container and get an error, we need to stop the container</span>
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//launch container if it is a System container or not in dev mode</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> (!chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) &amp;&amp; (chrte == 
    <span style="color:#569cd6;">nil</span> || chrte.handler == 
    <span style="color:#569cd6;">nil</span>) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//NOTE-We need to streamline code a bit so the data from LSCC gets passed to this thus</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//avoiding the need to go to the FS. In particular, we should use cdsfs completely. It is</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//just a vestige of old protocol that we continue to use ChaincodeDeploymentSpec for</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//anything other than Install. In particular, instantiate, invoke, upgrade should be using</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//just some form of ChaincodeInvocationSpec.</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//But for now, if we are invoking we have gone through the LSCC path above. If instantiating</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//or upgrading currently we send a CDS with nil CodePackage. In this case the codepath</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//in the endorser has gone through LSCC validation. Just get the code from the FS.</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> cds.CodePackage == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//no code bytes for these situations</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> !(chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccpack, err := ccprovider.GetChaincodeFromFS(cID.Name, cID.Version)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cds = ccpack.GetDepSpec()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debugf(
    <span style="color:#ce9178;">"launchAndWaitForRegister fetched %d bytes from file system"</span>, 
    <span style="color:#dcdcaa;">len</span>(cds.CodePackage))
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//_platforms.go中的GenerateDockerBuild作为返回值作为core.go中的BuildSpecFactory()的实现_</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder := 
    <span style="color:#569cd6;">func</span>() (io.Reader, 
    <span style="color:#569cd6;">error</span>) { 
    <span style="color:#c586c0;">return</span> platforms.GenerateDockerBuild(cds) }
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.launchAndWaitForRegister(context, cccid, cds, &amp;ccLauncherImpl{context, chaincodeSupport, cccid, cds, builder})
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf(
    <span style="color:#ce9178;">"launchAndWaitForRegister failed: %+v"</span>, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err == 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//launch will set the chaincode in Ready state</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = chaincodeSupport.sendReady(context, cccid, chaincodeSupport.ccStartupTimeout)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = errors.WithMessage(err, 
    <span style="color:#ce9178;">"failed to init chaincode"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf(
    <span style="color:#ce9178;">"%+v"</span>, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errIgnore := chaincodeSupport.Stop(context, cccid, cds)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> errIgnore != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Errorf(
    <span style="color:#ce9178;">"stop failed: %+v"</span>, errIgnore)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug(
    <span style="color:#ce9178;">"sending init completed"</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;chaincodeLogger.Debug(
    <span style="color:#ce9178;">"LaunchChaincode complete"</span>)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> cID, cMsg, err
   </div>
   <div>
    }
   </div>
   <br>
   <br>
   <div>
    ```
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 经过调用 launchAndWaitForRegister()-&gt;launch()-&gt;core/container/controller.go VMCProcess()
   </div>
   <div>
     因为controller.go中有好几个 do() 但是在launch中传进来的确是 
   </div>
   <div>
     ```go
   </div>
   <div>
     sir := container.StartImageReq{CCID: ccid, Builder: ccl.builder, Args: args, Env: env, FilesToUpload: filesToUpload, PrelaunchFunc: preLaunchFunc} 
   </div>
   <div>
     ```
   </div>
   <div>
    <span style="color:#569cd6;"><strong> ## 所以下面的VMCProcess中的 req.do 是执行的func (si StartImageReq) do(ctxt context.Context, v api.VM)VMCResp VMCReqIntf是接口定义</strong></span>
   </div>
   <div>
     ccLauncherImpl结构体中的builder就是platforms.go中的GenerateDockerBuild()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; 
   </div>
   <div>
    func VMCProcess(ctxt context.Context, vmtype string, req VMCReqIntf) (interface{}, error)
   </div>
   <br>
   <div>
    VMCProcess中调用 了v.Start() //core.go中的接口vm中定义的方法，其实现在dockercontroller.go中
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>## 4、 core/container包</strong></span>
   </div>
   <div>
    <span style="color:#6796e6;">*</span> core/container包提供了对容器的操作
   </div>
   <div>
    core/container/api/core.go中提供接口及函数类型定义
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#569cd6;">type</span> 
    <span style="color:#4ec9b0;">BuildSpecFactory</span> 
    <span style="color:#569cd6;">func</span>() (io.Reader, 
    <span style="color:#569cd6;">error</span>) 
    <span style="color:#608b4e;">//坑</span>
   </div>
   <div>
    <span style="color:#569cd6;">type</span> 
    <span style="color:#4ec9b0;">PrelaunchFunc</span> 
    <span style="color:#569cd6;">func</span>() 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    <span style="color:#569cd6;">type</span> 
    <span style="color:#4ec9b0;">VM</span> 
    <span style="color:#569cd6;">interface</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Deploy(ctxt context.Context, ccid ccintf.CCID, args []
    <span style="color:#4ec9b0;">string</span>, env []
    <span style="color:#4ec9b0;">string</span>, reader io.Reader) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Start(ctxt context.Context, ccid ccintf.CCID, args []
    <span style="color:#4ec9b0;">string</span>, env []
    <span style="color:#4ec9b0;">string</span>, filesToUpload 
    <span style="color:#569cd6;">map</span>[
    <span style="color:#4ec9b0;">string</span>][]
    <span style="color:#4ec9b0;">byte</span>, builder BuildSpecFactory, preLaunchFunc PrelaunchFunc) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Stop(ctxt context.Context, ccid ccintf.CCID, timeout 
    <span style="color:#4ec9b0;">uint</span>, dontkill 
    <span style="color:#4ec9b0;">bool</span>, dontremove 
    <span style="color:#4ec9b0;">bool</span>) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;Destroy(ctxt context.Context, ccid ccintf.CCID, force 
    <span style="color:#4ec9b0;">bool</span>, noprune 
    <span style="color:#4ec9b0;">bool</span>) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;GetVMName(ccID ccintf.CCID, format 
    <span style="color:#569cd6;">func</span>(
    <span style="color:#4ec9b0;">string</span>) (
    <span style="color:#4ec9b0;">string</span>, 
    <span style="color:#569cd6;">error</span>)) (
    <span style="color:#4ec9b0;">string</span>, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    }
   </div>
   <div>
    ```
   </div>
   <div>
    core/container/dockercontroller/dockercontroller.go提供了对上面接口的实现,并且定义如下接口
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#569cd6;">type</span> 
    <span style="color:#4ec9b0;">dockerClient</span> 
    <span style="color:#569cd6;">interface</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// CreateContainer creates a docker container, returns an error in case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;CreateContainer(opts docker.CreateContainerOptions) (*docker.Container, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// UploadToContainer uploads a tar archive to be extracted to a path in the</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// filesystem of the container.</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;UploadToContainer(id 
    <span style="color:#4ec9b0;">string</span>, opts docker.UploadToContainerOptions) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// StartContainer starts a docker container, returns an error in case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;StartContainer(id 
    <span style="color:#4ec9b0;">string</span>, cfg *docker.HostConfig) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// AttachToContainer attaches to a docker container, returns an error in case of</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;AttachToContainer(opts docker.AttachToContainerOptions) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// BuildImage builds an image from a tarball's url or a Dockerfile in the input</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// stream, returns an error in case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;BuildImage(opts docker.BuildImageOptions) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// RemoveImageExtended removes a docker image by its name or ID, returns an</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// error in case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;RemoveImageExtended(id 
    <span style="color:#4ec9b0;">string</span>, opts docker.RemoveImageOptions) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// StopContainer stops a docker container, killing it after the given timeout</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// (in seconds). Returns an error in case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;StopContainer(id 
    <span style="color:#4ec9b0;">string</span>, timeout 
    <span style="color:#4ec9b0;">uint</span>) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// KillContainer sends a signal to a docker container, returns an error in</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;KillContainer(opts docker.KillContainerOptions) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// RemoveContainer removes a docker container, returns an error in case of failure</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;RemoveContainer(opts docker.RemoveContainerOptions) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    }
   </div>
   <div>
    ```
   </div>
   <div>
    <span style="color:#6796e6;">*</span> 上面dockerClient接口实现类通过方法
   </div>
   <div>
    // getClient returns an instance that implements dockerClient interface
   </div>
   <div>
    type getClient func() (dockerClient, error) 返回其实现 类
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> dockercontroller.go中的Start方法实现 Start方法控制了合约容器生成到启动的过程
   </div>
   <div>
    /Start starts a container using a previously created docker image
   </div>
   <div>
    func (vm *DockerVM) Start(ctxt context.Context, ccid ccintf.CCID,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;args []string, env []string, filesToUpload map[string][]byte, builder container.BuildSpecFactory, prelaunchFunc container.PrelaunchFunc) error {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;imageID, err := vm.GetVMName(ccid, formatImageName)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;client, err := vm.getClientFnc()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf("start - cannot create client %s", err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
     //获取容器名称 规则 peer节点ID+domainname+合约名+随机数
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;containerID, err := vm.GetVMName(ccid, nil)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;attachStdout := viper.GetBool("vm.docker.attachStdout")
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//stop,force remove if necessary
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf("Cleanup container %s", containerID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//根据最后两位参数选择调用 stopContainer或者killcontainer或者removecontainer
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;vm.stopInternal(ctxt, client, containerID, 0, false, false)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf("Start container %s", containerID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//创建合约容器 第一次布署合约创建容器都会失败。err不会为空因为没有合约容器镜像 
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;err = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if image not found try to create image and 
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果镜像没找到则重新生成dockerfile文件
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err == docker.ErrNoSuchImage {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if builder != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf("start-could not find image &lt;%s&gt; (container id &lt;%s&gt;), because of &lt;%s&gt;..."+
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"attempt to recreate image", imageID, containerID, err)
   </div>
   <div>
     //********此处builder()调用 的是core/chaincdoe/platforms/platforms.go中的GenerateDockerBuild()函数**********
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//********产生一个DockerFile并写到reader中
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader, err1 := builder()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("Error creating image builder for image &lt;%s&gt; (container id &lt;%s&gt;), "+
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"because of &lt;%s&gt;", imageID, containerID, err1)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
     //根据builder()产生的DockerFile生成一个合约镜像文件.但是在/platforms/node/platform.go中会先根据 ccenv镜像先
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//npm install 安装链码. 此处会从reader中的DockerFile 生成新的镜像(继承自fabric-baseimage) 
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.deployImage(client, ccid, args, env, reader); err1 != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debug("start-recreated image successfully")
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建容器
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err1 = vm.createContainer(ctxt, client, imageID, containerID, args, env, attachStdout); err1 != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("start-could not recreate container post recreate image: %s", err1)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err1
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("start-could not find image &lt;%s&gt;, because of %s", imageID, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("start-could not recreate container &lt;%s&gt;, because of %s", containerID, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if attachStdout {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Launch a few go-threads to manage output streams from the container.
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// They will be automatically destroyed when the container exits
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//core.yml配置文件如果vm.docker.attachStdout设置为true 则会输出合约docker容器的日志信息,默认关闭
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached := make(chan struct{})
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, w := io.Pipe()
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// AttachToContainer will fire off a message on the "attached" channel once the
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// attachment completes, and then block until the container is terminated.
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The returned error is not used outside the scope of this function. Assign the
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error to a local variable to prevent clobbering the function variable 'err'.
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := client.AttachToContainer(docker.AttachToContainerOptions{
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container: containerID,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: w,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorStream: w,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs: true,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stdout: true,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stderr: true,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream: true,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Success: attached,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If we get here, the container has terminated. Send a signal on the pipe
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// so that downstream may clean up appropriately
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_ = w.CloseWithError(err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func() {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Block here until the attachment completes or we timeout
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-attached:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// successful attach
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lt;-time.After(10 * time.Second):
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("Timeout while attaching to IO channel in container %s", containerID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acknowledge the attachment? This was included in the gist I followed
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (http://bit.ly/2jBrCtM). Not sure it's actually needed but it doesn't
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// appear to hurt anything.
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attached &lt;- struct{}{}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Establish a buffer for our IO channel so that we may do readline-style
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ingestion of the IO, one log entry per line
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is := bufio.NewReader(r)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Acquire a custom logger for our chaincode, inheriting the level from the peer
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger := flogging.MustGetLogger(containerID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logging.SetLevel(logging.GetLevel("peer"), containerID)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop forever dumping lines of text into the containerLogger
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// until the pipe is closed
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line, err2 := is.ReadString('\n')
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err2 != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch err2 {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case io.EOF:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Infof("Container %s has closed its IO channel", containerID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("Error reading container output: %s", err2)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containerLogger.Info(line)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;// upload specified files to the container before starting it
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;// this can be used for configurations such as TLS key and certs
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//容器启动前上传指定文件到容器内部 如ca证书文件tls证书文件
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if len(filesToUpload) != 0 {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the docker upload API takes a tar file, so we need to first
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// consolidate the file entries to a tar
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload := bytes.NewBuffer(nil)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(payload)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for path, fileToUpload := range filesToUpload {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cutil.WriteBytesToPackage(path, fileToUpload, tw)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write the tar file out
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = tw.Close(); err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf("Error writing files to upload to Docker instance into a temporary tar blob: %s", err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close()
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = client.UploadToContainer(containerID, docker.UploadToContainerOptions{
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: bytes.NewReader(payload.Bytes()),
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Path: "/",
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoOverwriteDirNonDir: false,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fmt.Errorf("Error uploading files to the container instance %s: %s", containerID, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
     //调用chaincode_support.go中preLaunchSetup()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if prelaunchFunc != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err = prelaunchFunc(); err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;// start container with HostConfig was deprecated since v1.10 and removed in v1.2
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//启动容器
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;err = client.StartContainer(containerID, nil)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Errorf("start-could not start container: %s", err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;dockerLogger.Debugf("Started container %s", containerID)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;return nil
   </div>
   <div>
    }
   </div>
   <br>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>##5、 core/chaincode/platforms包</strong></span>
   </div>
   <div> 
    <span style="color:#6796e6;">*</span> core/chaincode/platforms目录，链码的编写语言平台实现，如golang或java。
   </div>
   <div>
     platforms.go，Platform接口定义，及platforms相关工具函数。
   </div>
   <div>
     util目录，Docker相关工具函数。
   </div>
   <div>
     java目录，java语言平台实现。
   </div>
   <div>
     node目录，nodejs语言平台实现。
   </div>
   <br>
   <div>
    <span style="color:#6796e6;">*</span> Platform接口定义
   </div>
   <br>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#569cd6;">type</span> 
    <span style="color:#4ec9b0;">Platform</span> 
    <span style="color:#569cd6;">interface</span> {
   </div>
   <div> 
    <span style="color:#608b4e;">//验证ChaincodeSpec</span>
   </div>
   <div>
     ValidateSpec(spec *pb.ChaincodeSpec) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div> 
    <span style="color:#608b4e;">//验证ChaincodeDeploymentSpec</span>
   </div>
   <div>
     ValidateDeploymentSpec(spec *pb.ChaincodeDeploymentSpec) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div> 
    <span style="color:#608b4e;">//获取部署Payload</span>
   </div>
   <div>
     GetDeploymentPayload(spec *pb.ChaincodeSpec) ([]
    <span style="color:#4ec9b0;">byte</span>, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div> 
    <span style="color:#608b4e;">//生成Dockerfile</span>
   </div>
   <div>
     GenerateDockerfile(spec *pb.ChaincodeDeploymentSpec) (
    <span style="color:#4ec9b0;">string</span>, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div> 
    <span style="color:#608b4e;">//生成DockerBuild</span>
   </div>
   <div>
     GenerateDockerBuild(spec *pb.ChaincodeDeploymentSpec, tw *tar.Writer) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    }
   </div>
   <div>
    <span style="color:#608b4e;">//代码在core/chaincode/platforms/platforms.go</span>
   </div>
   <div>
    ```
   </div>
   <div>
    <span style="color:#569cd6;"><strong>### 5.1、platforms相关工具函数</strong></span>
   </div>
   <br>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#608b4e;">//按链码类型构造Platform接口实例，如golang.Platform{}</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> Find(chaincodeType pb.ChaincodeSpec_Type) (Platform, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    <span style="color:#608b4e;">//调取platform.GetDeploymentPayload(spec)，获取部署Payload</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> GetDeploymentPayload(spec *pb.ChaincodeSpec) ([]
    <span style="color:#4ec9b0;">byte</span>, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    <span style="color:#608b4e;">//优先获取tls根证书，如无则获取tls证书</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> getPeerTLSCert() ([]
    <span style="color:#4ec9b0;">byte</span>, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    <span style="color:#608b4e;">//调取platform.GenerateDockerfile(cds)，创建Dockerfile</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> generateDockerfile(platform Platform, cds *pb.ChaincodeDeploymentSpec, tls 
    <span style="color:#4ec9b0;">bool</span>) ([]
    <span style="color:#4ec9b0;">byte</span>, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    <span style="color:#608b4e;">//调取platform.GenerateDockerBuild(cds, tw)，创建DockerBuild</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> generateDockerBuild(platform Platform, cds *pb.ChaincodeDeploymentSpec, inputFiles InputFiles, tw *tar.Writer) 
    <span style="color:#569cd6;">error</span>
   </div>
   <div>
    <span style="color:#608b4e;">//调取generateDockerfile(platform, cds, cert != nil)</span>
   </div>
   <div>
    <span style="color:#569cd6;">func</span> GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, 
    <span style="color:#569cd6;">error</span>)
   </div>
   <div>
    <span style="color:#608b4e;">//代码在core/chaincode/platforms/platforms.go</span>
   </div>
   <div>
    ```
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 5.2 platforms介绍</strong></span>
   </div>
   <div>
    <span style="color:#6796e6;">*</span> dockercontroller.go中的Start()里有build()方法调用 ，前文介绍过会调用platforms.GenerateDockerBuild() 
   </div>
   <div>
    ```go
   </div>
   <div>
    <span style="color:#569cd6;">func</span> GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec) (io.Reader, 
    <span style="color:#569cd6;">error</span>) {
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;inputFiles := 
    <span style="color:#dcdcaa;">make</span>(InputFiles)
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// ----------------------------------------------------------------------------------------------------</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Determine our platform driver from the spec</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// ----------------------------------------------------------------------------------------------------</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//查找平台相关实现 Nodejs在 platforms/node/platform.go中 go在platforms/golang/platform.go中</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;platform, err := _Find(cds.ChaincodeSpec.Type)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, fmt.Errorf(
    <span style="color:#ce9178;">"Failed to determine platform type: %s"</span>, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// ----------------------------------------------------------------------------------------------------</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Generate the Dockerfile specific to our context</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// ----------------------------------------------------------------------------------------------------</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//生成各平台DockerFile(nodejs java go)</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;dockerFile, err := _generateDockerfile(platform, cds)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> 
    <span style="color:#569cd6;">nil</span>, fmt.Errorf(
    <span style="color:#ce9178;">"Failed to generate a Dockerfile: %s"</span>, err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;inputFiles[
    <span style="color:#ce9178;">"Dockerfile"</span>] = dockerFile
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// ----------------------------------------------------------------------------------------------------</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// Finally, launch an asynchronous process to stream all of the above into a docker build context</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">// ----------------------------------------------------------------------------------------------------</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;input, output := io.Pipe()
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">go</span> 
    <span style="color:#569cd6;">func</span>() {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw := gzip.NewWriter(output)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw := tar.NewWriter(gw)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#608b4e;">//生成镜像</span>
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := _generateDockerBuild(platform, cds, inputFiles, tw)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">if</span> err != 
    <span style="color:#569cd6;">nil</span> {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.Error(err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tw.Close()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gw.Close()
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.CloseWithError(err)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}()
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <span style="color:#c586c0;">return</span> input, 
    <span style="color:#569cd6;">nil</span>
   </div>
   <div>
    }
   </div>
   <br>
   <br>
   <div>
    ```
   </div>
   <div>
    <span style="color:#6796e6;">*</span> platforms/node/platform.go GenerateDockerBuild函数 
   </div>
   <br>
   <div>
    func (nodePlatform *Platform) GenerateDockerBuild(cds *pb.ChaincodeDeploymentSpec, tw *tar.Writer) error {
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;codepackage := bytes.NewReader(cds.CodePackage)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;binpackage := bytes.NewBuffer(nil)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;str :=""
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;//此处是自己修改过的代码，目的是如果环境变量里配置了 NODE_REGISTRY 则npm使用这个源
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;var cusRegisry = os.Getenv("NODE_REGISTRY")
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if cusRegisry !=""{
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = "cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm config set registry "+cusRegisry+" &amp;&amp; npm install --production"
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;} else {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str = "cp -R /chaincode/input/src/. /chaincode/output &amp;&amp; cd /chaincode/output &amp;&amp; npm install --production"
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;fmt.Println("cmd........"+str)
   </div>
   <div>
     //把链码传到ccenv镜像的容器里启动并安装 nodejs合约模块.网络的原因，很慢。有些模块还需要编译二进制文件，可能失败(composer 合约是这样)
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;err := util.DockerBuild(util.DockerBuildOptions{
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cmd: fmt.Sprint(str),
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream: codepackage,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream: binpackage,
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;})
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;if err != nil {
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err
   </div>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;}
   </div>
   <br>
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;return cutil.WriteBytesToPackage("binpackage.tar", binpackage.Bytes(), tw)
   </div>
   <div>
    }
   </div>
   <br>
   <div>
    <span style="color:#569cd6;"><strong>### 5.3、nodejs合约容器启动编译流程图</strong></span>
   </div>
   <div>
    <span style="color:#6796e6;">*</span> nodejs写合约的话会先启动ccenv镜像，并在这个容器里编译nodejs合约，完成后拿到编译好的文件夹，再启
   </div>
   <div>
    动baseimage,并且把编译好的文件放到usr/local/src下面.最后才是 npm start ...命令启动.流程图如下
   </div>
   <div>
    ![](
    <span>nodejsdocker.png</span>)
    <img src="https://img-blog.csdn.net/20180601170720728" alt="">
   </div>
  </div>
  <ul style="color:rgb(0,0,0);font-family:Meiryo, 'Segoe WPC', 'Segoe UI', 'SFUIText-Light', 'HelveticaNeue-Light', sans-serif, 'Droid Sans Fallback';font-size:14px;">
   <li><br></li>
  </ul> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/foolone/article/details/80540340,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/foolone/article/details/80540340,&quot;}">阅读更多</a> 
</div>
      <br />
        <a href="https://blog.uzzz.org/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://blog.uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://blog.uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>

  </body>
</html>
