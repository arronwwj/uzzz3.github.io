<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>重磅！美图技术团队发布开源 ethereum dpos 实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="重磅！美图技术团队发布开源 ethereum dpos 实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者：美图技术团队 链接：https://zhuanlan.zhihu.com/p/38013479 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 导语：目前以太坊采用 PoW 算法，并计划逐步替换成 PoS，是否有可能在以太坊上引入 DPoS 算法？美图区块链实验室在区块链方面做了很多的研究，共识算法是其中重点研究的一个方向，最近，美图技术团队在以太坊上成功实现 DPoS 算法，并通过本文对算法思路及源码进行了详细介绍。 本文介绍了近期美图区块链实验室在学习和研究区块链技术的过程中的一些成果。Ethereum是比较成熟和智能化的案例，对我们日后发展区块链技术有相当的借鉴性，因此选择其作为研究对象。 我们基于 Ethereum(1.7.3版本) 实现 DPoS 共识算法主要有两个⽬的, ⼀个是我们之前主要是通过看代码的⽅式来研究区块链的⼀些技术，修改代码可以进⼀步加深和巩固代码设计上的理解。另外⼀点是通过将修改的代码开源，吸引更多的⼈来关注这个项⽬，那么也算是对社区的⼀种回馈。 Github 地址: meitu/go-ethereum 共识算法 开始分析 DPoS 实现之前，先简单介绍一下当前几个主流的数字货币共识算法。下面罗列的只是一部分共识算法，还有其他许多算法没有提及，罗列的顺序以及时间序不代表算法的优劣。 1.PoW(Proof of Work) 1993 年由 Cynthia Dwork 和 Moni Naor 提出，主要是用来解决垃圾邮件问题 2009 年 Satoshi 使用 PoW 作为 bitcoin 的共识算法，PoW 成为区块链第一个共识算法。随着 GPU 挖矿算法的出现, Satoshi 预期的每个 CPU 一票的机制被破坏 2011年 莱特币(比特币的第一个山寨币)， 采用 scrypt(由一个黑客发明) ，特点是挖矿需要更多内存以及并行计算困难，相比 SHA256 更加能够抵御矿机， 但由于安全性上没有经过严格的验证所以并未大规模应用 2013 年 primecoin 把算力用来寻找最大素数，解决算力浪费问题 2015 年 etherum 使用 PoW 作为共识算法, 提出 dagger-hashimoto 的改良版本，具备内存难解性以及更好的抵抗 ASIC 算法可以简单描述如下: hash(B) ⩽ M/D (1), 其中 D ∈ [1, M], hash = sha256" />
<meta property="og:description" content="作者：美图技术团队 链接：https://zhuanlan.zhihu.com/p/38013479 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 导语：目前以太坊采用 PoW 算法，并计划逐步替换成 PoS，是否有可能在以太坊上引入 DPoS 算法？美图区块链实验室在区块链方面做了很多的研究，共识算法是其中重点研究的一个方向，最近，美图技术团队在以太坊上成功实现 DPoS 算法，并通过本文对算法思路及源码进行了详细介绍。 本文介绍了近期美图区块链实验室在学习和研究区块链技术的过程中的一些成果。Ethereum是比较成熟和智能化的案例，对我们日后发展区块链技术有相当的借鉴性，因此选择其作为研究对象。 我们基于 Ethereum(1.7.3版本) 实现 DPoS 共识算法主要有两个⽬的, ⼀个是我们之前主要是通过看代码的⽅式来研究区块链的⼀些技术，修改代码可以进⼀步加深和巩固代码设计上的理解。另外⼀点是通过将修改的代码开源，吸引更多的⼈来关注这个项⽬，那么也算是对社区的⼀种回馈。 Github 地址: meitu/go-ethereum 共识算法 开始分析 DPoS 实现之前，先简单介绍一下当前几个主流的数字货币共识算法。下面罗列的只是一部分共识算法，还有其他许多算法没有提及，罗列的顺序以及时间序不代表算法的优劣。 1.PoW(Proof of Work) 1993 年由 Cynthia Dwork 和 Moni Naor 提出，主要是用来解决垃圾邮件问题 2009 年 Satoshi 使用 PoW 作为 bitcoin 的共识算法，PoW 成为区块链第一个共识算法。随着 GPU 挖矿算法的出现, Satoshi 预期的每个 CPU 一票的机制被破坏 2011年 莱特币(比特币的第一个山寨币)， 采用 scrypt(由一个黑客发明) ，特点是挖矿需要更多内存以及并行计算困难，相比 SHA256 更加能够抵御矿机， 但由于安全性上没有经过严格的验证所以并未大规模应用 2013 年 primecoin 把算力用来寻找最大素数，解决算力浪费问题 2015 年 etherum 使用 PoW 作为共识算法, 提出 dagger-hashimoto 的改良版本，具备内存难解性以及更好的抵抗 ASIC 算法可以简单描述如下: hash(B) ⩽ M/D (1), 其中 D ∈ [1, M], hash = sha256" />
<link rel="canonical" href="http://0.0.0.0:4000/2018/06/19/%E9%87%8D%E7%A3%85-%E7%BE%8E%E5%9B%BE%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90-ethereum-dpos-%E5%AE%9E%E7%8E%B0.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2018/06/19/%E9%87%8D%E7%A3%85-%E7%BE%8E%E5%9B%BE%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90-ethereum-dpos-%E5%AE%9E%E7%8E%B0.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-19T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者：美图技术团队 链接：https://zhuanlan.zhihu.com/p/38013479 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 导语：目前以太坊采用 PoW 算法，并计划逐步替换成 PoS，是否有可能在以太坊上引入 DPoS 算法？美图区块链实验室在区块链方面做了很多的研究，共识算法是其中重点研究的一个方向，最近，美图技术团队在以太坊上成功实现 DPoS 算法，并通过本文对算法思路及源码进行了详细介绍。 本文介绍了近期美图区块链实验室在学习和研究区块链技术的过程中的一些成果。Ethereum是比较成熟和智能化的案例，对我们日后发展区块链技术有相当的借鉴性，因此选择其作为研究对象。 我们基于 Ethereum(1.7.3版本) 实现 DPoS 共识算法主要有两个⽬的, ⼀个是我们之前主要是通过看代码的⽅式来研究区块链的⼀些技术，修改代码可以进⼀步加深和巩固代码设计上的理解。另外⼀点是通过将修改的代码开源，吸引更多的⼈来关注这个项⽬，那么也算是对社区的⼀种回馈。 Github 地址: meitu/go-ethereum 共识算法 开始分析 DPoS 实现之前，先简单介绍一下当前几个主流的数字货币共识算法。下面罗列的只是一部分共识算法，还有其他许多算法没有提及，罗列的顺序以及时间序不代表算法的优劣。 1.PoW(Proof of Work) 1993 年由 Cynthia Dwork 和 Moni Naor 提出，主要是用来解决垃圾邮件问题 2009 年 Satoshi 使用 PoW 作为 bitcoin 的共识算法，PoW 成为区块链第一个共识算法。随着 GPU 挖矿算法的出现, Satoshi 预期的每个 CPU 一票的机制被破坏 2011年 莱特币(比特币的第一个山寨币)， 采用 scrypt(由一个黑客发明) ，特点是挖矿需要更多内存以及并行计算困难，相比 SHA256 更加能够抵御矿机， 但由于安全性上没有经过严格的验证所以并未大规模应用 2013 年 primecoin 把算力用来寻找最大素数，解决算力浪费问题 2015 年 etherum 使用 PoW 作为共识算法, 提出 dagger-hashimoto 的改良版本，具备内存难解性以及更好的抵抗 ASIC 算法可以简单描述如下: hash(B) ⩽ M/D (1), 其中 D ∈ [1, M], hash = sha256","@type":"BlogPosting","url":"http://0.0.0.0:4000/2018/06/19/%E9%87%8D%E7%A3%85-%E7%BE%8E%E5%9B%BE%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90-ethereum-dpos-%E5%AE%9E%E7%8E%B0.html","headline":"重磅！美图技术团队发布开源 ethereum dpos 实现","dateModified":"2018-06-19T00:00:00+08:00","datePublished":"2018-06-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2018/06/19/%E9%87%8D%E7%A3%85-%E7%BE%8E%E5%9B%BE%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90-ethereum-dpos-%E5%AE%9E%E7%8E%B0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>

  </head>
  <body>
    <div class="wrapper">
      <header  class="without-description" >
        <h1>重磅！美图技术团队发布开源 ethereum dpos 实现</h1>
        
        
        <ul>
            <li><a href="https://blog.uzzz.org/" target="_blank"><strong>柚子社区<br/>(国际版)</strong></a></li>
            <li><a href="https://blog.uzzz.org.cn/" target="_blank"><strong>柚子社区<br/>(国内版)</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

      <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div>
   作者：美图技术团队
   <br>链接：https://zhuanlan.zhihu.com/p/38013479
   <br>来源：知乎
   <br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   <br>
   <br>
   <div>
    <p>导语：目前以太坊采用 PoW 算法，并计划逐步替换成 PoS，是否有可能在以太坊上引入 DPoS 算法？美图区块链实验室在区块链方面做了很多的研究，共识算法是其中重点研究的一个方向，最近，美图技术团队在以太坊上成功实现 DPoS 算法，并通过本文对算法思路及源码进行了详细介绍。</p>
    <hr>
    <p>本文介绍了近期美图区块链实验室在学习和研究区块链技术的过程中的一些成果。Ethereum是比较成熟和智能化的案例，对我们日后发展区块链技术有相当的借鉴性，因此选择其作为研究对象。</p>
    <p>我们基于 Ethereum(1.7.3版本) 实现 DPoS 共识算法主要有两个⽬的, ⼀个是我们之前主要是通过看代码的⽅式来研究区块链的⼀些技术，修改代码可以进⼀步加深和巩固代码设计上的理解。另外⼀点是通过将修改的代码开源，吸引更多的⼈来关注这个项⽬，那么也算是对社区的⼀种回馈。</p>
    <p>Github 地址: <a href="http://link.zhihu.com/?target=https%3A//github.com/meitu/go-ethereum" rel="nofollow" class="wrap external">meitu/go-ethereum</a></p>
    <h2><strong>共识算法</strong></h2>
    <p>开始分析 DPoS 实现之前，先简单介绍一下当前几个主流的数字货币共识算法。下面罗列的只是一部分共识算法，还有其他许多算法没有提及，罗列的顺序以及时间序不代表算法的优劣。</p>
    <p><br></p>
    <p><strong>1.PoW(Proof of Work)</strong></p>
    <ul>
     <li>1993 年由 Cynthia Dwork 和 Moni Naor 提出，主要是用来解决垃圾邮件问题</li>
     <li>2009 年 Satoshi 使用 PoW 作为 bitcoin 的共识算法，PoW 成为区块链第一个共识算法。随着 GPU 挖矿算法的出现, Satoshi 预期的每个 CPU 一票的机制被破坏</li>
     <li>2011年 莱特币(比特币的第一个山寨币)， 采用 scrypt(由一个黑客发明) ，特点是挖矿需要更多内存以及并行计算困难，相比 SHA256 更加能够抵御矿机， 但由于安全性上没有经过严格的验证所以并未大规模应用</li>
     <li>2013 年 primecoin 把算力用来寻找最大素数，解决算力浪费问题</li>
     <li>2015 年 etherum 使用 PoW 作为共识算法, 提出 dagger-hashimoto 的改良版本，具备内存难解性以及更好的抵抗 ASIC</li>
    </ul>
    <p>算法可以简单描述如下:</p>
    <div class="highlight">
     <pre><code class="language-go"><span class="nx">hash</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span> <span class="err">⩽</span> <span class="nx">M</span><span class="o">/</span><span class="nx">D</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="err">其中</span> <span class="nx">D</span> <span class="err">∈</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nx">M</span><span class="p">],</span> <span class="nx">hash</span> <span class="p">=</span> <span class="nx">sha256</span>

<span class="c1">// M 在不同算法里面设置的可能会不一样，我们这里可以认为就是常量</span>
<span class="c1">// D 就是目标难度，D 值越大, M 为常量，那么 M/D 就会越小，所以要使用 hash 找出小于这个值就会越难</span>
</code></pre>
    </div>
    <p>PoW 不断穷举的方式找到满足条件的整数需要消耗大量的计算资源， 而算力纯粹是为了找到一个没有任何意义的随机数，这成为大家诟病 PoW 的重要原因之一，现在有一些团队正在尝试把这些算力结合到现实中的一些场景，比如 AI 模型计算等。PoW 另外一个问题就是性能低下，当前比特币的性能差不多在 7 qps 左右，以太坊大概是比特币的两倍。现在比较知名的 offchain的 代表 lightning 主要就是为了解决比特币的性能问题，还有就是 V 神正在做的 ethereum sharding 等。</p>
    <p><br></p>
    <p><strong>2.PoS(Proof of Stake)</strong></p>
    <ul>
     <li>2012 年 sunny king 提出 PoS 算法， 主要是为了解决 PoW 对于算力消耗过大的问题</li>
     <li>2013 年 peercoin 首个实现 PoS 的数字货币但仍然保留 PoW。PoW 作为冷启动阶段使用，后续逐步降低 PoW 权重。同时使用币龄(coin age) 来解决财富累积的问题，这个也引入新的问题(下面的提到的币龄累积问题)。</li>
     <li>2013 年 11 月 NXT 实现了首个纯 PoS 的数字货币</li>
     <li>2014 年 blackcoin 也使用 PoS 作为共识算法同时去掉了币龄</li>
    </ul>
    <p>PoS 算法描述如下：</p>
    <div class="highlight">
     <pre><code class="language-go"><span class="nx">hash</span><span class="p">(</span><span class="nx">hash</span><span class="p">(</span><span class="nx">Bprev</span><span class="p">),</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="err">⩽</span> <span class="nx">balance</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span> <span class="o">*</span> <span class="nx">M</span><span class="o">/</span><span class="nx">D</span> <span class="err">其中</span> <span class="nx">hash</span> <span class="p">=</span> <span class="nx">sha256</span>

<span class="c1">// M/D 和 PoW 的公式里面的 M/D 是同一个意思</span>
<span class="c1">// Bpre 指的是上一块的 hash 值</span>
<span class="c1">// 注意: 右边变量乘上了用户的余额，意味着在 M/D 一样的情况下，那么余额越大算出的概率就会越大</span>
</code></pre>
    </div>
    <p>上面公式中唯一的变量只有左边的 t，同时变化范围在固定空间内(比如不超过 1h，那么 t 的取值区间只有 7200 个，找不到就退出)，这样就不再需要像 PoW 一样用穷举的方式来找随机数，也就不会存在消耗大量算力的问题。另外， 我们可以看到计算阈值时加上了用户余额，意味着如果用户拥有的资产越多，那么就找到正确随机数的概率也会越大。</p>
    <p>PoS 在解决算力的同时也引入了潜在的攻击问题：</p>
    <ul>
     <li>Nothing at stake， 由于 PoS 不需要消耗太多算力，所以当出现分叉时，矿工为了利益最大化会选择同时在两个分叉进行挖矿，从而导致更多的分叉。而 PoW 是算力敏感的，矿工只能选择押注其中一条路径。</li>
     <li>长距离攻击，在 PoW 中恶意节点即使拥有 51% 以上的算力，如果想篡改账本也是需要花费大量的成本。而 PoS 对于算力的要求很低，那么就存在被篡改的风险</li>
     <li>币龄累积攻击，有些算法实现中除了考虑拥有的资产之外还加上了币龄，那么就有可能导致部分节点不需要持有 51% 的资产就可以产生攻击</li>
    </ul>
    <p><br></p>
    <p><strong>3.DPoS(Delegated Proof of Stake)</strong></p>
    <ul>
     <li>2014 年 4 月Bitshares 的首席开发者 Dan Larimer 提出 DPoS 算法并应用到 Bitshares， 截止到当前(2018年 5 月) 已经运行了 4 年左右</li>
     <li>2016 年7 月 Steemit 公司发布 Steemit 项目以及今年的 EOS 测试网络也都是使用 DPoS 作为共识算法</li>
    </ul>
    <p>DPoS 被认为是 PoS 的改进版本，DPoS 通过每隔一段时间进行一次选举，然后由这些选举出来的节点来负责出块和互相监督验证，这样就可以大大降低出块以及块确认的时间。这样的选举方式带来的问题是出块节点会比 PoW 以及 PoS 更加中心化。</p>
    <h2><strong>DPoS 算法概要</strong></h2>
    <p>当前以太坊的共识算法是 PoW，后续会逐渐过渡为 PoW + PoS。目前为了解决算力消耗过大和性能问题，我们做的一个尝试是将共识算法从 PoW 修改为 DPoS。 </p>
    <p>DPoS 共识算法最大的特点是出块人是由选举产生而不是通过算随机数。算法设计上和中心化的投票选举机制和 Bitshares 提出的 DPoS 算法 没有太本质的区别，唯一的区别就是把投票的过程变成一笔交易。在下文中我将为大家详解的介绍我们整体的流程以及具体的实现。</p>
    <p>整体流程如下:</p>
    <img src="https://pic4.zhimg.com/v2-257d9bc68c9919c7168cdf0ef48bef6d_b.jpg" class="content_image" alt="">
    <p>算法实现主要包含两个核心部分:</p>
    <ol>
     <li>块验证人选举</li>
     <li>块验证人调度</li>
    </ol>
    <p>第一批块验证人由创世块指定，后续每个周期(周期由具体实现定义)都会在周期开始的第一个块重新选举。验证人选举过程如下:</p>
    <ol>
     <li>踢掉上个周期出块不足的验证人</li>
     <li>统计截止选举块(每个周期的第一块)产生时候选人的票数，选出票数最高的前 N 个作为验证人</li>
     <li>随机打乱验证人出块顺序，验证人根据随机后的结果顺序出块</li>
    </ol>
    <p>验证人调度根据选举结果进行出块，其他节点根据选举结果验证出块顺序和选举结果是否一致，如果不一致则认为此块不合法，直接丢弃。</p>
    <h2><strong>DPoS 实现</strong></h2>
    <p>以太坊当前代码里面已经包含了几种共识算法的实现:</p>
    <ul>
     <li><code>PoW</code> 在主网使用</li>
     <li><code>FakePow</code> 在单元测试使用</li>
     <li><code>PoA(Proof of Authority)</code> 在测试网络中使用</li>
    </ul>
    <p>为了在代码中实现多种共识算法，以太坊抽象了一套共识算法接口，实现不同的共识算法只要实现几个接口即可。另外由于 DPoS 为了避免每次选举都从创世块开始回放历史数据，增加了几个全局状态树用来记录选举和投票的状态， 并把树对应的 root 存储到块头，其中包括：</p>
    <ul>
     <li>EpochTrie 记录每个周期的验证人列表</li>
     <li>VoteTrie 记录投票人对应验证人</li>
     <li>CandidateTrie 记录候选人列表</li>
     <li>DelegateTrie 记录验证人以及对应投票人的列表</li>
     <li>MintCntTrie 记录验证人在周期内的出块数目</li>
    </ul>
    <p><br></p>
    <p><strong>1.接口</strong></p>
    <div class="highlight">
     <pre><code class="language-go"><span class="kd">type</span> <span class="nx">Engine</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Author</span><span class="p">(</span><span class="nx">header</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span> <span class="p">(</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  	<span class="c1">// 验证块头是否符合共识算法规则</span>
    <span class="nx">VerifyHeader</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">header</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="nx">seal</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 批量验证块头是否符合共识算法规则</span>
    <span class="nx">VerifyHeaders</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">headers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="nx">seals</span> <span class="p">[]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{},</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>
    <span class="c1">// 验证叔块是否符合共识算法规则, DPoS 没有叔块</span>
    <span class="nx">VerifyUncles</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">block</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// 验证块内容是否符合共识算法规则</span>
    <span class="nx">VerifySeal</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">header</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// 根据共识算法规则初始化块头信息</span>
    <span class="nx">Prepare</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">header</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 块内交易执行完成之后进行的相关更新操作(比如挖块激励等等)</span>
    <span class="nx">Finalize</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">header</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="nx">state</span> <span class="o">*</span><span class="nx">state</span><span class="p">.</span><span class="nx">StateDB</span><span class="p">,</span> <span class="nx">txs</span> <span class="p">[]</span><span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Transaction</span><span class="p">,</span> <span class="nx">uncles</span> <span class="p">[]</span><span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="nx">receipts</span> <span class="p">[]</span><span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Receipt</span><span class="p">,</span> <span class="nx">dposContext</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">DposContext</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Block</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// 根据 Prepare 和 Finalize 生成的块内容以及共识算法产生一个新块</span>
    <span class="nx">Seal</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">,</span> <span class="nx">block</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Block</span><span class="p">,</span> <span class="nx">stop</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">(</span><span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Block</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// 该共识算法对外提供的 API 接口</span>
    <span class="nx">APIs</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">ChainReader</span><span class="p">)</span> <span class="p">[]</span><span class="nx">rpc</span><span class="p">.</span><span class="nx">API</span>
<span class="p">}</span>
</code></pre>
    </div>
    <p><br></p>
    <p><strong>2.核心实现</strong></p>
    <p>我们先看看打包块的流程:</p>
    <img src="https://pic4.zhimg.com/v2-93efe9c1375bdaa75ed2c6bf150eede5_b.jpg" class="content_image" alt="">
    <p>矿工会定时通过 <code>CheckValidator</code> 去检查当前的 validator 是否为当前节点，如果是的话则通过 <code>CreateNewWork</code> 来创建一个新的打块任务，<code>CreateNewWork</code> 主要包含三部分的内容：</p>
    <ul>
     <li><code>Prepare()</code>，上面看到的共识算法需要实现的接口，主要是初始化块头基础信息</li>
     <li><code>CommitTransactions()</code>， 主要是从 transaction pool 按照 gas price 将交易打包到块中</li>
     <li><code>Finalize()</code>，将 prepare 和 CommitNewWork 内容打包成新块，同时里面还有包含出块奖励、选举、更新打块计数等功能 </li>
    </ul>
    <p>最后 Seal 会对新块进行签名，之后再将新块广播到邻近的节点，其他节点接收到新块会根据块的签名以及选举结果来看新块是否应该由该验证人来出块。相对其他的共识算法来说，DPoS 的共识算法主要区别在于选举，所以可以重点来看这块实现:</p>
    <div class="highlight">
     <pre><code class="language-go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ec</span> <span class="o">*</span><span class="nx">EpochContext</span><span class="p">)</span> <span class="nx">tryElect</span><span class="p">(</span><span class="nx">genesis</span><span class="p">,</span> <span class="nx">parent</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">genesisEpoch</span> <span class="o">:=</span> <span class="nx">genesis</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nx">Int64</span><span class="p">()</span> <span class="o">/</span> <span class="nx">epochInterval</span>
    <span class="nx">prevEpoch</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">Time</span><span class="p">.</span><span class="nx">Int64</span><span class="p">()</span> <span class="o">/</span> <span class="nx">epochInterval</span>
    <span class="nx">currentEpoch</span> <span class="o">:=</span> <span class="nx">ec</span><span class="p">.</span><span class="nx">TimeStamp</span> <span class="o">/</span> <span class="nx">epochInterval</span> 
    <span class="o">...</span><span class="p">.</span>
    <span class="c1">// 根据当前块和上一块的时间计算当前块和上一块是否属于同一个周期，</span>
    <span class="c1">// 如果是同一个周期，意味着当前块不是周期的第一块，不需要触发选举</span>
    <span class="c1">// 如果不是同一周期，说明当前块是该周期的第一块，则触发选举</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">prevEpoch</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">currentEpoch</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 如果前一个周期不是创世周期，触发踢出候选人规则</span>
        <span class="c1">// 踢出规则主要是看上一周期是否存在候选人出块少于特定阈值(50%), 如果存在则踢出</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">prevEpochIsGenesis</span> <span class="o">&amp;&amp;</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ec</span><span class="p">.</span><span class="nx">kickoutCandidate</span><span class="p">(</span><span class="nx">prevEpoch</span><span class="p">,</span> <span class="nx">prevEpochIsGenesis</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">err</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 对候选人进行计票后按照票数由高到低来排序, 选出前 N 个</span>
        <span class="c1">// 这里需要注意的是当前对于成为候选人没有门槛限制很容易被恶意攻击</span>
        <span class="nx">votes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ec</span><span class="p">.</span><span class="nx">countVotes</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">epochSize</span> <span class="p">{</span>
            <span class="nx">candidates</span> <span class="p">=</span> <span class="nx">candidates</span><span class="p">[:</span><span class="nx">epochSize</span><span class="p">]</span>
        <span class="p">}</span>
        
        <span class="c1">// 打乱验证人列表，由于使用 seed 是由父块的 hash 以及当前周期编号组成，</span>
        <span class="c1">// 所以每个节点计算出来的验证人列表也会一致</span>
        <span class="nx">seed</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">(</span><span class="nx">crypto</span><span class="p">.</span><span class="nx">Keccak512</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">Hash</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">())))</span> <span class="o">+</span> <span class="nx">i</span>
        <span class="nx">r</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">NewSource</span><span class="p">(</span><span class="nx">seed</span><span class="p">))</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
            <span class="nx">j</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Int31n</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="nx">sortedValidators</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">candidates</span> <span class="p">{</span>
            <span class="nx">sortedValidators</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sortedValidators</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">.</span><span class="nx">address</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>   
</code></pre>
    </div>
    <p>我们在打包每个块之前都会调用 <code>tryElect</code> 来看看当前块是否是新周期的第一块，如果是第一块则需要触发选举。 整体的选举的实现比较简单，主要是做了三个事情:</p>
    <ol>
     <li>根据上个周期出块的情况把一些被选上但出块数达不到要求的候选人踢掉</li>
     <li>截止到上一块为止，选出票数最高的前 N 个候选人作为验证人</li>
     <li>打乱验证人顺序</li>
    </ol>
    <p>接下来看看计票实现(忽略一些不重要的代码):</p>
    <div class="highlight">
     <pre><code class="language-go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ec</span> <span class="o">*</span><span class="nx">EpochContext</span><span class="p">)</span> <span class="nx">countVotes</span><span class="p">()</span> <span class="p">(</span><span class="nx">votes</span> <span class="kd">map</span><span class="p">[</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 遍历候选人列表</span>
    <span class="k">for</span> <span class="nx">existCandidate</span> <span class="p">{</span>
        <span class="nx">candidate</span> <span class="o">:=</span> <span class="nx">iterCandidate</span><span class="p">.</span><span class="nx">Value</span>
        <span class="nx">candidateAddr</span> <span class="o">:=</span> <span class="nx">common</span><span class="p">.</span><span class="nx">BytesToAddress</span><span class="p">(</span><span class="nx">candidate</span><span class="p">)</span>
        <span class="nx">delegateIterator</span> <span class="o">:=</span> <span class="nx">trie</span><span class="p">.</span><span class="nx">NewIterator</span><span class="p">(</span><span class="nx">delegateTrie</span><span class="p">.</span><span class="nx">PrefixIterator</span><span class="p">(</span><span class="nx">candidate</span><span class="p">))</span>
        <span class="nx">existDelegator</span> <span class="o">:=</span> <span class="nx">delegateIterator</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span>
		<span class="o">...</span>
        <span class="c1">// 遍历候选人对应的投票人列表</span>
        <span class="k">for</span> <span class="nx">existDelegator</span> <span class="p">{</span>
            <span class="nx">delegator</span> <span class="o">:=</span> <span class="nx">delegateIterator</span><span class="p">.</span><span class="nx">Value</span>
            <span class="nx">score</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">votes</span><span class="p">[</span><span class="nx">candidateAddr</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
                <span class="nx">score</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">delegatorAddr</span> <span class="o">:=</span> <span class="nx">common</span><span class="p">.</span><span class="nx">BytesToAddress</span><span class="p">(</span><span class="nx">delegator</span><span class="p">)</span>
            <span class="c1">// 获取投票人的余额作为票数累积到候选人的票数中</span>
            <span class="nx">weight</span> <span class="o">:=</span> <span class="nx">statedb</span><span class="p">.</span><span class="nx">GetBalance</span><span class="p">(</span><span class="nx">delegatorAddr</span><span class="p">)</span>
            <span class="nx">score</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">score</span><span class="p">,</span> <span class="nx">weight</span><span class="p">)</span>
            <span class="nx">votes</span><span class="p">[</span><span class="nx">candidateAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">score</span>
            <span class="nx">existDelegator</span> <span class="p">=</span> <span class="nx">delegateIterator</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nx">existCandidate</span> <span class="p">=</span> <span class="nx">iterCandidate</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">votes</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
    </div>
    <p>计票的逻辑也很简单:</p>
    <ol>
     <li>先找出候选人对应投票人的列表</li>
     <li>所有投票人的余额作为票数累积到候选人的总票数中</li>
    </ol>
    <p>之前我们看到除了上面看到几个接口之外，共识算法接口还要求实现比如像 <code>VerifyHeader()</code>，<code>VerifySeal()</code>，<code>VerifyUncles()</code> 等几个验证接口，主要是当其他人接收到新块时会使用这几个方法分别来验证块头，内容以及叔块的信息是否符合验证规则。由于篇幅的关系这里不进行详细介绍。</p>
    <p><br></p>
    <p><strong>3.成为候选人/投票</strong></p>
    <p>某个节点想要成为验证人，首先要成为候选人，接着其他人才能对这个候选人进行投票。不管是投票还是成为候选人，对于节点来说其实都是一笔交易，之前的交易主要是转账或者合约调用，因此现在多增加几种交易类型。</p>
    <div class="highlight">
     <pre><code class="language-go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Binary</span> <span class="nx">TxType</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// 之前的转账或者合约调用交易</span>
    <span class="nx">LoginCandidate</span>       <span class="c1">// 成为候选人</span>
    <span class="nx">LogoutCandidate</span>		 <span class="c1">// 退出候选人</span>
    <span class="nx">Delegate</span>			 <span class="c1">// 投票(授权)</span>
    <span class="nx">UnDelegate</span>			  <span class="c1">// 取消投票(授权)</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">txdata</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>         <span class="nx">TxType</span>          <span class="s">`json:"type" gencodec:"required"`</span> 
    <span class="nx">AccountNonce</span> <span class="kt">uint64</span>          <span class="s">`json:"nonce" gencodec:"required"`</span>
    <span class="nx">Price</span>        <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>        <span class="s">`json:"gasPrice" gencodec:"required"`</span>
    <span class="nx">GasLimit</span>     <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>        <span class="s">`json:"gas" gencodec:"required"`</span>
    <span class="nx">Recipient</span>    <span class="o">*</span><span class="nx">common</span><span class="p">.</span><span class="nx">Address</span> <span class="s">`json:"to" rlp:"nil"`</span> <span class="c1">// nil means contract creation</span>
    <span class="nx">Amount</span>       <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>        <span class="s">`json:"value" gencodec:"required"`</span>
    <span class="nx">Payload</span>      <span class="p">[]</span><span class="kt">byte</span>          <span class="s">`json:"input" gencodec:"required"`</span>

    <span class="c1">// Signature values</span>
    <span class="nx">V</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="s">`json:"v" gencodec:"required"`</span>
    <span class="nx">R</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="s">`json:"r" gencodec:"required"`</span>
    <span class="nx">S</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="s">`json:"s" gencodec:"required"`</span>

    <span class="c1">// This is only used when marshaling to JSON.</span>
    <span class="nx">Hash</span> <span class="o">*</span><span class="nx">common</span><span class="p">.</span><span class="nx">Hash</span> <span class="s">`json:"hash" rlp:"-"`</span>
<span class="p">}</span>
</code></pre>
    </div>
    <p>在一个新块打包时会执行所有块内的交易，如果发现交易类型不是之前的转账或者合约调用类型，那么会调用 `applyDposMessage` 进行处理。</p>
    <div class="highlight">
     <pre><code class="language-go"><span class="kd">func</span> <span class="nx">applyDposMessage</span><span class="p">(</span><span class="nx">dposContext</span> <span class="o">*</span><span class="nx">types</span><span class="p">.</span><span class="nx">DposContext</span><span class="p">,</span> <span class="nx">msg</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">types</span><span class="p">.</span><span class="nx">LoginCandidate</span><span class="p">:</span>
        <span class="nx">dposContext</span><span class="p">.</span><span class="nx">BecomeCandidate</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">())</span>
    <span class="k">case</span> <span class="nx">types</span><span class="p">.</span><span class="nx">LogoutCandidate</span><span class="p">:</span>
        <span class="nx">dposContext</span><span class="p">.</span><span class="nx">KickoutCandidate</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">())</span>
    <span class="k">case</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Delegate</span><span class="p">:</span>
        <span class="nx">dposContext</span><span class="p">.</span><span class="nx">Delegate</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">(),</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">())</span>
    <span class="k">case</span> <span class="nx">types</span><span class="p">.</span><span class="nx">UnDelegate</span><span class="p">:</span>
        <span class="nx">dposContext</span><span class="p">.</span><span class="nx">UnDelegate</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">(),</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">().</span><span class="nx">Bytes</span><span class="p">())</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">types</span><span class="p">.</span><span class="nx">ErrInvalidType</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">DposContext</span><span class="p">)</span> <span class="nx">BecomeCandidate</span><span class="p">(</span><span class="nx">candidate</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 更新候选人树即可</span>
    <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">candidateTrie</span><span class="p">.</span><span class="nx">TryUpdate</span><span class="p">(</span><span class="nx">candidate</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">DposContext</span><span class="p">)</span> <span class="nx">Delegate</span><span class="p">(</span><span class="nx">delegator</span><span class="p">,</span> <span class="nx">candidate</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">common</span><span class="p">.</span><span class="nx">IsHexAddress</span><span class="p">(</span><span class="nx">common</span><span class="p">.</span><span class="nx">BytesToAddress</span><span class="p">(</span><span class="nx">candidate</span><span class="p">).</span><span class="nx">String</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">ErrInvalidAddress</span>
    <span class="p">}</span>
    <span class="c1">// 投票(授权)之前需要先检查该账号是否候选人</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">candidateTrie</span><span class="p">.</span><span class="nx">TryGet</span><span class="p">(</span><span class="nx">candidate</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// 如果投票人之前已经给其他人投过票则先取消之前的投票</span>
    <span class="nx">oldCandidate</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">voteTrie</span><span class="p">.</span><span class="nx">TryGet</span><span class="p">(</span><span class="nx">delegator</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MissingNodeError</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">oldCandidate</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">d</span><span class="p">.</span><span class="nx">delegateTrie</span><span class="p">.</span><span class="nx">Delete</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">oldCandidate</span><span class="p">,</span> <span class="nx">delegator</span><span class="o">...</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// 更新候选人对应的授权列表</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">delegateTrie</span><span class="p">.</span><span class="nx">TryUpdate</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">candidate</span><span class="p">,</span> <span class="nx">delegator</span><span class="o">...</span><span class="p">),</span> <span class="nx">delegator</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">voteTrie</span><span class="p">.</span><span class="nx">TryUpdate</span><span class="p">(</span><span class="nx">delegator</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
    </div>
    <p>可以看到投票/成为候选人跟我们传统的实现差别不大，本质还是对于数据的增删查改，只是在数据的更新上区块链会比普通的 KV 更加复杂和特殊一些。</p>
    <h2><strong>测试</strong></h2>
    <div class="highlight">
     <pre><code class="language-console"><span class="gp">$</span> <span class="nb">cd </span>go-ethereum <span class="o">&amp;&amp;</span> make geth
<span class="gp">$</span> ./build/bin/geth init --datadir /path/to/datadir dpos_test_genesis.json
<span class="gp">$</span> ./build/bin/geth --datadir /path/to/datadir --keystore /path/to/keystore console
<span class="gp">$</span> personal.unlock<span class="o">(</span><span class="nv">$validator</span>, <span class="nv">$passwd</span>, 0<span class="o">)</span>
<span class="gp">$</span> miner.setValidator<span class="o">(</span><span class="nv">$validator</span><span class="o">)</span>
<span class="gp">$</span> miner.start<span class="o">()</span>
</code></pre>
    </div>
    <blockquote>
     第一批创世验证人在 dpos_test_genesis.json 修改，为了方便测试可以将验证人数目(maxValidatorSize)调小
    </blockquote>
    <h2>开发遇到的问题</h2>
    <ul>
     <li>fast sync 模式下不接收广播的块导致节点之间一直无法互相同步新块</li>
    </ul>
    <p>以太坊同步有三种同步机制：</p>
    <ol>
     <li><code>full sync</code> 同步全量区块并回放所有交易数据来构造全局状态树</li>
     <li><code>fast sync</code>（默认） 同步全量区块数据以及第 N 块的全局状态树，同时只回放从第 N 块之后的交易数据。这个机制很像 Redis 的 RDB + AOF 机制，这种方式避免回放所带来的性能问题(回放交易主要的性能瓶颈是在于随机 IO 读写)。</li>
     <li><code>light sync</code>只同步区块头部信息不同步具体交易内容，主要是用于钱包实现 SPV 功能</li>
    </ol>
    <p>fast sync 模式下会直接丢弃广播的块，只有在进入 full sync 之后才会接收。如果我们同时以默认同步方式(fast sync)启动多个节点，由于节点之间出块的频率一样导致所有节点都无法进入 full sync 模式，节点之间同步的块都会被丢弃。解决方案是创始节点以 full sync 方式启动，我们开源的代码为了方便测试，默认也会使用 full sync。</p>
    <ul>
     <li>加入 DPoS 之后，区块的存储结构发生一些变化，之前一些验证流程逻辑需要调整。比如验证人是否合法理论上需要在 <code>VerifyHeader</code> 来做校验 ，因为块头只是存储需要对应树的 root, 而没有具体的内容，需要等到新块写入 DB 之后再来校验(注意这里的写入本地指的是块数据写入 KV，而块本身并未插入链)。</li>
     <li>由于以太坊一些实现机制上也相对复杂一些，开始对于设计细节了解不是特别深入，在调试过程中也会花费比较多的时间。另外就是单元测试庞大，在对代码修改过程中需要不断地理解和修正单元测试。</li>
    </ul>
    <p><br></p>
    <p><strong>参考：</strong></p>
    <p><a href="http://link.zhihu.com/?target=https%3A//steemit.com/dpos/%40dantheman/dpos-consensus-algorithm-this-missing-white-paper" rel="nofollow" class="wrap external">DPOS Consensus Algorithm - The Missing White Paper</a></p>
    <p><a href="http://link.zhihu.com/?target=https%3A//github.com/ethereum/go-ethereum/pull/1889" rel="nofollow" class="wrap external">eth/63 fast synchronization algorithm</a></p>
    <p><a href="http://link.zhihu.com/?target=https%3A//bitfury.com/content/downloads/pos-vs-pow-1.0.2.pdf" rel="nofollow" class="wrap external">pos vs pow</a></p>
    <p><a href="http://link.zhihu.com/?target=https%3A//bitshares.org/technology/delegated-proof-of-stake-consensus/" rel="nofollow" class="wrap external">delegated proof of stake consensus</a></p>
    <p><a href="http://link.zhihu.com/?target=https%3A//github.com/ethereum/go-ethereum" rel="nofollow" class="external"><span class="invisible">https://</span><span class="visible">github.com/ethereum/go-</span><span class="invisible">ethereum</span><span class="ellipsis"></span></a></p>
    <p><a href="http://link.zhihu.com/?target=https%3A//github.com/meitu/go-ethereum" rel="nofollow" class="external"><span class="invisible">https://</span><span class="visible">github.com/meitu/go-eth</span><span class="invisible">ereum</span><span class="ellipsis"></span></a></p>
    <p><br></p>
   </div>
  </div>
  <p><br></p>
  <p>https://zhuanlan.zhihu.com/p/38013479<br></p>
  <div></div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/omnispace/article/details/80728089,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/omnispace/article/details/80728089,&quot;}">阅读更多</a> 
</div>
      <br />
        <a href="https://blog.uzzz.org/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://blog.uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://blog.uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>

  </body>
</html>
