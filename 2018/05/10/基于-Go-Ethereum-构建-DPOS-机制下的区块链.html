<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基于 Go-Ethereum 构建 DPOS 机制下的区块链 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基于 Go-Ethereum 构建 DPOS 机制下的区块链" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者简介 朱 崇 文 恺英网络区块链组技术经理 目 录 Go 版本以太坊 为何选择DPOS机制&nbsp;&nbsp; 拓展共识改造实践&nbsp;&nbsp; 智能合约的实践 压力测试下暴露的问题&nbsp;&nbsp; &nbsp; &nbsp;1. &nbsp;Go 版本以太坊 1.1 &nbsp;以太坊的客户端 ﻿﻿&nbsp; &nbsp;首先是以太坊技术社区的一些客户端的实现。以太坊技术协议本身是协议，它包含了一些接口协议，规范或参数定义和内部具体的实现逻辑和流程等。基于这个技术协议，可以用各自语言实现一个以太坊节点。以太坊的官方团队使用Go 语言实现了官方版本。partiy 的实现是第二大的客户端。 1.2 &nbsp;以太坊的工具组 ﻿核心组件包括 Solidity，Web3.js。对于大多数的开发者来说，最关心的是这两个组件。Swarm 一种外部存储的实现，希望拓展以太坊本身对于较大数据存放的问题，另外 IPFS 也是类似的功能实现。 1.3 以太坊公联网络拓扑 ﻿ &nbsp;图3 &nbsp;&nbsp;图3 是以太坊网络的拓扑图。包含了各种不同的客户端，他们之间相互组成了图中的网络。通过图3 就可以看到整个以太坊的公有链是非常开放的。 2. 为何选择DPOS机制 2.1 共识机制对比 &nbsp; &nbsp;&nbsp;&nbsp;DPOS 是一种共识机制，源自于石墨烯技术。简单对比一下以太坊的官方社区提供的 POW 机制。POW 是消耗你的计算力来产块，它出块速度慢，确认慢。而 DPOS 是代理人的模式。现阶段实现的 DPOS 的机制 TPS 可达 1000，平均确认的时间在 1~3 秒钟。 2.2 DPOS机制的优势 &nbsp; &nbsp; 我们实现了的 DPOS 机制的优势主要在于两个方面。第一是系统可靠性。在商业场景下，网络性能可控，在异常情况下能快速处理并恢复，同时对TPS/QPS，以及确认时间有一定的要求。第二，共识机制是一种思想，以公有链为基础，可对外开放，任何人都可以参与，设立理事会和见证人角色，理事会管理区块链网络，见证人生产并验证区块，构成了一个良性的生态圈。 2.3 &nbsp;DPOS机制的理念 图4 &nbsp;&nbsp;&nbsp;图4表示，我们把一个公司和社区定义为三种角色，普通社区成员会通过自己手上的投票权选举理事会。理事会通过自己的判断或认知来委任见证人。见证人根据自己实际情况维持整个链的运作，这是 DPOS&nbsp;机制的理念。 3. 拓展共识改造实践 3.1 &nbsp;共识框架引擎 3.1.1 &nbsp;改造共识层逻辑 &nbsp;图5 &nbsp;&nbsp;图5显示，如何实现 DPOS 的机制。以太坊的接口服务是提供客户端调用，网络通讯是为 p2p 提供服务。 中间是一个共识层，是去做挖矿还是去做 DPOS 等其他共识，在这个上面都可以做一个扩展。最下面就是存储，区块的存储和状态都是通过这层做的。 3.1.2 &nbsp;官方实现引擎 ：Ethash/Clique ﻿图6 &nbsp;&nbsp;图6 显示&nbsp;，我们通过共识层来达到DPOS目的 。图上代码直接截取了以太坊的代码，这是一个接口引擎，提供了一些方法，看到这些方法名字，很多都是在 Verify。Verify 对整个以太坊非常重要，区块链是不可篡改的，它需要对各种各样的异常情况做验证。&nbsp;最上面的文字写到官方上有两个引擎，第一个是在公有链上所使用的引擎，是 POW 机制的实现。第二个是 Clique，修改为 Dpos 很大的灵感来自于 Clique 引擎。 3.1.3 &nbsp;Seal 核心方法调用 ﻿ 图7 &nbsp;&nbsp;&nbsp;图7有点复杂，它能帮助我们了解以太坊内部的逻辑，首先通过 agent 和 worker 两个方法，去监听他们自己的对象，这两个 channel 一旦有数据会触发下面的事情。我们先看 worker channel，这个 channel 里面有新的 work出来会发生不同的事情。worker 是有工作的命令，一旦收到这个 worker 的 channel，就要判断自己有没有能力挖矿，是否要做打包工作，触发这个 channel 之后，就调用引擎里面的方法，然后 seal 就去解决问题。最终的题目是谁解出来，谁就有权利或者资格去挖这个区块，这个 seal 方法就成功了，接着会产生一个Result 的对象，会触发下面的工作，一旦产生出块之后就会有新的 worker 放在新的 channel 上去，如果我一直可以产块，就可以不断地做这个流程，这样就构成了以太坊矿工节点里面核心挖矿的流程。此外 work channel 也有一个自己的触发机制。这个时候就需要依赖外部的节点了，当其他节点产生区块的时候，会向我们这个节点广播，我就会同步出块，通知这个 channel 有新的工作区去做。刚刚讲的是接口引擎里面最重要的 Seal 方法，我们可以通过修改这个方法，把原来需要解决题目的挖矿改成不解决题目。 3.2 借鉴 Clique （POA) 的实现 ﻿ 图8 &nbsp;&nbsp;&nbsp;另一种共识机制是 Clique。以太坊公链使用 POW 机制，通过节点数量来防止别人恶意攻击。同时，以太坊提供一些测试链。但测试链用 POW 发布之后有一个问题，测试链没有很多人同时参与维护，如果有人恶意搞它就非常简单，通过一些机器和算力很容易把它搞瘫痪掉。为了能够让测试链比较稳定的运行，开发了另外一种共识机制取代了 POW，只有授权的机器才可以生产区块，这样维护成本非常低，找一些机器授权给他就能够去维持这个网络。整个网络通过授权过的人去出块，节点之间通过投票的方式来授权或者剔除授权，这些额外的投票机制记录在区块头的 extra data 字段里面。 &nbsp;&nbsp;&nbsp;图8右边的图是测试链的产块逻辑。假定有 A、B、C 三个节点的话，正常逻辑 A&nbsp;完成之后到&nbsp;B，B&nbsp;完成之后到&nbsp;C。图中有一个竞争出块的概念，出 C 的时候不仅仅是 C 产块，A 也可以产块，为什么呢？ 因为避免 C&nbsp;节点有问题的时候，不能产块，A 节点的块也能提供出来加入到链里面。同时，如果 C 在当前轮次里面，字段有一个 difficult 字段值就是 2，而这个 A 虽然可以产块，但不在这个轮次里面，所以 difficult 就是 1，尽可能保证 C 这个节点产生的块被大多数的节点所接受，这是以太坊最常见的概念。 图9 &nbsp;&nbsp;&nbsp;图9&nbsp;是轮次问题，也做了小的改动，这两个节点可以竞争出块，对于它，我们希望 C 节点的块尽量被接受，所以对 A 节点来说，如果不是这个轮次里面的话，可以让A节点出块的时间变得稍微延后一些。比如在现在这个时间点应该可以出块的，但我要控制让它晚一些时候出块，这样就避免会产生过多的分叉，虽然可以通过 difficult 值来决定谁是最长链，但过多的分叉会导致链的状态越不稳定。 3.3 扩展区块头结构 3.3.1 &nbsp;增加见证人列表 ﻿图10 &nbsp;&nbsp;&nbsp;我们借鉴 Clique 的想法之后，会想怎么扩展我们的 DPOS 机制。首先我们会先修改数据结构，对区块的 Header 的结构，定义新的字段，下面的&nbsp;WitnessVotes 是我们自己定义的字段，我们希望通过这个字段来为 DPOS 机制提供节点授权，我们扩展这个字段，把见证人的地址列出，按照字典做排序，这样能避免出块轮次发生变化的问题。以太坊对于字段扩展是非常容易做的，在代码的框架里体统了框架的主体架构，我们只需要增加一些代码，就可以很容易扩容它的 Header 了。 3.3.2 &nbsp;见证人列表生成规则﻿﻿&nbsp;图11 &nbsp;图11是 witness 的列表。对以太坊来的验证机制而言，两个区块，即便区块数据一样，但是区块的成产者不一样，也是不被接受的。为了达到这个目的，我们就需要约定好方案，对于见证人的列表来说，必须依托于父节点。如果现在区块链上被确认的区块高度是 Block N，现在要产生 Block N+1 的区块，我们如何填充区块的见证人列表? 我们必须通过 Block N 的区块达成共识，当前的 Block N 上面的见证人列表是谁，就填到下一个见证人列表当中去。对创始块来说，我们通过创世配置文件，把见证人列表直接写在创世块中。 3.4 &nbsp;轮流生产者的实现 3.4.1判断当前轮次是否需要产块 &nbsp;&nbsp;&nbsp;当每个节点收到一些条件之后，如何判断自己可以出块？普通的是通过计算题目，现在是通过一些条件判断，我们根据以下几个条件值: 当前的时间戳、当前区块的产块人，Parent 区块的见证人列表，Parent 区块的产块人，Parent 区块的时间戳，产块周期来共同计算出来当前矿工到底有没有资格出块。如果现在没有资格，那不应该出块。 3.4.2 &nbsp;轮流生产者的实现—分析 场景分析 &nbsp;&nbsp;&nbsp;图中，如果我们有 A、B、C 三个节点，这是他们的 parent 节点的数据结构，parent 见证人的列表是 ABC，时间戳是 T，产块周期是 3 秒钟，当前的时间点是&nbsp;T+3，这三个节点点各自判断有没有资格出块。根据图，我们发现见证人列表永远都是 ABC，父节点产块人是&nbsp;A，下一个要 B 产块，B&nbsp;在&nbsp;T+3&nbsp;时间可以产块，A 和 C 在 T+3 的时间节点是不能产块的。A 可能要等到 T+9 的时间点产块，C 是 T+6&nbsp;的时间点可以产块。这样才能保证整个网络持续的往下运行。 判断当前轮次—代码实现 ﻿ &nbsp;&nbsp;&nbsp;逻辑通过代码实现，我们根据条件来计算一个值，计算出轮次查， 我们可以根据时间戳和产块节点和当地时间戳判断是不是可以出块。 注册下一次调用 原因 ﻿ &nbsp;&nbsp;&nbsp;还有一个问题是产块没到自己的轮次或现在不应该产块，所以不会产生结果对象，也就不会触发提交新的 worker，也没有其他的时间节点触发这个 channel，这个时候我收不到任何消息，什么都不能干，这个是 Clique 测试网络存在的问题。我们不希望这种情况发生，希望网络永远是向前推进，即便是网络出现故障或者异常，只要保证后面的节点 OK 还是可以往前走的。解决这个问题就需要做一些改变，我们把 worker 产生的通知机制去掉。每次产生 seal 的方法不是通过这两个地方通知他，而是通过 Seal 本身判断自己，Seal 判断完之后注册下一个 Seal，这样永远保证它可以判断它自己。 场景分析 ﻿﻿&nbsp;&nbsp;根据上述内容，自己判断自己的话，需要给自己注册一个动作的定时器。还是以刚刚的场景分析，对于 A 节点来说，这个时间节点&nbsp;A&nbsp;不能出块，因为没有符合条件，他给自己定时器是什么时间点呢？一种方案是我在 T+9&nbsp;时去出块，我就等 9 秒钟或 6 秒钟判断我自己是不是有出块的资格。在实际测试中这种方案的效果并不是特别好。有两个原因； &nbsp;第一个是见证人的列表会发生变化，如果这个列表发生变化之后，下一次被唤醒的时候，出块的轮次也发生变化，这个时候就有可能错过了出块的机会，会导致整个网络的产块周期变的更加不稳定。&nbsp;第二，我的迭代时间比较长，降低自己出块的频次，一旦整个网络发生不稳定的情况下，会处于 side fork 的情况。整个网络每个节点都在出块，但是没有被其他的节点接受，我们希望尽可能的在短时间之内同步，也不能过分的小，过分的小会使产块的性能有问题。我们定义两个时段，一个是 3 秒钟，第二是定义一个最小值，其实在出块的时候，在节点出块之前会做打包、验证的工作。我们扣除时间消耗，打包时间过长，最小的值就会有用，可以帮助快速的出块。这种情况下，前面因为某种原因导致你的产块速度慢，或你有可能这个时间点应该出块，但压根没有出块，这个时候就小于 0 了，这个时候马上让他出块。 代码实现 &nbsp;&nbsp;&nbsp;在每个 Seal 方案里面会注册一个方法，使其在下次被调用，这个方法叫registernext 3.4.3 &nbsp; 自定义奖励规则 &nbsp;&nbsp;&nbsp;我们对奖励也做了变化, 对我们应用场景来说会改变奖励的分配规则，使我们适应不同的业务场景。﻿﻿&nbsp; &nbsp;首先在创世块当中确认奖励规则，这是一个 default-reward 的规则，这个规则可以在节点挖矿完之后按照这个规则去发放奖励，具体怎么做呢：就定一个接口，定义一个方法，比如我希望出块人可以获得五个币的奖励，在每次出完块之后，其他节点验证完之后，最后在这个数据结构里面，把账号里面的钱就增加5个币，这是最简单的实践。我们把代码抽出来之后扩展自己奖励分配的规则，根据时间出块，或者不给他奖励，或者通过其他方式奖励，或者把建立放在一个池里面。 4.智能合约的支点实践 4.1 &nbsp;合约语言 Solidity &nbsp;&nbsp;&nbsp;接下来讲一下我们在智能合约里面的实现。我们说的 DPOS 的机制，很大程度上是要跟智能合约所绑定在一起的，我们的投票人如何投票，我们的理事会成员如何选举见证人都是通过 DPOS 去做，这个可以和共识做一个相关联。 4.2 &nbsp;实现投票合约 4.2.1 &nbsp;理事会 ﻿&nbsp; &nbsp;我们对于理事会的投票思路就是普通用户，通过自己持有的投票权，质押投票权可以选举理事会的成员，会通过 Top N 的计算，自动去发生变化，现在一些 DPOS 的机制是有换届的概念，每天换一届，我们这边是自动的，这个时间点你只要票数够高，马上就成为理事会的成员。 4.2.2 &nbsp;见证人 ﻿&nbsp; &nbsp;见证人是通过理事会任命的，一个理事会成员有资格去发起一个提案，这个提案可能包含提名或者是移除一个见证人，他发起提案之后，其他理事会成员可以选择通过还是不通过，这个提案有一定时效期，超过这个时间窗口也是自动作废的，一旦超过半数就通过，如果半数以上否认掉那就是作废了。 4.3 &nbsp;智能合约设计模式 &nbsp; &nbsp;&nbsp;&nbsp;对于智能合约有很多资料，你可以通过业务的智能合约代码和控制器拆开，我们的业务是会变化的。对于智能合约来说，一旦进入到这个区块链是不能改的，这时你必须要写一个新的合约替代它，但是对外暴露的接口只有一个，可以把控制器和业务层分开，你只需要把控制器变更下面业务合约的地址就行。此外还有一种思路，我们可能会在智能合约里面存一些数据比如说存证数据，但是一旦新的业务实现之后，这个数据不通用，这两个智能合约虽然类似，但是数据是不通用的，我们把数据单独的划分出来，数据也是一个合约，不需要设计的过分的复杂，可以同时被上面的业务层所通用。 4.4 &nbsp;智能合约并不智能，反而有太多坑 &nbsp; &nbsp;智能合约本身有很多的限制，对于参数的数量限制，对于返回值的定长设置，包括智能合约的大小都不能定得特别大，所以说智能合约从现在的角度来说，还是需要一段时间优化。 4.5 &nbsp;智能合约设计模式，使用单一合约 &nbsp; 因为它本身也有一些问题在，所以理想的设计模式，有控制器层和数据存储层，我们都不要了，一开始是只有一个合约，或者只有一类合约来做所有的工作。后来发现一旦拆下来这些层之后，很多功能就不能这么做了，我们开发智能合约的思路就是跟我们写代码的思路是一样的，定义返回值，定义变向量，就做不了，最后通过单一合约去做这些事情。 5. 压力测试下暴露的问题 5.1 &nbsp; &nbsp;以太坊公链并不会有压力测试的场景，需要大量的优化和测试 ﻿ 5.2 &nbsp;流量控制 / 重发机制 &nbsp; ﻿﻿&nbsp; &nbsp;最简单的一点是通过一些流量控制和重发机制，我们对外业务调用的时候，不是直接连接到见证节点，而是网关节点，代码都是一样的，在里面会对所有的请求做一个限制。达到一定的程度之后就会拒绝请求。 5.2.1 &nbsp; 对交易请求进行检查，是否到达上限 ﻿﻿ &nbsp;&nbsp;&nbsp;实际的代码实现中，控制一下调用的接口，我们不想对&nbsp;p2p&nbsp;网络造成影响。 5.2.2 &nbsp; &nbsp;重发机制，防止p2p网络交易广播失败 ﻿﻿ &nbsp;&nbsp;&nbsp;这个在节点规模很大的情况下不大容易出现问题，但是在范围较小的情况下就会出现，我们在程序中的&nbsp;pending list&nbsp;里增加了重发的机制。 &nbsp; 2018年的 Gopher Meetup 将在深圳开启巡回第一站，这一次邀请了很多新的讲师给大家一起交流分享Go的使用经验〜 点击阅读原文报名参加 阅读更多" />
<meta property="og:description" content="作者简介 朱 崇 文 恺英网络区块链组技术经理 目 录 Go 版本以太坊 为何选择DPOS机制&nbsp;&nbsp; 拓展共识改造实践&nbsp;&nbsp; 智能合约的实践 压力测试下暴露的问题&nbsp;&nbsp; &nbsp; &nbsp;1. &nbsp;Go 版本以太坊 1.1 &nbsp;以太坊的客户端 ﻿﻿&nbsp; &nbsp;首先是以太坊技术社区的一些客户端的实现。以太坊技术协议本身是协议，它包含了一些接口协议，规范或参数定义和内部具体的实现逻辑和流程等。基于这个技术协议，可以用各自语言实现一个以太坊节点。以太坊的官方团队使用Go 语言实现了官方版本。partiy 的实现是第二大的客户端。 1.2 &nbsp;以太坊的工具组 ﻿核心组件包括 Solidity，Web3.js。对于大多数的开发者来说，最关心的是这两个组件。Swarm 一种外部存储的实现，希望拓展以太坊本身对于较大数据存放的问题，另外 IPFS 也是类似的功能实现。 1.3 以太坊公联网络拓扑 ﻿ &nbsp;图3 &nbsp;&nbsp;图3 是以太坊网络的拓扑图。包含了各种不同的客户端，他们之间相互组成了图中的网络。通过图3 就可以看到整个以太坊的公有链是非常开放的。 2. 为何选择DPOS机制 2.1 共识机制对比 &nbsp; &nbsp;&nbsp;&nbsp;DPOS 是一种共识机制，源自于石墨烯技术。简单对比一下以太坊的官方社区提供的 POW 机制。POW 是消耗你的计算力来产块，它出块速度慢，确认慢。而 DPOS 是代理人的模式。现阶段实现的 DPOS 的机制 TPS 可达 1000，平均确认的时间在 1~3 秒钟。 2.2 DPOS机制的优势 &nbsp; &nbsp; 我们实现了的 DPOS 机制的优势主要在于两个方面。第一是系统可靠性。在商业场景下，网络性能可控，在异常情况下能快速处理并恢复，同时对TPS/QPS，以及确认时间有一定的要求。第二，共识机制是一种思想，以公有链为基础，可对外开放，任何人都可以参与，设立理事会和见证人角色，理事会管理区块链网络，见证人生产并验证区块，构成了一个良性的生态圈。 2.3 &nbsp;DPOS机制的理念 图4 &nbsp;&nbsp;&nbsp;图4表示，我们把一个公司和社区定义为三种角色，普通社区成员会通过自己手上的投票权选举理事会。理事会通过自己的判断或认知来委任见证人。见证人根据自己实际情况维持整个链的运作，这是 DPOS&nbsp;机制的理念。 3. 拓展共识改造实践 3.1 &nbsp;共识框架引擎 3.1.1 &nbsp;改造共识层逻辑 &nbsp;图5 &nbsp;&nbsp;图5显示，如何实现 DPOS 的机制。以太坊的接口服务是提供客户端调用，网络通讯是为 p2p 提供服务。 中间是一个共识层，是去做挖矿还是去做 DPOS 等其他共识，在这个上面都可以做一个扩展。最下面就是存储，区块的存储和状态都是通过这层做的。 3.1.2 &nbsp;官方实现引擎 ：Ethash/Clique ﻿图6 &nbsp;&nbsp;图6 显示&nbsp;，我们通过共识层来达到DPOS目的 。图上代码直接截取了以太坊的代码，这是一个接口引擎，提供了一些方法，看到这些方法名字，很多都是在 Verify。Verify 对整个以太坊非常重要，区块链是不可篡改的，它需要对各种各样的异常情况做验证。&nbsp;最上面的文字写到官方上有两个引擎，第一个是在公有链上所使用的引擎，是 POW 机制的实现。第二个是 Clique，修改为 Dpos 很大的灵感来自于 Clique 引擎。 3.1.3 &nbsp;Seal 核心方法调用 ﻿ 图7 &nbsp;&nbsp;&nbsp;图7有点复杂，它能帮助我们了解以太坊内部的逻辑，首先通过 agent 和 worker 两个方法，去监听他们自己的对象，这两个 channel 一旦有数据会触发下面的事情。我们先看 worker channel，这个 channel 里面有新的 work出来会发生不同的事情。worker 是有工作的命令，一旦收到这个 worker 的 channel，就要判断自己有没有能力挖矿，是否要做打包工作，触发这个 channel 之后，就调用引擎里面的方法，然后 seal 就去解决问题。最终的题目是谁解出来，谁就有权利或者资格去挖这个区块，这个 seal 方法就成功了，接着会产生一个Result 的对象，会触发下面的工作，一旦产生出块之后就会有新的 worker 放在新的 channel 上去，如果我一直可以产块，就可以不断地做这个流程，这样就构成了以太坊矿工节点里面核心挖矿的流程。此外 work channel 也有一个自己的触发机制。这个时候就需要依赖外部的节点了，当其他节点产生区块的时候，会向我们这个节点广播，我就会同步出块，通知这个 channel 有新的工作区去做。刚刚讲的是接口引擎里面最重要的 Seal 方法，我们可以通过修改这个方法，把原来需要解决题目的挖矿改成不解决题目。 3.2 借鉴 Clique （POA) 的实现 ﻿ 图8 &nbsp;&nbsp;&nbsp;另一种共识机制是 Clique。以太坊公链使用 POW 机制，通过节点数量来防止别人恶意攻击。同时，以太坊提供一些测试链。但测试链用 POW 发布之后有一个问题，测试链没有很多人同时参与维护，如果有人恶意搞它就非常简单，通过一些机器和算力很容易把它搞瘫痪掉。为了能够让测试链比较稳定的运行，开发了另外一种共识机制取代了 POW，只有授权的机器才可以生产区块，这样维护成本非常低，找一些机器授权给他就能够去维持这个网络。整个网络通过授权过的人去出块，节点之间通过投票的方式来授权或者剔除授权，这些额外的投票机制记录在区块头的 extra data 字段里面。 &nbsp;&nbsp;&nbsp;图8右边的图是测试链的产块逻辑。假定有 A、B、C 三个节点的话，正常逻辑 A&nbsp;完成之后到&nbsp;B，B&nbsp;完成之后到&nbsp;C。图中有一个竞争出块的概念，出 C 的时候不仅仅是 C 产块，A 也可以产块，为什么呢？ 因为避免 C&nbsp;节点有问题的时候，不能产块，A 节点的块也能提供出来加入到链里面。同时，如果 C 在当前轮次里面，字段有一个 difficult 字段值就是 2，而这个 A 虽然可以产块，但不在这个轮次里面，所以 difficult 就是 1，尽可能保证 C 这个节点产生的块被大多数的节点所接受，这是以太坊最常见的概念。 图9 &nbsp;&nbsp;&nbsp;图9&nbsp;是轮次问题，也做了小的改动，这两个节点可以竞争出块，对于它，我们希望 C 节点的块尽量被接受，所以对 A 节点来说，如果不是这个轮次里面的话，可以让A节点出块的时间变得稍微延后一些。比如在现在这个时间点应该可以出块的，但我要控制让它晚一些时候出块，这样就避免会产生过多的分叉，虽然可以通过 difficult 值来决定谁是最长链，但过多的分叉会导致链的状态越不稳定。 3.3 扩展区块头结构 3.3.1 &nbsp;增加见证人列表 ﻿图10 &nbsp;&nbsp;&nbsp;我们借鉴 Clique 的想法之后，会想怎么扩展我们的 DPOS 机制。首先我们会先修改数据结构，对区块的 Header 的结构，定义新的字段，下面的&nbsp;WitnessVotes 是我们自己定义的字段，我们希望通过这个字段来为 DPOS 机制提供节点授权，我们扩展这个字段，把见证人的地址列出，按照字典做排序，这样能避免出块轮次发生变化的问题。以太坊对于字段扩展是非常容易做的，在代码的框架里体统了框架的主体架构，我们只需要增加一些代码，就可以很容易扩容它的 Header 了。 3.3.2 &nbsp;见证人列表生成规则﻿﻿&nbsp;图11 &nbsp;图11是 witness 的列表。对以太坊来的验证机制而言，两个区块，即便区块数据一样，但是区块的成产者不一样，也是不被接受的。为了达到这个目的，我们就需要约定好方案，对于见证人的列表来说，必须依托于父节点。如果现在区块链上被确认的区块高度是 Block N，现在要产生 Block N+1 的区块，我们如何填充区块的见证人列表? 我们必须通过 Block N 的区块达成共识，当前的 Block N 上面的见证人列表是谁，就填到下一个见证人列表当中去。对创始块来说，我们通过创世配置文件，把见证人列表直接写在创世块中。 3.4 &nbsp;轮流生产者的实现 3.4.1判断当前轮次是否需要产块 &nbsp;&nbsp;&nbsp;当每个节点收到一些条件之后，如何判断自己可以出块？普通的是通过计算题目，现在是通过一些条件判断，我们根据以下几个条件值: 当前的时间戳、当前区块的产块人，Parent 区块的见证人列表，Parent 区块的产块人，Parent 区块的时间戳，产块周期来共同计算出来当前矿工到底有没有资格出块。如果现在没有资格，那不应该出块。 3.4.2 &nbsp;轮流生产者的实现—分析 场景分析 &nbsp;&nbsp;&nbsp;图中，如果我们有 A、B、C 三个节点，这是他们的 parent 节点的数据结构，parent 见证人的列表是 ABC，时间戳是 T，产块周期是 3 秒钟，当前的时间点是&nbsp;T+3，这三个节点点各自判断有没有资格出块。根据图，我们发现见证人列表永远都是 ABC，父节点产块人是&nbsp;A，下一个要 B 产块，B&nbsp;在&nbsp;T+3&nbsp;时间可以产块，A 和 C 在 T+3 的时间节点是不能产块的。A 可能要等到 T+9 的时间点产块，C 是 T+6&nbsp;的时间点可以产块。这样才能保证整个网络持续的往下运行。 判断当前轮次—代码实现 ﻿ &nbsp;&nbsp;&nbsp;逻辑通过代码实现，我们根据条件来计算一个值，计算出轮次查， 我们可以根据时间戳和产块节点和当地时间戳判断是不是可以出块。 注册下一次调用 原因 ﻿ &nbsp;&nbsp;&nbsp;还有一个问题是产块没到自己的轮次或现在不应该产块，所以不会产生结果对象，也就不会触发提交新的 worker，也没有其他的时间节点触发这个 channel，这个时候我收不到任何消息，什么都不能干，这个是 Clique 测试网络存在的问题。我们不希望这种情况发生，希望网络永远是向前推进，即便是网络出现故障或者异常，只要保证后面的节点 OK 还是可以往前走的。解决这个问题就需要做一些改变，我们把 worker 产生的通知机制去掉。每次产生 seal 的方法不是通过这两个地方通知他，而是通过 Seal 本身判断自己，Seal 判断完之后注册下一个 Seal，这样永远保证它可以判断它自己。 场景分析 ﻿﻿&nbsp;&nbsp;根据上述内容，自己判断自己的话，需要给自己注册一个动作的定时器。还是以刚刚的场景分析，对于 A 节点来说，这个时间节点&nbsp;A&nbsp;不能出块，因为没有符合条件，他给自己定时器是什么时间点呢？一种方案是我在 T+9&nbsp;时去出块，我就等 9 秒钟或 6 秒钟判断我自己是不是有出块的资格。在实际测试中这种方案的效果并不是特别好。有两个原因； &nbsp;第一个是见证人的列表会发生变化，如果这个列表发生变化之后，下一次被唤醒的时候，出块的轮次也发生变化，这个时候就有可能错过了出块的机会，会导致整个网络的产块周期变的更加不稳定。&nbsp;第二，我的迭代时间比较长，降低自己出块的频次，一旦整个网络发生不稳定的情况下，会处于 side fork 的情况。整个网络每个节点都在出块，但是没有被其他的节点接受，我们希望尽可能的在短时间之内同步，也不能过分的小，过分的小会使产块的性能有问题。我们定义两个时段，一个是 3 秒钟，第二是定义一个最小值，其实在出块的时候，在节点出块之前会做打包、验证的工作。我们扣除时间消耗，打包时间过长，最小的值就会有用，可以帮助快速的出块。这种情况下，前面因为某种原因导致你的产块速度慢，或你有可能这个时间点应该出块，但压根没有出块，这个时候就小于 0 了，这个时候马上让他出块。 代码实现 &nbsp;&nbsp;&nbsp;在每个 Seal 方案里面会注册一个方法，使其在下次被调用，这个方法叫registernext 3.4.3 &nbsp; 自定义奖励规则 &nbsp;&nbsp;&nbsp;我们对奖励也做了变化, 对我们应用场景来说会改变奖励的分配规则，使我们适应不同的业务场景。﻿﻿&nbsp; &nbsp;首先在创世块当中确认奖励规则，这是一个 default-reward 的规则，这个规则可以在节点挖矿完之后按照这个规则去发放奖励，具体怎么做呢：就定一个接口，定义一个方法，比如我希望出块人可以获得五个币的奖励，在每次出完块之后，其他节点验证完之后，最后在这个数据结构里面，把账号里面的钱就增加5个币，这是最简单的实践。我们把代码抽出来之后扩展自己奖励分配的规则，根据时间出块，或者不给他奖励，或者通过其他方式奖励，或者把建立放在一个池里面。 4.智能合约的支点实践 4.1 &nbsp;合约语言 Solidity &nbsp;&nbsp;&nbsp;接下来讲一下我们在智能合约里面的实现。我们说的 DPOS 的机制，很大程度上是要跟智能合约所绑定在一起的，我们的投票人如何投票，我们的理事会成员如何选举见证人都是通过 DPOS 去做，这个可以和共识做一个相关联。 4.2 &nbsp;实现投票合约 4.2.1 &nbsp;理事会 ﻿&nbsp; &nbsp;我们对于理事会的投票思路就是普通用户，通过自己持有的投票权，质押投票权可以选举理事会的成员，会通过 Top N 的计算，自动去发生变化，现在一些 DPOS 的机制是有换届的概念，每天换一届，我们这边是自动的，这个时间点你只要票数够高，马上就成为理事会的成员。 4.2.2 &nbsp;见证人 ﻿&nbsp; &nbsp;见证人是通过理事会任命的，一个理事会成员有资格去发起一个提案，这个提案可能包含提名或者是移除一个见证人，他发起提案之后，其他理事会成员可以选择通过还是不通过，这个提案有一定时效期，超过这个时间窗口也是自动作废的，一旦超过半数就通过，如果半数以上否认掉那就是作废了。 4.3 &nbsp;智能合约设计模式 &nbsp; &nbsp;&nbsp;&nbsp;对于智能合约有很多资料，你可以通过业务的智能合约代码和控制器拆开，我们的业务是会变化的。对于智能合约来说，一旦进入到这个区块链是不能改的，这时你必须要写一个新的合约替代它，但是对外暴露的接口只有一个，可以把控制器和业务层分开，你只需要把控制器变更下面业务合约的地址就行。此外还有一种思路，我们可能会在智能合约里面存一些数据比如说存证数据，但是一旦新的业务实现之后，这个数据不通用，这两个智能合约虽然类似，但是数据是不通用的，我们把数据单独的划分出来，数据也是一个合约，不需要设计的过分的复杂，可以同时被上面的业务层所通用。 4.4 &nbsp;智能合约并不智能，反而有太多坑 &nbsp; &nbsp;智能合约本身有很多的限制，对于参数的数量限制，对于返回值的定长设置，包括智能合约的大小都不能定得特别大，所以说智能合约从现在的角度来说，还是需要一段时间优化。 4.5 &nbsp;智能合约设计模式，使用单一合约 &nbsp; 因为它本身也有一些问题在，所以理想的设计模式，有控制器层和数据存储层，我们都不要了，一开始是只有一个合约，或者只有一类合约来做所有的工作。后来发现一旦拆下来这些层之后，很多功能就不能这么做了，我们开发智能合约的思路就是跟我们写代码的思路是一样的，定义返回值，定义变向量，就做不了，最后通过单一合约去做这些事情。 5. 压力测试下暴露的问题 5.1 &nbsp; &nbsp;以太坊公链并不会有压力测试的场景，需要大量的优化和测试 ﻿ 5.2 &nbsp;流量控制 / 重发机制 &nbsp; ﻿﻿&nbsp; &nbsp;最简单的一点是通过一些流量控制和重发机制，我们对外业务调用的时候，不是直接连接到见证节点，而是网关节点，代码都是一样的，在里面会对所有的请求做一个限制。达到一定的程度之后就会拒绝请求。 5.2.1 &nbsp; 对交易请求进行检查，是否到达上限 ﻿﻿ &nbsp;&nbsp;&nbsp;实际的代码实现中，控制一下调用的接口，我们不想对&nbsp;p2p&nbsp;网络造成影响。 5.2.2 &nbsp; &nbsp;重发机制，防止p2p网络交易广播失败 ﻿﻿ &nbsp;&nbsp;&nbsp;这个在节点规模很大的情况下不大容易出现问题，但是在范围较小的情况下就会出现，我们在程序中的&nbsp;pending list&nbsp;里增加了重发的机制。 &nbsp; 2018年的 Gopher Meetup 将在深圳开启巡回第一站，这一次邀请了很多新的讲师给大家一起交流分享Go的使用经验〜 点击阅读原文报名参加 阅读更多" />
<link rel="canonical" href="http://0.0.0.0:4000/2018/05/10/%E5%9F%BA%E4%BA%8E-Go-Ethereum-%E6%9E%84%E5%BB%BA-DPOS-%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2018/05/10/%E5%9F%BA%E4%BA%8E-Go-Ethereum-%E6%9E%84%E5%BB%BA-DPOS-%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-10T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者简介 朱 崇 文 恺英网络区块链组技术经理 目 录 Go 版本以太坊 为何选择DPOS机制&nbsp;&nbsp; 拓展共识改造实践&nbsp;&nbsp; 智能合约的实践 压力测试下暴露的问题&nbsp;&nbsp; &nbsp; &nbsp;1. &nbsp;Go 版本以太坊 1.1 &nbsp;以太坊的客户端 ﻿﻿&nbsp; &nbsp;首先是以太坊技术社区的一些客户端的实现。以太坊技术协议本身是协议，它包含了一些接口协议，规范或参数定义和内部具体的实现逻辑和流程等。基于这个技术协议，可以用各自语言实现一个以太坊节点。以太坊的官方团队使用Go 语言实现了官方版本。partiy 的实现是第二大的客户端。 1.2 &nbsp;以太坊的工具组 ﻿核心组件包括 Solidity，Web3.js。对于大多数的开发者来说，最关心的是这两个组件。Swarm 一种外部存储的实现，希望拓展以太坊本身对于较大数据存放的问题，另外 IPFS 也是类似的功能实现。 1.3 以太坊公联网络拓扑 ﻿ &nbsp;图3 &nbsp;&nbsp;图3 是以太坊网络的拓扑图。包含了各种不同的客户端，他们之间相互组成了图中的网络。通过图3 就可以看到整个以太坊的公有链是非常开放的。 2. 为何选择DPOS机制 2.1 共识机制对比 &nbsp; &nbsp;&nbsp;&nbsp;DPOS 是一种共识机制，源自于石墨烯技术。简单对比一下以太坊的官方社区提供的 POW 机制。POW 是消耗你的计算力来产块，它出块速度慢，确认慢。而 DPOS 是代理人的模式。现阶段实现的 DPOS 的机制 TPS 可达 1000，平均确认的时间在 1~3 秒钟。 2.2 DPOS机制的优势 &nbsp; &nbsp; 我们实现了的 DPOS 机制的优势主要在于两个方面。第一是系统可靠性。在商业场景下，网络性能可控，在异常情况下能快速处理并恢复，同时对TPS/QPS，以及确认时间有一定的要求。第二，共识机制是一种思想，以公有链为基础，可对外开放，任何人都可以参与，设立理事会和见证人角色，理事会管理区块链网络，见证人生产并验证区块，构成了一个良性的生态圈。 2.3 &nbsp;DPOS机制的理念 图4 &nbsp;&nbsp;&nbsp;图4表示，我们把一个公司和社区定义为三种角色，普通社区成员会通过自己手上的投票权选举理事会。理事会通过自己的判断或认知来委任见证人。见证人根据自己实际情况维持整个链的运作，这是 DPOS&nbsp;机制的理念。 3. 拓展共识改造实践 3.1 &nbsp;共识框架引擎 3.1.1 &nbsp;改造共识层逻辑 &nbsp;图5 &nbsp;&nbsp;图5显示，如何实现 DPOS 的机制。以太坊的接口服务是提供客户端调用，网络通讯是为 p2p 提供服务。 中间是一个共识层，是去做挖矿还是去做 DPOS 等其他共识，在这个上面都可以做一个扩展。最下面就是存储，区块的存储和状态都是通过这层做的。 3.1.2 &nbsp;官方实现引擎 ：Ethash/Clique ﻿图6 &nbsp;&nbsp;图6 显示&nbsp;，我们通过共识层来达到DPOS目的 。图上代码直接截取了以太坊的代码，这是一个接口引擎，提供了一些方法，看到这些方法名字，很多都是在 Verify。Verify 对整个以太坊非常重要，区块链是不可篡改的，它需要对各种各样的异常情况做验证。&nbsp;最上面的文字写到官方上有两个引擎，第一个是在公有链上所使用的引擎，是 POW 机制的实现。第二个是 Clique，修改为 Dpos 很大的灵感来自于 Clique 引擎。 3.1.3 &nbsp;Seal 核心方法调用 ﻿ 图7 &nbsp;&nbsp;&nbsp;图7有点复杂，它能帮助我们了解以太坊内部的逻辑，首先通过 agent 和 worker 两个方法，去监听他们自己的对象，这两个 channel 一旦有数据会触发下面的事情。我们先看 worker channel，这个 channel 里面有新的 work出来会发生不同的事情。worker 是有工作的命令，一旦收到这个 worker 的 channel，就要判断自己有没有能力挖矿，是否要做打包工作，触发这个 channel 之后，就调用引擎里面的方法，然后 seal 就去解决问题。最终的题目是谁解出来，谁就有权利或者资格去挖这个区块，这个 seal 方法就成功了，接着会产生一个Result 的对象，会触发下面的工作，一旦产生出块之后就会有新的 worker 放在新的 channel 上去，如果我一直可以产块，就可以不断地做这个流程，这样就构成了以太坊矿工节点里面核心挖矿的流程。此外 work channel 也有一个自己的触发机制。这个时候就需要依赖外部的节点了，当其他节点产生区块的时候，会向我们这个节点广播，我就会同步出块，通知这个 channel 有新的工作区去做。刚刚讲的是接口引擎里面最重要的 Seal 方法，我们可以通过修改这个方法，把原来需要解决题目的挖矿改成不解决题目。 3.2 借鉴 Clique （POA) 的实现 ﻿ 图8 &nbsp;&nbsp;&nbsp;另一种共识机制是 Clique。以太坊公链使用 POW 机制，通过节点数量来防止别人恶意攻击。同时，以太坊提供一些测试链。但测试链用 POW 发布之后有一个问题，测试链没有很多人同时参与维护，如果有人恶意搞它就非常简单，通过一些机器和算力很容易把它搞瘫痪掉。为了能够让测试链比较稳定的运行，开发了另外一种共识机制取代了 POW，只有授权的机器才可以生产区块，这样维护成本非常低，找一些机器授权给他就能够去维持这个网络。整个网络通过授权过的人去出块，节点之间通过投票的方式来授权或者剔除授权，这些额外的投票机制记录在区块头的 extra data 字段里面。 &nbsp;&nbsp;&nbsp;图8右边的图是测试链的产块逻辑。假定有 A、B、C 三个节点的话，正常逻辑 A&nbsp;完成之后到&nbsp;B，B&nbsp;完成之后到&nbsp;C。图中有一个竞争出块的概念，出 C 的时候不仅仅是 C 产块，A 也可以产块，为什么呢？ 因为避免 C&nbsp;节点有问题的时候，不能产块，A 节点的块也能提供出来加入到链里面。同时，如果 C 在当前轮次里面，字段有一个 difficult 字段值就是 2，而这个 A 虽然可以产块，但不在这个轮次里面，所以 difficult 就是 1，尽可能保证 C 这个节点产生的块被大多数的节点所接受，这是以太坊最常见的概念。 图9 &nbsp;&nbsp;&nbsp;图9&nbsp;是轮次问题，也做了小的改动，这两个节点可以竞争出块，对于它，我们希望 C 节点的块尽量被接受，所以对 A 节点来说，如果不是这个轮次里面的话，可以让A节点出块的时间变得稍微延后一些。比如在现在这个时间点应该可以出块的，但我要控制让它晚一些时候出块，这样就避免会产生过多的分叉，虽然可以通过 difficult 值来决定谁是最长链，但过多的分叉会导致链的状态越不稳定。 3.3 扩展区块头结构 3.3.1 &nbsp;增加见证人列表 ﻿图10 &nbsp;&nbsp;&nbsp;我们借鉴 Clique 的想法之后，会想怎么扩展我们的 DPOS 机制。首先我们会先修改数据结构，对区块的 Header 的结构，定义新的字段，下面的&nbsp;WitnessVotes 是我们自己定义的字段，我们希望通过这个字段来为 DPOS 机制提供节点授权，我们扩展这个字段，把见证人的地址列出，按照字典做排序，这样能避免出块轮次发生变化的问题。以太坊对于字段扩展是非常容易做的，在代码的框架里体统了框架的主体架构，我们只需要增加一些代码，就可以很容易扩容它的 Header 了。 3.3.2 &nbsp;见证人列表生成规则﻿﻿&nbsp;图11 &nbsp;图11是 witness 的列表。对以太坊来的验证机制而言，两个区块，即便区块数据一样，但是区块的成产者不一样，也是不被接受的。为了达到这个目的，我们就需要约定好方案，对于见证人的列表来说，必须依托于父节点。如果现在区块链上被确认的区块高度是 Block N，现在要产生 Block N+1 的区块，我们如何填充区块的见证人列表? 我们必须通过 Block N 的区块达成共识，当前的 Block N 上面的见证人列表是谁，就填到下一个见证人列表当中去。对创始块来说，我们通过创世配置文件，把见证人列表直接写在创世块中。 3.4 &nbsp;轮流生产者的实现 3.4.1判断当前轮次是否需要产块 &nbsp;&nbsp;&nbsp;当每个节点收到一些条件之后，如何判断自己可以出块？普通的是通过计算题目，现在是通过一些条件判断，我们根据以下几个条件值: 当前的时间戳、当前区块的产块人，Parent 区块的见证人列表，Parent 区块的产块人，Parent 区块的时间戳，产块周期来共同计算出来当前矿工到底有没有资格出块。如果现在没有资格，那不应该出块。 3.4.2 &nbsp;轮流生产者的实现—分析 场景分析 &nbsp;&nbsp;&nbsp;图中，如果我们有 A、B、C 三个节点，这是他们的 parent 节点的数据结构，parent 见证人的列表是 ABC，时间戳是 T，产块周期是 3 秒钟，当前的时间点是&nbsp;T+3，这三个节点点各自判断有没有资格出块。根据图，我们发现见证人列表永远都是 ABC，父节点产块人是&nbsp;A，下一个要 B 产块，B&nbsp;在&nbsp;T+3&nbsp;时间可以产块，A 和 C 在 T+3 的时间节点是不能产块的。A 可能要等到 T+9 的时间点产块，C 是 T+6&nbsp;的时间点可以产块。这样才能保证整个网络持续的往下运行。 判断当前轮次—代码实现 ﻿ &nbsp;&nbsp;&nbsp;逻辑通过代码实现，我们根据条件来计算一个值，计算出轮次查， 我们可以根据时间戳和产块节点和当地时间戳判断是不是可以出块。 注册下一次调用 原因 ﻿ &nbsp;&nbsp;&nbsp;还有一个问题是产块没到自己的轮次或现在不应该产块，所以不会产生结果对象，也就不会触发提交新的 worker，也没有其他的时间节点触发这个 channel，这个时候我收不到任何消息，什么都不能干，这个是 Clique 测试网络存在的问题。我们不希望这种情况发生，希望网络永远是向前推进，即便是网络出现故障或者异常，只要保证后面的节点 OK 还是可以往前走的。解决这个问题就需要做一些改变，我们把 worker 产生的通知机制去掉。每次产生 seal 的方法不是通过这两个地方通知他，而是通过 Seal 本身判断自己，Seal 判断完之后注册下一个 Seal，这样永远保证它可以判断它自己。 场景分析 ﻿﻿&nbsp;&nbsp;根据上述内容，自己判断自己的话，需要给自己注册一个动作的定时器。还是以刚刚的场景分析，对于 A 节点来说，这个时间节点&nbsp;A&nbsp;不能出块，因为没有符合条件，他给自己定时器是什么时间点呢？一种方案是我在 T+9&nbsp;时去出块，我就等 9 秒钟或 6 秒钟判断我自己是不是有出块的资格。在实际测试中这种方案的效果并不是特别好。有两个原因； &nbsp;第一个是见证人的列表会发生变化，如果这个列表发生变化之后，下一次被唤醒的时候，出块的轮次也发生变化，这个时候就有可能错过了出块的机会，会导致整个网络的产块周期变的更加不稳定。&nbsp;第二，我的迭代时间比较长，降低自己出块的频次，一旦整个网络发生不稳定的情况下，会处于 side fork 的情况。整个网络每个节点都在出块，但是没有被其他的节点接受，我们希望尽可能的在短时间之内同步，也不能过分的小，过分的小会使产块的性能有问题。我们定义两个时段，一个是 3 秒钟，第二是定义一个最小值，其实在出块的时候，在节点出块之前会做打包、验证的工作。我们扣除时间消耗，打包时间过长，最小的值就会有用，可以帮助快速的出块。这种情况下，前面因为某种原因导致你的产块速度慢，或你有可能这个时间点应该出块，但压根没有出块，这个时候就小于 0 了，这个时候马上让他出块。 代码实现 &nbsp;&nbsp;&nbsp;在每个 Seal 方案里面会注册一个方法，使其在下次被调用，这个方法叫registernext 3.4.3 &nbsp; 自定义奖励规则 &nbsp;&nbsp;&nbsp;我们对奖励也做了变化, 对我们应用场景来说会改变奖励的分配规则，使我们适应不同的业务场景。﻿﻿&nbsp; &nbsp;首先在创世块当中确认奖励规则，这是一个 default-reward 的规则，这个规则可以在节点挖矿完之后按照这个规则去发放奖励，具体怎么做呢：就定一个接口，定义一个方法，比如我希望出块人可以获得五个币的奖励，在每次出完块之后，其他节点验证完之后，最后在这个数据结构里面，把账号里面的钱就增加5个币，这是最简单的实践。我们把代码抽出来之后扩展自己奖励分配的规则，根据时间出块，或者不给他奖励，或者通过其他方式奖励，或者把建立放在一个池里面。 4.智能合约的支点实践 4.1 &nbsp;合约语言 Solidity &nbsp;&nbsp;&nbsp;接下来讲一下我们在智能合约里面的实现。我们说的 DPOS 的机制，很大程度上是要跟智能合约所绑定在一起的，我们的投票人如何投票，我们的理事会成员如何选举见证人都是通过 DPOS 去做，这个可以和共识做一个相关联。 4.2 &nbsp;实现投票合约 4.2.1 &nbsp;理事会 ﻿&nbsp; &nbsp;我们对于理事会的投票思路就是普通用户，通过自己持有的投票权，质押投票权可以选举理事会的成员，会通过 Top N 的计算，自动去发生变化，现在一些 DPOS 的机制是有换届的概念，每天换一届，我们这边是自动的，这个时间点你只要票数够高，马上就成为理事会的成员。 4.2.2 &nbsp;见证人 ﻿&nbsp; &nbsp;见证人是通过理事会任命的，一个理事会成员有资格去发起一个提案，这个提案可能包含提名或者是移除一个见证人，他发起提案之后，其他理事会成员可以选择通过还是不通过，这个提案有一定时效期，超过这个时间窗口也是自动作废的，一旦超过半数就通过，如果半数以上否认掉那就是作废了。 4.3 &nbsp;智能合约设计模式 &nbsp; &nbsp;&nbsp;&nbsp;对于智能合约有很多资料，你可以通过业务的智能合约代码和控制器拆开，我们的业务是会变化的。对于智能合约来说，一旦进入到这个区块链是不能改的，这时你必须要写一个新的合约替代它，但是对外暴露的接口只有一个，可以把控制器和业务层分开，你只需要把控制器变更下面业务合约的地址就行。此外还有一种思路，我们可能会在智能合约里面存一些数据比如说存证数据，但是一旦新的业务实现之后，这个数据不通用，这两个智能合约虽然类似，但是数据是不通用的，我们把数据单独的划分出来，数据也是一个合约，不需要设计的过分的复杂，可以同时被上面的业务层所通用。 4.4 &nbsp;智能合约并不智能，反而有太多坑 &nbsp; &nbsp;智能合约本身有很多的限制，对于参数的数量限制，对于返回值的定长设置，包括智能合约的大小都不能定得特别大，所以说智能合约从现在的角度来说，还是需要一段时间优化。 4.5 &nbsp;智能合约设计模式，使用单一合约 &nbsp; 因为它本身也有一些问题在，所以理想的设计模式，有控制器层和数据存储层，我们都不要了，一开始是只有一个合约，或者只有一类合约来做所有的工作。后来发现一旦拆下来这些层之后，很多功能就不能这么做了，我们开发智能合约的思路就是跟我们写代码的思路是一样的，定义返回值，定义变向量，就做不了，最后通过单一合约去做这些事情。 5. 压力测试下暴露的问题 5.1 &nbsp; &nbsp;以太坊公链并不会有压力测试的场景，需要大量的优化和测试 ﻿ 5.2 &nbsp;流量控制 / 重发机制 &nbsp; ﻿﻿&nbsp; &nbsp;最简单的一点是通过一些流量控制和重发机制，我们对外业务调用的时候，不是直接连接到见证节点，而是网关节点，代码都是一样的，在里面会对所有的请求做一个限制。达到一定的程度之后就会拒绝请求。 5.2.1 &nbsp; 对交易请求进行检查，是否到达上限 ﻿﻿ &nbsp;&nbsp;&nbsp;实际的代码实现中，控制一下调用的接口，我们不想对&nbsp;p2p&nbsp;网络造成影响。 5.2.2 &nbsp; &nbsp;重发机制，防止p2p网络交易广播失败 ﻿﻿ &nbsp;&nbsp;&nbsp;这个在节点规模很大的情况下不大容易出现问题，但是在范围较小的情况下就会出现，我们在程序中的&nbsp;pending list&nbsp;里增加了重发的机制。 &nbsp; 2018年的 Gopher Meetup 将在深圳开启巡回第一站，这一次邀请了很多新的讲师给大家一起交流分享Go的使用经验〜 点击阅读原文报名参加 阅读更多","@type":"BlogPosting","url":"http://0.0.0.0:4000/2018/05/10/%E5%9F%BA%E4%BA%8E-Go-Ethereum-%E6%9E%84%E5%BB%BA-DPOS-%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE.html","headline":"基于 Go-Ethereum 构建 DPOS 机制下的区块链","dateModified":"2018-05-10T00:00:00+08:00","datePublished":"2018-05-10T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2018/05/10/%E5%9F%BA%E4%BA%8E-Go-Ethereum-%E6%9E%84%E5%BB%BA-DPOS-%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>

  </head>
  <body>
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基于 Go-Ethereum 构建 DPOS 机制下的区块链</h1>
        
        
        <ul>
            <li><a href="https://blog.uzzz.org/" target="_blank"><strong>柚子社区<br/>(国际版)</strong></a></li>
            <li><a href="https://blog.uzzz.org.cn/" target="_blank"><strong>柚子社区<br/>(国内版)</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

      <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <div class="rich_media_content"> 
   <img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibCvMNgZ6zymiceCibpUOtGhtUlZ14ohHyupmhqL4hdyb24cFKFu9ErsqygrdocHyMmrJq55bWz0pZTA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt="640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1">
   <p style="clear:none;">作者简介</p>
   <img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibCvMNgZ6zymiceCibpUOtGhtUaKxmZ21YgNNbNAhRHqJKwqoqNnj4RCc5CDLINiaPnia9PFyib3v8MTpFA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;retryload=1" alt="640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;retryload=1">
   <p><strong>朱 崇 文</strong></p>
   <p style="text-align:left;color:rgb(0,0,0);text-transform:none;text-indent:2em;letter-spacing:normal;font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', sans-serif;font-size:14.66px;font-style:normal;font-variant:normal;font-weight:400;text-decoration:none;word-spacing:0px;background-color:transparent;"><span class="ql-author-297664 ql-size-12" style="color:rgb(0,0,0);"></span><span><span class="ql-author-297664 ql-size-12">恺英网络</span><span class="ql-size-12 ql-author-10256377">区块链组技术经理</span></span><span class="ql-author-297664 ql-size-12" style="color:rgb(0,0,0);"></span><br></p>
   <p><br></p>
   <br>
   <p><br></p>
   <p style="clear:none;"><br></p>
   <p>目</p>
   <p><br></p>
   <p>录</p>
   <p><br></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496">Go 版本以太坊</p>
   <p class="ql-long-9863496">为何选择DPOS机制&nbsp;&nbsp;</p>
   <p class="ql-long-9863496">拓展共识改造实践&nbsp;&nbsp;</p>
   <p class="ql-long-9863496">智能合约的实践</p>
   <p class="ql-long-9863496">压力测试下暴露的问题&nbsp;&nbsp;</p>
   <p><br></p>
   <br>
   <p class="ql-indent-1"><span>&nbsp;</span></p>
   <p class="ql-indent-1"><span class="ql-author-9863496 ql-size-12" style="color:rgb(77,168,238);">&nbsp;</span><strong class="ql-author-9863496 ql-size-12" style="color:rgb(77,168,238);">1. &nbsp;Go 版本以太坊</strong></p>
   <p class="ql-long-9863496" style="text-align:left;"><strong><em class="ql-author-9863496 ql-size-12"><br></em></strong></p>
   <p class="ql-long-9863496" style="text-align:left;"><strong><em class="ql-author-9863496 ql-size-12">1.1 &nbsp;以太坊的客户端</em></strong></p>
   <p class="ql-long-9863496" style="text-align:left;"><strong>﻿</strong><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loadederror" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBL3ibYsNVV5TjyHKibpbia5bY8q6USibcZicpicFCMLRBUvGKq5MyqHEmndNug/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿<span class="ql-author-9863496 ql-size-12">&nbsp; &nbsp;</span><span class="ql-size-12 ql-author-297664">首先</span><span class="ql-size-12 ql-author-9863496">是</span><span class="ql-size-12 ql-author-297664">以太坊技术社区的一些客户端的实现</span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-297664">以太坊技术协议</span><span class="ql-size-12 ql-author-10256377">本身是</span><span class="ql-size-12 ql-author-297664">协议，</span><span class="ql-size-12 ql-author-9863496">它</span><span class="ql-size-12 ql-author-297664">包含了一些接口协议，规范或参数定义和内部具体的实现逻辑和流程</span><span class="ql-size-12 ql-author-10256377">等</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">基于这个技术协议，</span><span class="ql-size-12 ql-author-10256377">可以</span><span class="ql-size-12 ql-author-297664">用</span><span class="ql-size-12 ql-author-10256377">各自</span><span class="ql-size-12 ql-author-297664">语言实现一个以太坊</span><span class="ql-size-12 ql-author-10256377">节点</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">以太坊的官方团队使用Go </span><span class="ql-size-12 ql-author-9863496">语言</span><span class="ql-size-12 ql-author-297664">实现</span><span class="ql-size-12 ql-author-9863496">了</span><span class="ql-size-12 ql-author-10256377">官方</span><span class="ql-size-12 ql-author-297664">版本</span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-9863496">p</span><span class="ql-size-12 ql-author-297664">artiy </span><span class="ql-size-12 ql-author-10256377">的实</span><span class="ql-size-12 ql-author-297664">现是第二大的客户端</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">1.2 &nbsp;以太坊的工具组</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLk5RgdBhc9qYm3gvSYMmZXEjZNg430T0j2GVvxkAf7jC4j9SPibKsvcA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span><span class="ql-size-12 ql-author-297664">核心组件包括</span><span class="ql-size-12 ql-author-10256377"> </span><span class="ql-size-12 ql-author-297664">Solidity</span><span class="ql-size-12 ql-author-10256377">，Web3.js。</span><span class="ql-size-12 ql-author-297664">对于</span><span class="ql-size-12 ql-author-9863496">大多数的</span><span class="ql-size-12 ql-author-297664">开发者来说，最关</span><span class="ql-size-12 ql-author-10256377">心</span><span class="ql-size-12 ql-author-297664">的是</span><span class="ql-size-12 ql-author-10256377">这两个组件</span><span class="ql-size-12 ql-author-297664">。Swarm 一种外部存储</span><span class="ql-size-12 ql-author-10256377">的实现</span><span class="ql-size-12 ql-author-297664">，希望拓展以太坊本身对于较</span><span class="ql-size-12 ql-author-10256377">大数据存放的问题，另外 IPFS 也是类似的功能实现。</span></p>
   <p class="ql-long-9863496"><span class="ql-size-12 ql-author-10256377"><br></span></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">1.3 以太坊公联网络拓扑</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLZWwfSlzVQQsNlibibk9ZOERRGm3sJGsxEIlLk5ejj3byDHR5ibKHZkueg/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span></p>
   <p class="ql-align-center ql-long-9863496" style="text-align:center;"><span class="ql-author-297664 ql-size-12">&nbsp;</span><strong><span class="ql-size-12 ql-author-9863496">图3</span></strong></p>
   <p class="ql-long-297664"><span class="ql-author-9863496 ql-size-12"> </span><span class="ql-size-12 ql-author-297664">&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">图3 </span><span class="ql-size-12 ql-author-297664">是以太坊</span><span class="ql-size-12 ql-author-10256377">网络</span><span class="ql-size-12 ql-author-297664">的拓扑图</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">包含了</span><span class="ql-size-12 ql-author-9863496">各种不同</span><span class="ql-size-12 ql-author-297664">的客户端，他们之间相互组成了</span><span class="ql-size-12 ql-author-9863496">图中的</span><span class="ql-size-12 ql-author-10256377">网络</span><span class="ql-size-12 ql-author-297664">。通过图</span><span class="ql-size-12 ql-author-9863496">3 </span><span class="ql-size-12 ql-author-297664">就可以看到整个以太坊</span><span class="ql-size-12 ql-author-10256377">的公有链</span><span class="ql-size-12 ql-author-297664">是非常开放的</span><span class="ql-size-12 ql-author-10256377">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong class="ql-author-9863496 ql-size-12" style="color:rgb(77,168,238);">2. 为何选择DPOS机制</strong></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">2.1 共识机制对比 &nbsp;</em></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;DPOS 是</span><span class="ql-size-12 ql-author-10256377">一种</span><span class="ql-size-12 ql-author-297664">共识机制，</span><span class="ql-size-12 ql-author-10256377">源自于石墨烯技术</span><span class="ql-size-12 ql-author-297664">。简单对比一下以太坊的官方社区提供的 POW </span><span class="ql-size-12 ql-author-10256377">机制。POW 是</span><span class="ql-size-12 ql-author-297664">消耗你的</span><span class="ql-size-12 ql-author-10256377">计算力来产块，它</span><span class="ql-size-12 ql-author-297664">出块速度慢，确认慢。</span><span class="ql-size-12 ql-author-10256377">而 </span><span class="ql-size-12 ql-author-297664">DPOS 是代理人的模式。</span><span class="ql-size-12 ql-author-10256377">现阶段实现的 DPOS 的机制 TPS 可达 1000，</span><span class="ql-size-12 ql-author-297664">平均确认的时间</span><span class="ql-size-12 ql-author-10256377">在 1~</span><span class="ql-size-12 ql-author-297664">3 秒钟</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">2.2 DPOS机制的优势 &nbsp;</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12"> &nbsp; </span><span class="ql-size-12 ql-author-10256377">我们实现了的 </span><span class="ql-size-12 ql-author-297664">DPOS 机制的优势主要</span><span class="ql-size-12 ql-author-10256377">在于两个方面</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">第一是</span><span class="ql-size-12 ql-author-9863496">系统可靠性。在商业场景下，网络性能可控</span><span class="ql-size-12 ql-author-10256377">，在</span><span class="ql-size-12 ql-author-9863496">异常情况</span><span class="ql-size-12 ql-author-10256377">下</span><span class="ql-size-12 ql-author-9863496">能快速处理并恢复</span><span class="ql-size-12 ql-author-10256377">，同时</span><span class="ql-size-12 ql-author-9863496">对TPS/QPS，</span><span class="ql-author-9863496 ql-size-12">以及确认</span><span class="ql-size-12 ql-author-10256377">时间</span><span class="ql-size-12 ql-author-9863496">有一定的要求。</span><span class="ql-size-12 ql-author-10256377">第二，</span><span class="ql-size-12 ql-author-297664">共识机制是一种思想</span><span class="ql-size-12 ql-author-10256377">，</span><span class="ql-size-12 ql-author-9863496">以公有链为基础，可对外开放</span><span class="ql-size-12 ql-author-10256377">，</span><span class="ql-size-12 ql-author-9863496">任何人都可以参与，设立理事会和见证人角色</span><span class="ql-size-12 ql-author-10256377">，</span><span class="ql-size-12 ql-author-9863496">理事会管理区块链网络</span><span class="ql-size-12 ql-author-10256377">，</span><span class="ql-size-12 ql-author-9863496">见证人生产并验证区块，</span><span class="ql-size-12 ql-author-10256377">构成了一个良性的生态圈。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">2.3 &nbsp;DPOS机制的理念</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLv9BVz3XbY3VNylkKSDnoicicAianE212VUlExm3KIQhgjZJiawgticFwVEA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-align-center ql-long-9863496" style="text-align:center;"><strong><span class="ql-author-9863496">图4</span></strong><span class="ql-author-9863496"> </span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;图</span><span class="ql-size-12 ql-author-9863496">4</span><span class="ql-size-12 ql-author-297664">表示，我们把一个公司和社区定义</span><span class="ql-size-12 ql-author-10256377">为</span><span class="ql-size-12 ql-author-297664">三种角色，普通社区成员会通过自己手上的</span><span class="ql-size-12 ql-author-10256377">投票权</span><span class="ql-size-12 ql-author-297664">选举理事会</span><span class="ql-size-12 ql-author-10256377">。理事会</span><span class="ql-size-12 ql-author-297664">通过自己的判断</span><span class="ql-size-12 ql-author-9863496">或</span><span class="ql-size-12 ql-author-10256377">认知</span><span class="ql-size-12 ql-author-9863496">来</span><span class="ql-size-12 ql-author-297664">委任见证人</span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-297664">见证人根据自己实际情况维持整个</span><span class="ql-size-12 ql-author-10256377">链</span><span class="ql-size-12 ql-author-297664">的运作</span><span class="ql-size-12 ql-author-10256377">，</span><span class="ql-size-12 ql-author-9863496">这</span><span class="ql-size-12 ql-author-297664">是 DPOS&nbsp;</span><span class="ql-size-12 ql-author-9863496">机制的</span><span class="ql-size-12 ql-author-297664">理念</span><span class="ql-size-12 ql-author-10256377">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong class="ql-author-9863496 ql-size-12" style="color:rgb(77,168,238);">3. 拓展共识改造实践</strong></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">3.1 &nbsp;共识框架引擎</em></strong><em class="ql-author-9863496 ql-size-12"> </em></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.1.1 &nbsp;改造共识层逻辑</span></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLvaNXhfRib4fGMMH5cJt5iaBicoOBHCD2picibIiaPGibfkwZ6oltsrQoOUwTg/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-align-center ql-long-9863496" style="text-align:center;"><strong><span class="ql-author-297664 ql-size-12">&nbsp;</span><span class="ql-size-12 ql-author-9863496">图5</span></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">图5显示，</span><span class="ql-size-12 ql-author-297664">如何实现 DPOS 的机制</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">以太坊的接口服务</span><span class="ql-size-12 ql-author-10256377">是提供</span><span class="ql-size-12 ql-author-9863496">客户端调用</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">网络通讯是为 p2p 提供服务。 </span><span class="ql-size-12 ql-author-297664">中间是一个共识层，是去做挖矿还是去做 DPOS </span><span class="ql-size-12 ql-author-10256377">等其他共识</span><span class="ql-size-12 ql-author-297664">，在这个上面都可以做一个扩展。</span><span class="ql-size-12 ql-author-10256377">最</span><span class="ql-size-12 ql-author-297664">下面就是存储，区块的存储和状态都是通过这层做的。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.1.2 &nbsp;官方实现引擎 ：Ethash/Clique</span></p>
   <p class="ql-long-9863496" style="text-align:center;"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLAR4TA347shL1ubRNhbbhHo7ib3q2NMgSZASUM8C0wsd5FkibQcqY1sMA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span><strong><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿</span></span>图6</strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">图6 显示</span><span class="ql-size-12 ql-author-297664">&nbsp;</span><span class="ql-size-12 ql-author-9863496">，</span><span class="ql-size-12 ql-author-297664">我们</span><span class="ql-size-12 ql-author-10256377">通过共识层来</span><span class="ql-size-12 ql-author-297664">达到DPOS目的</span><span class="ql-size-12 ql-author-9863496"> </span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-9863496">图上代码</span><span class="ql-size-12 ql-author-297664">直接</span><span class="ql-size-12 ql-author-10256377">截取</span><span class="ql-size-12 ql-author-9863496">了</span><span class="ql-size-12 ql-author-297664">以太坊的代码，</span><span class="ql-size-12 ql-author-10256377">这</span><span class="ql-size-12 ql-author-297664">是一个接口引擎，提供了一些方法，看到</span><span class="ql-size-12 ql-author-9863496">这些</span><span class="ql-size-12 ql-author-297664">方法名字，很多都是在 </span><span class="ql-size-12 ql-author-9863496">Verify。Verify </span><span class="ql-size-12 ql-author-297664">对整个以太坊非常重要，区块链是不可篡改的，它需要对各种各样的异常情况做验证</span><span class="ql-size-12 ql-author-9863496">。&nbsp;最上面的文字写到官方上有两个引擎，第一个是在</span><span class="ql-size-12 ql-author-10256377">公有链</span><span class="ql-size-12 ql-author-9863496">上</span><span class="ql-size-12 ql-author-10256377">所使用的</span><span class="ql-size-12 ql-author-9863496">引擎，</span><span class="ql-size-12 ql-author-10256377">是 </span><span class="ql-size-12 ql-author-9863496">POW </span><span class="ql-size-12 ql-author-10256377">机制的实现</span><span class="ql-size-12 ql-author-9863496">。第二个是 Clique，</span><span class="ql-size-12 ql-author-10256377">修改为 Dpos </span><span class="ql-size-12 ql-author-9863496">很大的灵感来自于 </span><span class="ql-size-12 ql-author-10256377">Clique</span><span class="ql-size-12 ql-author-9863496"> 引擎。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.1.3 &nbsp;Seal 核心方法调用</span></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLSBJLzWV0wcLHd9dkVGULUh9z1qiaqJNRnjialWz0n3uiahVoXUpcM85LA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-align-center ql-long-9863496" style="text-align:center;"><strong><span class="ql-author-9863496">图7</span></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;图</span><span class="ql-size-12 ql-author-9863496">7</span><span class="ql-size-12 ql-author-297664">有点复杂</span><span class="ql-size-12 ql-author-9863496">，它能</span><span class="ql-size-12 ql-author-297664">帮助我们了解以太坊内部的逻辑，首先通过</span><span class="ql-size-12 ql-author-9863496"> agent </span><span class="ql-size-12 ql-author-297664">和</span><span class="ql-size-12 ql-author-9863496"> </span><span class="ql-size-12 ql-author-297664">work</span><span class="ql-size-12 ql-author-9863496">er </span><span class="ql-size-12 ql-author-297664">两个方法，去监听他们自己的对象，这两个</span><span class="ql-size-12 ql-author-9863496"> channel </span><span class="ql-size-12 ql-author-297664">一旦有数据会触发下面的事情。我们先看</span><span class="ql-size-12 ql-author-9863496"> worker channel</span><span class="ql-size-12 ql-author-297664">，这个</span><span class="ql-size-12 ql-author-9863496"> channel </span><span class="ql-size-12 ql-author-297664">里面有新的</span><span class="ql-size-12 ql-author-9863496"> work</span><span class="ql-size-12 ql-author-297664">出来会发生</span><span class="ql-size-12 ql-author-9863496">不同的</span><span class="ql-size-12 ql-author-297664">事情。worker 是有工作的</span><span class="ql-size-12 ql-author-9863496">命令</span><span class="ql-size-12 ql-author-297664">，一旦收到</span><span class="ql-size-12 ql-author-10256377">这个 </span><span class="ql-size-12 ql-author-297664">worker </span><span class="ql-size-12 ql-author-9863496">的 channel</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">就</span><span class="ql-size-12 ql-author-297664">要判断自己有没有能力挖矿，</span><span class="ql-size-12 ql-author-10256377">是否</span><span class="ql-size-12 ql-author-297664">要做打包工作，触发这个 </span><span class="ql-size-12 ql-author-9863496">channel </span><span class="ql-size-12 ql-author-297664">之后，就</span><span class="ql-size-12 ql-author-10256377">调用</span><span class="ql-size-12 ql-author-297664">引擎里面的方法，然后 </span><span class="ql-size-12 ql-author-9863496">seal </span><span class="ql-size-12 ql-author-297664">就去</span><span class="ql-size-12 ql-author-9863496">解决</span><span class="ql-size-12 ql-author-10256377">问题</span><span class="ql-size-12 ql-author-297664">。最终的</span><span class="ql-size-12 ql-author-10256377">题目</span><span class="ql-size-12 ql-author-297664">是</span><span class="ql-size-12 ql-author-10256377">谁</span><span class="ql-size-12 ql-author-297664">解出来，</span><span class="ql-size-12 ql-author-10256377">谁</span><span class="ql-size-12 ql-author-297664">就</span><span class="ql-size-12 ql-author-9863496">有</span><span class="ql-size-12 ql-author-297664">权利或者资格去挖这个</span><span class="ql-size-12 ql-author-10256377">区块，</span><span class="ql-size-12 ql-author-297664">这个 s</span><span class="ql-size-12 ql-author-9863496">ea</span><span class="ql-size-12 ql-author-297664">l 方法</span><span class="ql-size-12 ql-author-10256377">就</span><span class="ql-size-12 ql-author-297664">成功了，</span><span class="ql-size-12 ql-author-10256377">接着</span><span class="ql-size-12 ql-author-297664">会产生一个Result 的对象，会触发下面的工作，一旦产生出块之后</span><span class="ql-size-12 ql-author-10256377">就会有新的 </span><span class="ql-size-12 ql-author-297664">worker 放在新的 </span><span class="ql-size-12 ql-author-9863496">channel 上</span><span class="ql-size-12 ql-author-297664">去，如果我一直可以产块，就可以不断地做</span><span class="ql-size-12 ql-author-10256377">这个</span><span class="ql-size-12 ql-author-297664">流程，</span><span class="ql-size-12 ql-author-10256377">这样就</span><span class="ql-size-12 ql-author-297664">构成</span><span class="ql-size-12 ql-author-10256377">了</span><span class="ql-size-12 ql-author-297664">以太坊矿工节点里面核心挖矿的流程。此外 work</span><span class="ql-size-12 ql-author-9863496"> channel </span><span class="ql-size-12 ql-author-297664">也有一个自己的触发机制。这个时候就需要</span><span class="ql-size-12 ql-author-10256377">依赖</span><span class="ql-size-12 ql-author-297664">外部的节点</span><span class="ql-size-12 ql-author-10256377">了</span><span class="ql-size-12 ql-author-297664">，当</span><span class="ql-size-12 ql-author-10256377">其他节点</span><span class="ql-size-12 ql-author-297664">产生</span><span class="ql-size-12 ql-author-10256377">区块</span><span class="ql-size-12 ql-author-297664">的时候，会向我们这个节点广播，我就会同步</span><span class="ql-size-12 ql-author-9863496">出块，通知这个 channel 有新的工作区</span><span class="ql-size-12 ql-author-10256377">去</span><span class="ql-size-12 ql-author-9863496">做。刚刚讲的是接口引擎里面最重要的 Seal 方法，</span><span class="ql-size-12 ql-author-10256377">我们可以通过修改这个方法，</span><span class="ql-size-12 ql-author-9863496">把原来</span><span class="ql-size-12 ql-author-10256377">需要解决题目的挖矿</span><span class="ql-size-12 ql-author-9863496">改成</span><span class="ql-size-12 ql-author-10256377">不解决</span><span class="ql-size-12 ql-author-9863496">题目。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">3.2 借鉴 Clique （POA) 的实现</em></strong></p>
   <p class="ql-long-9863496">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBL3LW75FH2vGyJEMaJO9derptoVGiaw4w7WE6sbumEqg0Tz9q9TjxQFicw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></p>
   <p class="ql-align-center ql-long-9863496" style="text-align:center;"><strong><span class="ql-author-9863496">图8</span></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;另</span><span class="ql-size-12 ql-author-9863496">一种</span><span class="ql-size-12 ql-author-297664">共识机制是 Clique</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">以太坊</span><span class="ql-size-12 ql-author-10256377">公链使用 </span><span class="ql-size-12 ql-author-297664">POW </span><span class="ql-size-12 ql-author-10256377">机制</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">通过节点</span><span class="ql-size-12 ql-author-297664">数量</span><span class="ql-size-12 ql-author-9863496">来</span><span class="ql-size-12 ql-author-297664">防止别人恶意攻击</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-10256377">同时，</span><span class="ql-size-12 ql-author-297664">以太坊提供一些测试链</span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-297664">但测试链用 POW 发布之后有一个问题，测试链</span><span class="ql-size-12 ql-author-10256377">没有</span><span class="ql-size-12 ql-author-297664">很多人</span><span class="ql-size-12 ql-author-9863496">同时</span><span class="ql-size-12 ql-author-297664">参与</span><span class="ql-size-12 ql-author-10256377">维护</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-9863496">如果有</span><span class="ql-size-12 ql-author-297664">人恶意搞它就非常简单，通过一些机器和算力很容易把</span><span class="ql-size-12 ql-author-9863496">它</span><span class="ql-size-12 ql-author-297664">搞瘫痪掉。为了能够让测试链比较稳定的运行，开发</span><span class="ql-size-12 ql-author-9863496">了</span><span class="ql-size-12 ql-author-297664">另外一种共识机制取代</span><span class="ql-size-12 ql-author-10256377">了 </span><span class="ql-size-12 ql-author-297664">POW，只有授权的机器才可以生产区块</span><span class="ql-size-12 ql-author-9863496">，</span><span class="ql-size-12 ql-author-10256377">这样</span><span class="ql-size-12 ql-author-297664">维护成本非常低，找一些机器授权给他就能够去维持这个网络。整个网络通过授权过的人去出块，</span><span class="ql-size-12 ql-author-10256377">节点之间通过投票的方式来授权或者剔除授权，这些额外的投票机制记录在区块头的 e</span><span class="ql-size-12 ql-author-9863496">xtra data </span><span class="ql-size-12 ql-author-10256377">字段</span><span class="ql-size-12 ql-author-9863496">里面。</span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;图</span><span class="ql-size-12 ql-author-9863496">8右边的图</span><span class="ql-size-12 ql-author-297664">是测试链的产块逻辑</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">假定有 A</span><span class="ql-size-12 ql-author-10256377">、</span><span class="ql-size-12 ql-author-297664">B</span><span class="ql-size-12 ql-author-10256377">、</span><span class="ql-size-12 ql-author-297664">C 三个节点的话，正常逻辑 A&nbsp;</span><span class="ql-size-12 ql-author-10256377">完成之后</span><span class="ql-size-12 ql-author-9863496">到&nbsp;</span><span class="ql-size-12 ql-author-297664">B，B&nbsp;</span><span class="ql-size-12 ql-author-10256377">完成</span><span class="ql-size-12 ql-author-297664">之后</span><span class="ql-size-12 ql-author-9863496">到&nbsp;</span><span class="ql-size-12 ql-author-297664">C</span><span class="ql-size-12 ql-author-9863496">。图中</span><span class="ql-size-12 ql-author-297664">有一个竞争出块</span><span class="ql-size-12 ql-author-10256377">的概念</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-9863496">出 C 的</span><span class="ql-size-12 ql-author-297664">时候不仅仅是 C 产块，A 也可以产块，为什么呢？</span><span class="ql-size-12 ql-author-10256377"> 因为</span><span class="ql-size-12 ql-author-297664">避免 C&nbsp;</span><span class="ql-size-12 ql-author-10256377">节点有问题的时候</span><span class="ql-size-12 ql-author-297664">，不能产块，A 节点</span><span class="ql-size-12 ql-author-10256377">的块也能提供出来</span><span class="ql-size-12 ql-author-297664">加入到链里面</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-10256377">同时，</span><span class="ql-size-12 ql-author-297664">如果 C 在</span><span class="ql-size-12 ql-author-10256377">当前</span><span class="ql-size-12 ql-author-297664">轮次里面，字段有一个 </span><span class="ql-size-12 ql-author-10256377">difficult </span><span class="ql-size-12 ql-author-297664">字段值就是 2，而这个 A 虽然可以产块，但不在这个轮次里面，所以 </span><span class="ql-size-12 ql-author-9863496">difficult </span><span class="ql-size-12 ql-author-297664">就是 1，尽可能保证 C 这个节点</span><span class="ql-size-12 ql-author-10256377">产生的块</span><span class="ql-size-12 ql-author-297664">被大多数的节点所接受，这是以太坊最常见的概念。</span></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLjMLR4jcr2Kleqr8Tel86HqdFLnYX3mr45pTqhU15VtIV900PbJoQfA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-align-center ql-long-9863496" style="text-align:center;"><strong><span class="ql-author-9863496">图9</span></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">图9&nbsp;</span><span class="ql-size-12 ql-author-297664">是轮次问题，</span><span class="ql-size-12 ql-author-9863496">也</span><span class="ql-size-12 ql-author-297664">做了小的改动，这两个节点可以竞争出块</span><span class="ql-size-12 ql-author-9863496">，</span><span class="ql-size-12 ql-author-297664">对于它</span><span class="ql-size-12 ql-author-9863496">，我们</span><span class="ql-size-12 ql-author-297664">希望 C 节点</span><span class="ql-size-12 ql-author-10256377">的块尽量被接受</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">所以</span><span class="ql-size-12 ql-author-297664">对 A 节点来说，如果不是这个轮次里面的话，可以让A节点出块的时间变得稍微延后一些</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-10256377">比如在</span><span class="ql-size-12 ql-author-297664">现在这个</span><span class="ql-size-12 ql-author-10256377">时间点</span><span class="ql-size-12 ql-author-297664">应该可以出块</span><span class="ql-size-12 ql-author-10256377">的</span><span class="ql-size-12 ql-author-297664">，但我</span><span class="ql-size-12 ql-author-9863496">要控制让它</span><span class="ql-size-12 ql-author-297664">晚一些时候出块，这</span><span class="ql-size-12 ql-author-10256377">样</span><span class="ql-size-12 ql-author-297664">就避免</span><span class="ql-size-12 ql-author-10256377">会</span><span class="ql-size-12 ql-author-297664">产生过多的分叉，虽然可以通过 </span><span class="ql-size-12 ql-author-9863496">difficult 值来</span><span class="ql-size-12 ql-author-297664">决定谁是最长链，</span><span class="ql-size-12 ql-author-10256377">但过多的分叉会</span><span class="ql-size-12 ql-author-297664">导致</span><span class="ql-size-12 ql-author-10256377">链的状态越不稳定</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">3.3 扩展区块头结构</em></strong></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.3.1 &nbsp;增加见证人列表</span></p>
   <p class="ql-long-9863496" style="text-align:center;"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBL3L5sn3kEqYwFxPUGc6NiaiaaHxIEA6lNS3qpJ395EB9dvR8u7wTtdn7g/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span><strong><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿</span></span>图10</strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;我们借鉴 Clique 的想法之后，</span><span class="ql-size-12 ql-author-9863496">会</span><span class="ql-size-12 ql-author-297664">想怎么扩展我们的 DPOS 机制。</span><span class="ql-size-12 ql-author-10256377">首先</span><span class="ql-size-12 ql-author-9863496">我们会</span><span class="ql-size-12 ql-author-297664">先修改数据结构，</span><span class="ql-size-12 ql-author-10256377">对</span><span class="ql-size-12 ql-author-297664">区块的 </span><span class="ql-size-12 ql-author-10256377">H</span><span class="ql-size-12 ql-author-9863496">eader </span><span class="ql-size-12 ql-author-297664">的结构，定义新的字段，下面的&nbsp;</span><span class="ql-size-12 ql-author-9863496">WitnessVotes </span><span class="ql-size-12 ql-author-297664">是我们自己定义的字段，我们希望</span><span class="ql-size-12 ql-author-10256377">通过这个字段来为 DPOS 机制提供节点授权</span><span class="ql-size-12 ql-author-297664">，我们扩展这个字段，</span><span class="ql-size-12 ql-author-10256377">把见证人的地址列出，按照字典</span><span class="ql-size-12 ql-author-9863496">做排序，这样能避免出块轮次发生变化的问题。以太坊</span><span class="ql-size-12 ql-author-10256377">对于字段</span><span class="ql-size-12 ql-author-9863496">扩展是非常容易做的，在</span><span class="ql-size-12 ql-author-10256377">代码的框架里体统了框架的主体架构</span><span class="ql-size-12 ql-author-9863496">，我们</span><span class="ql-size-12 ql-author-10256377">只</span><span class="ql-size-12 ql-author-9863496">需要</span><span class="ql-size-12 ql-author-10256377">增</span><span class="ql-size-12 ql-author-9863496">加一</span><span class="ql-size-12 ql-author-10256377">些</span><span class="ql-size-12 ql-author-9863496">代码，就可以</span><span class="ql-size-12 ql-author-10256377">很容易</span><span class="ql-size-12 ql-author-9863496">扩容它的 </span><span class="ql-size-12 ql-author-10256377">Header </span><span class="ql-size-12 ql-author-9863496">了。</span></p>
   <p><br></p>
   <p class="ql-long-9863496" style="text-align:center;"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.3.2 &nbsp;见证人列表生成规则</span>﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBL3mibSsEiaED9h3ib2ciaseTEvqk65UfzZQ7rR1ia7ZcxqiazuvIbGXcG6AVA/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span><strong>﻿<span class="ql-author-297664 ql-size-12">&nbsp;</span><span class="ql-size-12 ql-author-9863496">图11</span></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;图</span><span class="ql-size-12 ql-author-9863496">11是 witness </span><span class="ql-size-12 ql-author-297664">的列表</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">对以太坊来</span><span class="ql-size-12 ql-author-10256377">的验证机制而言，两个区块</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">即便区块</span><span class="ql-size-12 ql-author-297664">数据一样，</span><span class="ql-size-12 ql-author-10256377">但是区块的成产者</span><span class="ql-size-12 ql-author-297664">不一样，也是不被接受的</span><span class="ql-size-12 ql-author-9863496">。为了</span><span class="ql-size-12 ql-author-297664">达到这个目的，我们就需要约定好方案，对于见证人的列表来说，必须依托于</span><span class="ql-size-12 ql-author-10256377">父</span><span class="ql-size-12 ql-author-297664">节点</span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-297664">如果现在区块</span><span class="ql-size-12 ql-author-10256377">链上</span><span class="ql-size-12 ql-author-297664">被确认的</span><span class="ql-size-12 ql-author-10256377">区块</span><span class="ql-size-12 ql-author-297664">高度是 </span><span class="ql-size-12 ql-author-9863496">Block N</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">现在要产生 </span><span class="ql-size-12 ql-author-297664">Block</span><span class="ql-size-12 ql-author-10256377"> N+1 </span><span class="ql-size-12 ql-author-297664">的区块，我们如何填充区块的见证人列表</span><span class="ql-size-12 ql-author-10256377">? </span><span class="ql-size-12 ql-author-297664">我们必须通过 Block</span><span class="ql-size-12 ql-author-9863496"> </span><span class="ql-size-12 ql-author-297664">N 的区块达成共识，当前</span><span class="ql-size-12 ql-author-9863496">的 </span><span class="ql-size-12 ql-author-297664">Block</span><span class="ql-size-12 ql-author-9863496"> </span><span class="ql-size-12 ql-author-297664">N 上面的见证人列表是谁，</span><span class="ql-size-12 ql-author-10256377">就</span><span class="ql-size-12 ql-author-297664">填到下一个见证人列表当中去。对创始块来说，我们通过</span><span class="ql-size-12 ql-author-10256377">创世</span><span class="ql-size-12 ql-author-297664">配置文件，把</span><span class="ql-size-12 ql-author-10256377">见证人列表直接</span><span class="ql-size-12 ql-author-297664">写在</span><span class="ql-size-12 ql-author-10256377">创世块中。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">3.4 &nbsp;轮流生产者的实现</em></strong><em class="ql-author-9863496 ql-size-12"> </em></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.4.1判断当前轮次是否需要产块</span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">当</span><span class="ql-size-12 ql-author-297664">每个节点收到一些条件之后，如何判断自己可以出块？普通的是通过计算题目，</span><span class="ql-size-12 ql-author-9863496">现在</span><span class="ql-size-12 ql-author-297664">是通过一些条件判断，</span><span class="ql-size-12 ql-author-9863496">我们</span><span class="ql-size-12 ql-author-297664">根据</span><span class="ql-size-12 ql-author-9863496">以下</span><span class="ql-size-12 ql-author-297664">几个条件值</span><span class="ql-size-12 ql-author-10256377">: </span><span class="ql-size-12 ql-author-297664">当前的时间戳、当前区块的产块人，</span><span class="ql-size-12 ql-author-9863496">Parent 区块的</span><span class="ql-size-12 ql-author-10256377">见证人列表，Parent 区块的产块人</span><span class="ql-size-12 ql-author-9863496">，Parent 区块</span><span class="ql-size-12 ql-author-297664">的时间戳</span><span class="ql-size-12 ql-author-9863496">，产块周期来</span><span class="ql-size-12 ql-author-297664">共同计算出来当前矿工到底有没有资格出块。如果现在没有资格，那不应该出块</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.4.2 &nbsp;轮流生产者的实现—分析</span></p>
   <ul class="ql-long-9863496 list-paddingleft-2">
    <li><p><strong><span class="ql-author-9863496 ql-size-12">场景分析</span></strong></p></li>
   </ul>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLXQXYLjmkX9x0uXuMc1Roe15R6xXD2BplpqsicA7JJvnGHqk48ibRzFew/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">图中</span><span class="ql-size-12 ql-author-297664">，如果我们有 A</span><span class="ql-size-12 ql-author-10256377">、</span><span class="ql-size-12 ql-author-297664">B</span><span class="ql-size-12 ql-author-10256377">、</span><span class="ql-size-12 ql-author-297664">C 三个节点，</span><span class="ql-size-12 ql-author-10256377">这是</span><span class="ql-size-12 ql-author-297664">他们的 </span><span class="ql-size-12 ql-author-9863496">parent </span><span class="ql-size-12 ql-author-297664">节点</span><span class="ql-size-12 ql-author-10256377">的</span><span class="ql-size-12 ql-author-297664">数据结构，</span><span class="ql-size-12 ql-author-9863496">parent </span><span class="ql-size-12 ql-author-297664">见证人的列表是 ABC，时间戳是 T，产块周期是 3 秒钟，当前的时间点是&nbsp;</span><span class="ql-size-12 ql-author-10256377">T</span><span class="ql-size-12 ql-author-297664">+3，这三个</span><span class="ql-size-12 ql-author-10256377">节点</span><span class="ql-size-12 ql-author-297664">点各自判断有没有资格出块。</span><span class="ql-size-12 ql-author-9863496">根据图，我们发现</span><span class="ql-size-12 ql-author-297664">见证人列表永远都是 ABC，</span><span class="ql-size-12 ql-author-10256377">父节点产块人是&nbsp;</span><span class="ql-size-12 ql-author-297664">A，下一个要 B 产块，B&nbsp;</span><span class="ql-size-12 ql-author-10256377">在&nbsp;</span><span class="ql-size-12 ql-author-297664">T+3&nbsp;</span><span class="ql-size-12 ql-author-10256377">时间</span><span class="ql-size-12 ql-author-297664">可以产块，A 和 C 在 T+3 的时间节点是不能产块的。A 可能要等到 T+9 的时间点</span><span class="ql-size-12 ql-author-9863496">产块</span><span class="ql-size-12 ql-author-297664">，C 是 T+</span><span class="ql-size-12 ql-author-10256377">6&nbsp;</span><span class="ql-size-12 ql-author-297664">的时间点可以产块。这样才能保证整个网络持续的往下运行。</span></p>
   <ul class="ql-long-9863496 list-paddingleft-2">
    <li><p><strong><span class="ql-author-9863496 ql-size-12">判断当前轮次—代码实现</span></strong></p></li>
   </ul>
   <p class="ql-long-9863496" style="text-align:center;"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLoTY9Zia2ic9vibxgNF1m5QOtJoicmbsWG0OJBpMOWgqIbj3o3bneJIsbew/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;逻辑通过代码</span><span class="ql-size-12 ql-author-10256377">实现</span><span class="ql-size-12 ql-author-297664">，我们根据条件来</span><span class="ql-size-12 ql-author-10256377">计算</span><span class="ql-size-12 ql-author-297664">一个值，</span><span class="ql-size-12 ql-author-10256377">计算出轮次查，</span><span class="ql-size-12 ql-author-9863496"> 我们</span><span class="ql-size-12 ql-author-297664">可以根据时间戳和产块节点和当地时间戳判断是不是可以出块</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <ul class="ql-long-9863496 list-paddingleft-2">
    <li><p><strong><span class="ql-author-9863496 ql-size-12">注册下一次调用</span></strong></p></li>
   </ul>
   <ul class="ql-long-9863496 list-paddingleft-2">
    <li><p><strong><span class="ql-author-9863496 ql-size-12">原因</span></strong></p></li>
   </ul>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBL70QCz3bNhyuPOBH518kcr6zLuSmO2ZbMCIazSYJJCib9uwVtr8kGAWw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">还有</span><span class="ql-size-12 ql-author-297664">一个问题是产块没到自己的轮次或现在不应该产块，所以不会产生结果对象，也就不会触发提交新的 worker，也没有其他的时间节点触发这个 channel，这个时候</span><span class="ql-size-12 ql-author-9863496">我收不到任何消息</span><span class="ql-size-12 ql-author-297664">，什么都不能干，这个</span><span class="ql-size-12 ql-author-9863496">是 </span><span class="ql-size-12 ql-author-297664">Clique 测试网络存在的问题</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">我们不希望这种情况发生，希望网络永远是向前推进，即便是网络出现故障或者异常，只要保证后面的节点 OK 还是</span><span class="ql-size-12 ql-author-10256377">可以</span><span class="ql-size-12 ql-author-297664">往前走的。</span><span class="ql-size-12 ql-author-10256377">解决这个问</span><span class="ql-size-12 ql-author-297664">题就需要做一些改变，我们把 </span><span class="ql-size-12 ql-author-9863496">worker </span><span class="ql-size-12 ql-author-297664">产生的通知机制去掉</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">每次产生 </span><span class="ql-size-12 ql-author-9863496">seal </span><span class="ql-size-12 ql-author-297664">的方法不是通过这两个地方通知他，而是通过 S</span><span class="ql-size-12 ql-author-9863496">e</span><span class="ql-size-12 ql-author-297664">al 本身判断自己，S</span><span class="ql-size-12 ql-author-9863496">e</span><span class="ql-size-12 ql-author-297664">al 判断完之后注册下一个 S</span><span class="ql-size-12 ql-author-9863496">e</span><span class="ql-size-12 ql-author-297664">al，这样永远保证它可以判断</span><span class="ql-size-12 ql-author-9863496">它</span><span class="ql-size-12 ql-author-297664">自己。</span></p>
   <p><br></p>
   <ul class="ql-long-9863496 list-paddingleft-2">
    <li><p><strong><span class="ql-author-9863496 ql-size-12">场景分析</span></strong></p></li>
   </ul>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLnoYEWkib5j0GOaEQGiamGthMgu1JVWYaMWSCpo3bzjfjgI3ttL8Euytw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">根据上述内容，自己</span><span class="ql-size-12 ql-author-297664">判断自己的话，需要给自己注册一个动作的定时器</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">还是以刚刚的场景分析，对于 A 节点来说，这个时间节点&nbsp;</span><span class="ql-size-12 ql-author-9863496">A&nbsp;</span><span class="ql-size-12 ql-author-297664">不能出块，因为没有符合条件，他给自己定时器是什么时间点呢？一种方案是我在 T+9&nbsp;</span><span class="ql-size-12 ql-author-9863496">时</span><span class="ql-size-12 ql-author-297664">去出块，我就等 9 秒钟或 6 秒钟判断我自己是不是有出块的资格。</span><span class="ql-size-12 ql-author-10256377">在实际测试</span><span class="ql-size-12 ql-author-297664">中这种</span><span class="ql-size-12 ql-author-10256377">方案的</span><span class="ql-size-12 ql-author-297664">效果并不是特别好</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">有两个原因</span><span class="ql-size-12 ql-author-9863496">；</span></p>
   <p class="ql-long-297664"><span class="ql-author-9863496 ql-size-12"> &nbsp;</span><span class="ql-size-12 ql-author-297664">第一个是见证人的列表会发生变化，如果这个列表发生变化之后，下一次被唤醒的时候，出块的轮次也发生变化，这个时候就</span><span class="ql-size-12 ql-author-10256377">有可能</span><span class="ql-size-12 ql-author-297664">错过了出块的机会，会导致整个网络</span><span class="ql-size-12 ql-author-10256377">的产块</span><span class="ql-size-12 ql-author-297664">周期变的更加不稳定</span><span class="ql-size-12 ql-author-10256377">。</span><span class="ql-size-12 ql-author-297664">&nbsp;第二，我的迭代时间比较长，降低自己出块的频次，一旦整个网络发生不稳定的情况下，会处于 </span><span class="ql-size-12 ql-author-9863496">side fork </span><span class="ql-size-12 ql-author-297664">的情况</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">整个网络每个节点都在出块，但是没有被其他的节点接受，我们希望尽可能的在短时间之内同步，也不能过分的小，过分的小会使产块的性能</span><span class="ql-size-12 ql-author-10256377">有</span><span class="ql-size-12 ql-author-297664">问题。我们</span><span class="ql-size-12 ql-author-10256377">定义</span><span class="ql-size-12 ql-author-297664">两个时段，一个是 3 秒钟，第二是定义一个最小值，其实在出块的时候，在节点出块之前会做打包、</span><span class="ql-size-12 ql-author-10256377">验证</span><span class="ql-size-12 ql-author-297664">的工作</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">我们扣除时间消耗，打包时间过长，最小的值就会有用，可以帮助快速的出块。这种情况下，前面因为某种原因</span><span class="ql-size-12 ql-author-9863496">导致</span><span class="ql-size-12 ql-author-297664">你的产块速度慢，或你有可能这个时间点应该出块，但压根没有出块，这个时候</span><span class="ql-size-12 ql-author-10256377">就</span><span class="ql-size-12 ql-author-297664">小于 0 了，这个时候马上让他出块。</span></p>
   <p><br></p>
   <ul class="ql-long-9863496 list-paddingleft-2">
    <li><p><strong><span class="ql-author-9863496 ql-size-12">代码实现</span></strong></p></li>
   </ul>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLKb33uaSX9Cahq2Ojy7RqHIwONQrNErPMm88Zibot7MqKbMnqsibAOKsw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">在</span><span class="ql-size-12 ql-author-297664">每个 S</span><span class="ql-size-12 ql-author-9863496">e</span><span class="ql-size-12 ql-author-297664">al 方案里面会注册一个方法，使</span><span class="ql-size-12 ql-author-10256377">其</span><span class="ql-size-12 ql-author-297664">在下次被调用，这个方法</span><span class="ql-size-12 ql-author-9863496">叫registernext</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">3.4.3 &nbsp; 自定义奖励规则</span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;我们对奖励也做了变化</span><span class="ql-size-12 ql-author-10256377">, </span><span class="ql-size-12 ql-author-297664">对我们应用场景来说会改变奖励的分配规则，</span><span class="ql-size-12 ql-author-9863496">使</span><span class="ql-size-12 ql-author-297664">我们适应不同的业务场景</span><span class="ql-size-12 ql-author-9863496">。</span>﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLMjrtico51frALicYQqs9MWG5N0HcyouYRjic6LludqRrTvzBXOmcta2GQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿<span class="ql-author-297664 ql-size-12">&nbsp; &nbsp;首先在创世块当中确认奖励规则，这是一个 </span><span class="ql-size-12 ql-author-9863496">default-reward </span><span class="ql-size-12 ql-author-297664">的规则，这个规则可以在节点挖矿完之后按照这个规则去</span><span class="ql-size-12 ql-author-9863496">发放奖励</span><span class="ql-size-12 ql-author-297664">，具体怎么</span><span class="ql-size-12 ql-author-9863496">做呢：</span><span class="ql-size-12 ql-author-297664">就定一个接口，定义一个方法，</span><span class="ql-size-12 ql-author-9863496">比如</span><span class="ql-size-12 ql-author-10256377">我希望出块人可以获得</span><span class="ql-size-12 ql-author-297664">五个币</span><span class="ql-size-12 ql-author-10256377">的奖励</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">在</span><span class="ql-size-12 ql-author-297664">每次出完块之后，其他节点验证完之后，最后在这个数据结构里面，把账号里面的钱就增加5个币，这是最简单的实践。我们把代码抽出来之后扩展自己奖励分配的规则，根据时间出块，或者不给他奖励，或者通过其他方式奖励，或者把建立放在一个池里面</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong class="ql-author-9863496 ql-size-12" style="color:rgb(77,168,238);">4.智能合约的支点实践 </strong></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">4.1 &nbsp;合约语言 Solidity</em></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-9863496">接下来</span><span class="ql-size-12 ql-author-297664">讲一下我们在智能合约里面的实现。我们说的 DPOS 的机制，很大程度上是要跟智能合约所绑定在一起的，我们的投票人如何投票，我们的理事会成员如何选举见证人都是通过 DPOS 去做，这个可以和共识做一个相关联。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">4.2 &nbsp;实现投票合约</em></strong><em class="ql-author-9863496 ql-size-12"> </em></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">4.2.1 &nbsp;理事会</span></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLz8Y3FypibfIabYZhSZjictsogm2oiaJOPqpPxY7FKV0ncMdR0NXoZskNw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span><span class="ql-author-297664 ql-size-12">&nbsp; &nbsp;我们对于理事会的投票思路就是普通用户，通过自己持有的</span><span class="ql-size-12 ql-author-9863496">投票权</span><span class="ql-size-12 ql-author-297664">，质押</span><span class="ql-size-12 ql-author-9863496">投票权</span><span class="ql-size-12 ql-author-297664">可以选举理事会的成员，会通过 </span><span class="ql-size-12 ql-author-9863496">Top N </span><span class="ql-size-12 ql-author-297664">的计算，自动去发生变化，现在一些 DPOS 的机制是有换届的概念，每天换一届，我们这边是自动的，这个时间点你只要票数够高，马上就成为理事会的成员。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496 ql-size-12" style="color:rgb(173,114,14);">4.2.2 &nbsp;见证人</span></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLNARfrtKufXA5MO293wYiaF5o5QxUibAsxqOwoS59XEciazcmDE0YCb4QQ/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span>&nbsp; &nbsp;见证人是通过理事会任命的，一个理事会成员有资格去发起一个提案，这个提案可能包含提名或者是移除一个见证人，他发起提案之后，其他理事会成员可以选择通过还是不通过，这个提案有一定时效期，超过这个时间窗口也是自动作废的，一旦超过半数就通过，如果半数以上否认掉那就是作废了。</p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">4.3 &nbsp;智能合约设计模式 &nbsp;</em></strong></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;对于智能合约有很多资料，你可以通过业务的智能合约代码和控制器拆开，我们的业务是会变化的</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">对于智能合约来说，一旦进入到这个区块链是不能改的，这时你必须要写一个新的合约替代它，但是对外暴露的接口只有一个，可以把控制器和业务层分开，你只需要把控制器变更下面业务合约的地址就行。此外还有一种思路，我们可能会在智能合约里面存一些数据比如说存证数据，但是一旦新的业务实现之后，这个数据不通用，这两个智能合约虽然类似，但是数据是不通用的，我们把数据单独的划分出来，数据也是一个合约，不需要设计的过分的复杂，可以同时被上面的业务层所通用</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">4.4 &nbsp;智能合约并不智能，反而有太多坑</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLmgSPHUQSXBdUyB22g8um9X5Iiatzj2DlDQ47Pc5UxZubktbaDd9fs9A/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span></span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;</span><span class="ql-size-12 ql-author-9863496"> &nbsp;</span><span class="ql-size-12 ql-author-297664">智能合约本身有很多的限制，对于参数的数量限制，对于返回值的定长设置，包括智能合约的大小都不能定得特别大，所以说智能合约从现在的角度来说，还是需要一段时间优化</span><span class="ql-size-12 ql-author-9863496">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">4.5 &nbsp;智能合约设计模式，使用单一合约</em></strong></p>
   <p class="ql-long-297664"><span class="ql-author-9863496 ql-size-12"> &nbsp; </span><span class="ql-size-12 ql-author-297664">因为它本身也有一些问题在，所以理想的设计模式，有控制器层和数据存储层，我们都不要了，一开始是只有一个合约，或者只有一类合约来做所有的工作</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-297664">后来发现一旦</span><span class="ql-size-12 ql-author-9863496">拆下来</span><span class="ql-size-12 ql-author-297664">这些层之后，很多功能就不能这么做了，我们开发智能合约的思路就是跟我们写代码的思路是一样的，定义返回值，定义变向量，就做不了，最后通过单一合约去做这些事情。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong class="ql-author-9863496 ql-size-12" style="color:rgb(77,168,238);">5. 压力测试下暴露的问题 </strong></p>
   <p class="ql-long-9863496"><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">5.1 &nbsp; &nbsp;以太坊公链并不会有压力测试的场景，需要大量的优化和测试</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none"><span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLocnX7x1HfClYpns3TGAXVCzK1TwlYKUIQBicAibO1bzJMW6QjcLo68zw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">5.2 &nbsp;流量控制 / 重发机制 &nbsp;</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLFhvmwkmtsexG5cs1EokLIcISs2biaJ4aDP8KtCbZOyKy3ENcCDjmHzw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span><span class="ql-author-297664 ql-size-12">&nbsp; &nbsp;最简单的一点是通过一些流量控制和重发机制，我们对外业务调用的时候，不是</span><span class="ql-size-12 ql-author-10256377">直接连接到见证</span><span class="ql-size-12 ql-author-297664">节点，而是网关节点，代码都是一样的，在里面会对所有的请求做一个</span><span class="ql-size-12 ql-author-10256377">限制</span><span class="ql-size-12 ql-author-9863496">。</span><span class="ql-size-12 ql-author-10256377">达到一定</span><span class="ql-size-12 ql-author-297664">的程度之后就</span><span class="ql-size-12 ql-author-10256377">会</span><span class="ql-size-12 ql-author-297664">拒绝请求</span><span class="ql-size-12 ql-author-10256377">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">5.2.1 &nbsp; 对交易请求进行检查，是否到达上限</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLZmnscVYwRCKUwbEJOImxO045X5R7Jia7m4U7QRZAZLtP22lYwBNiaMJw/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;</span><span class="ql-size-12 ql-author-10256377">实际的</span><span class="ql-size-12 ql-author-297664">代码实现</span><span class="ql-size-12 ql-author-9863496">中</span><span class="ql-size-12 ql-author-297664">，控制一下调用的</span><span class="ql-size-12 ql-author-10256377">接口</span><span class="ql-size-12 ql-author-297664">，</span><span class="ql-size-12 ql-author-10256377">我们不想</span><span class="ql-size-12 ql-author-297664">对&nbsp;</span><span class="ql-size-12 ql-author-9863496">p2p&nbsp;</span><span class="ql-size-12 ql-author-10256377">网络</span><span class="ql-size-12 ql-author-297664">造成影响</span><span class="ql-size-12 ql-author-10256377">。</span></p>
   <p><br></p>
   <p class="ql-long-9863496"><strong><em class="ql-author-9863496 ql-size-12">5.2.2 &nbsp; &nbsp;重发机制，防止p2p网络交易广播失败</em></strong></p>
   <p class="ql-long-9863496"><span class="ql-author-9863496"><span class="ql-blot-gallery-embed ql-blot-gallery ql-gallery-margin-none ql-gallery-frame-none">﻿<span style="margin-left:2px;"><span class="ql-gallery-editableimage"><span class="img-wrapper" style="width:inherit;"><img class="gallery-image img_loading" style="width:648px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/5WXEuGYZIibDQOPkMql7zXKmYh51S3CBLe7rQ85iaZ44O9aAs8oIK7UULKAibAuTlSM7Picokwhib7biayAU9konDB4A/640?wx_fmt=png" alt="640?wx_fmt=png"></span></span></span>﻿</span></span></p>
   <p class="ql-long-297664"><span class="ql-author-297664 ql-size-12">&nbsp;&nbsp;&nbsp;这个在节点</span><span class="ql-size-12 ql-author-10256377">规模</span><span class="ql-size-12 ql-author-297664">很大的情况下不大容易出现问题，但是在范围较小的情况下就会出现，</span><span class="ql-size-12 ql-author-10256377">我们在</span><span class="ql-size-12 ql-author-297664">程序</span><span class="ql-size-12 ql-author-10256377">中的&nbsp;</span><span class="ql-size-12 ql-author-9863496">pending</span><span class="ql-size-12 ql-author-10256377"> list&nbsp;</span><span class="ql-size-12 ql-author-297664">里</span><span class="ql-size-12 ql-author-10256377">增加了重发的机制</span><span class="ql-size-12 ql-author-297664">。</span></p>
   <span class="ql-size-12 ql-author-297664" style="color:rgb(0,0,0);"></span>
   <p>&nbsp;<br></p>
   <hr>
   <p class="ql-indent-2 ql-long-297664" style="line-height:2;"><span style="color:rgb(32,32,32);font-size:14px;">2018年的 Gopher Meetup 将在深圳开启巡回第一站，这一次邀请了很多新的讲师给大家一起交流分享Go的使用经验〜</span><br><span style="font-size:14px;"></span></p>
   <p><span style="font-size:14px;color:rgb(32,32,32);">点击</span><span style="font-size:14px;color:rgb(0,128,255);"><strong>阅读原文</strong></span><span style="font-size:14px;color:rgb(32,32,32);">报名参加</span></p>
  </div> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/80268193,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/80268193,&quot;}">阅读更多</a> 
</div>
      <br />
        <a href="https://blog.uzzz.org/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://blog.uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://blog.uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>

  </body>
</html>
