<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <div class="blog-content-box"> 
   <div class="article-header-box"> 
    <div class="article-header"> 
     <div class="article-title-box"> 
     </div>
    </div>
   </div>
  </div> 
  <br> 关于Alias Method的介绍的比较好的是一个外国Blog：
  <a href="http://www.keithschwarz.com/darts-dice-coins/" rel="nofollow" target="_blank">Darts, Dice, and Coins: Sampling from a Discrete Distribution</a>，以下的介绍也主要参考这篇Blog里的算法。 
  <p>问题：比如一个随机事件包含四种情况，每种情况发生的概率分别为： <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0"><span class="math" id="MathJax-Span-1"><span><span><span class="mrow" id="MathJax-Span-2"><span class="mfrac" id="MathJax-Span-3"><span><span><span class="mn" id="MathJax-Span-4">1</span><span></span></span><span><span class="mn" id="MathJax-Span-5">2</span><span></span></span><span><span></span><span></span></span></span></span><span class="mo" id="MathJax-Span-6">,</span><span class="mfrac" id="MathJax-Span-7"><span><span><span class="mn" id="MathJax-Span-8">1</span><span></span></span><span><span class="mn" id="MathJax-Span-9">3</span><span></span></span><span><span></span><span></span></span></span></span><span class="mo" id="MathJax-Span-10">,</span><span class="mfrac" id="MathJax-Span-11"><span><span><span class="mn" id="MathJax-Span-12">1</span><span></span></span><span><span class="mn" id="MathJax-Span-13">12</span><span></span></span><span><span></span><span></span></span></span></span><span class="mo" id="MathJax-Span-14">,</span><span class="mfrac" id="MathJax-Span-15"><span><span><span class="mn" id="MathJax-Span-16">1</span><span></span></span><span><span class="mn" id="MathJax-Span-17">12</span><span></span></span><span><span></span><span></span></span></span></span></span><span></span></span></span><span></span></span><span class="MJX_Assistive_MathML">12,13,112,112</span></span>，问怎么用产生符合这个概率的采样方法。</p> 
  <h1 id="最容易想到的方法"><a></a>最容易想到的方法</h1> 
  <p>我之前有在<a href="http://blog.csdn.net/haolexiao/article/details/60511164" rel="nofollow" target="_blank">【数学】均匀分布生成其他分布的方法</a>中写过均匀分布生成其他分布的方法，这种方法就是产生0-1之间的一个随机数，然后看起对应到这个分布的CDF中的哪一个，就是产生的一个采样。<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0"><span class="math" id="MathJax-Span-18"><span><span><span class="mrow" id="MathJax-Span-19"><span class="mfrac" id="MathJax-Span-20"><span><span><span class="mn" id="MathJax-Span-21"></span><span></span></span><span><span class="mn" id="MathJax-Span-22"></span><span></span></span><span><span></span><span></span></span></span></span></span><span></span></span></span><span></span></span><span class="MJX_Assistive_MathML"></span></span></p>
  <h1 id="一个naive的办法"><a></a>一个Naive的办法</h1> 
  <p>一个Naive的想法如下： <br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdn.net/20170323010605986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFvbGV4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 1. 可以像上图这样采样，将四个事件排成4列：1~4，扔两次骰子，第一次扔1~4之间的整数，决定落在哪一列。 <br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdn.net/20170323010616461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFvbGV4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 2. 如上如所示，<strong>将其按照最大的那个概率进行归一化</strong>。在1步中决定好哪一列了之后，扔第二次骰子，0~1之间的任意数，如果落在了第一列上，不论第二次扔几，都采样时间A，如果落在第二列上，第二次扔超过<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0"><span class="math" id="MathJax-Span-57"><span><span><span class="mrow" id="MathJax-Span-58"><span class="mfrac" id="MathJax-Span-59"><span><span><span class="mn" id="MathJax-Span-60">2</span><span></span></span><span><span class="mn" id="MathJax-Span-61">3</span><span></span></span><span><span></span><span></span></span></span></span></span><span></span></span></span><span></span></span><span class="MJX_Assistive_MathML">23</span></span></p> 
  <p>那怎么去改进呢？</p> 
  <h1 id="alias-method"><a></a>Alias Method</h1> 
  <p>这样Alias Method采样方法就横空出世了 <br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdn.net/20170323011208949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFvbGV4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br> 还是如上面的那样的思路，但是如果我们不按照其中最大的值去归一化，而是按照其均值归一化。即按照<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-13-Frame" tabindex="0"><span class="math" id="MathJax-Span-79"><span><span><span class="mrow" id="MathJax-Span-80"><span class="mfrac" id="MathJax-Span-81"><span><span><span class="mn" id="MathJax-Span-82">1</span><span></span></span><span><span class="mi" id="MathJax-Span-83">N<span></span></span><span></span></span><span><span></span><span></span></span></span></span></span><span></span></span></span><span></span></span><span class="MJX_Assistive_MathML">1N</span></span>的另外一个事件的标号，像上图就是Alias[2 NULL 1 1] <br> 2.产生两个随机数，第一个产生1~N 之间的整数i，决定落在哪一列。扔第二次骰子，0~1之间的任意数，判断其与Prab[i]大小，如果小于Prab[i]，则采样i，如果大于Prab[i]，则采样Alias[i]</p> 
  <p>这个算法是不是非常的精妙而且简洁，做到了<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-22-Frame" tabindex="0"><span class="math" id="MathJax-Span-114"><span><span><span class="mrow" id="MathJax-Span-115"><span class="mi" id="MathJax-Span-116">O</span><span class="mo" id="MathJax-Span-117">(</span><span class="mn" id="MathJax-Span-118">1</span><span class="mo" id="MathJax-Span-119">)</span></span><span></span></span></span><span></span></span><span class="MJX_Assistive_MathML">O(1)</span></span>事件复杂度的采样。但是还有一个问题是，如何去构建上面的第1步？即如何去拉平整个概率分布？这样预处理的时间复杂度又是多少呢？</p> 
  <h1 id="alias-method程序化构建"><a></a>Alias Method程序化构建</h1> 
  <h2 id="naive方法"><a></a>Naive方法</h2> 
  <p>构建方法： <br> 1.找出其中面积小于等于1的列，如i列，这些列说明其一定要被别的事件矩形填上，所以在Prab[i]中填上其面积 <br> 2.然后从面积大于1的列中，选出一个，比如j列，用它将第i列填满，然后Alias[i] = j，第j列面积减去填充用掉的面积。</p> 
  <p>以上两个步骤一直循环，直到所有列的面积都为1了为止。</p> 
  <h2 id="存在性证明"><a></a>存在性证明</h2> 
  <p>那么Alias Table一定存在吗，如何去证明呢？ <br> 要证明Alias Table一定存在，就说明上述的算法是能够一直运行下去，直到所有列的面积都为1了为止，而不是会中间卡住。 <br> 一个直觉就是，这一定是可以一直运行下去的。上述方法每运行一轮，就会使得剩下的没有匹配的总面积减去1，在第n轮，剩下的面积为N-n，如果存在有小于1的面积，则一定存在大于1的面积，则一定可以用大于1的面积那部分把小于1部分给填充到1，这样就进入到了第n+1轮，最后一直到所有列面积都为1。 <br> 更为严谨的证明见上面给出的那个Blog。</p> 
  <h2 id="更快的构建方法"><a></a>更快的构建方法</h2> 
  <p>如果按照上面的方法去构建Alias Table，算法复杂度是<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-23-Frame" tabindex="0"><span class="math" id="MathJax-Span-120"><span><span><span class="mrow" id="MathJax-Span-121"><span class="mi" id="MathJax-Span-122">O</span><span class="mo" id="MathJax-Span-123">(</span><span class="msubsup" id="MathJax-Span-124"><span><span><span class="mi" id="MathJax-Span-125">n</span><span></span></span><span><span class="mn" id="MathJax-Span-126">2</span><span></span></span></span></span><span class="mo" id="MathJax-Span-127">)</span></span><span></span></span></span><span></span></span><span class="MJX_Assistive_MathML">O(n2)</span></span></p> 
  <p>至此Alias Method就讲完了，感觉还是一个非常精妙的方法，而且方法实现起来也非常的简单。值得学习。</p> [转载自此篇博客](https://blog.csdn.net/haolexiao/article/details/65157026) 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>