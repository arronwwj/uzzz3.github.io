<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views">
   # 1.参考文献
  <br>
  <br>
  <br>https://forums.eosgo.io/profile/discussions/1039/IMEOS
  <br>
  <br>
  <br>看完这个系列，讲一遍给吉祥物听。
  <br>
  <br>
  <br># 2.技术节点
  <br>
  <br>
  <br>## 2.1 区块链外部进化史
  <br>
  <br>
  <br>人类社会中，货币的形态经历了实物货币——贵金属货币——信用货币的演变过程，而信用货币里便包含了数字货币
  <br>
  <br>
  <br>区块链的三个代表性项目：比特币、以太坊和EOS
  <br>
  <br>
  <br>比特币采用POW解决了拜占庭将军问题，并且保证了节点的忠诚执行。
  <br>
  <br>
  <br>以太坊：智能合约来搭建一个DAPP，即去中心化应用平台。
  <br>
  <br>
  <br>EOS：委托权益证明DPOS，免费使用。
  <br>
  <br>
  <br>## 2.2 EOS内部进化史
  <br>
  <br>
  <br>区块链生态系统主要分为三类，一类是比特币生态系，一类是以太坊生态系，而另外一种就是石墨烯生态系，而石墨烯生态系下有三个代表项目：BTS，Steem 和 EOS。
  <br>
  <br>
  <br>2015年, 为解决系统性能问题，BM团队发布了石墨烯工具组，在此基础上建立的Bitshare2.0是第一个间隔时间只有3秒的区块链，每秒支持1万笔交易，也证明了在分布式环境下的高性能。
  <br>
  <br>
  <br>Steem结合了社交媒体概念，以及加密货币及其社区建设过程中的经验教训。Steem沿用了比特股的底层技术：石墨烯区块链底层，简单来说就是利用内容激励内容生产，作者可以根据点赞和转发量来获得代币奖励，“股东评价、系统奖励”的模式。
  <br>
  <br>
  <br>2017年，BM离开了Steemit, 作为一个社交媒体应用，Steemit上的功能聚焦得非常狭窄，几乎只能用来做社交。Bitshare和Steemit都是基于区块链的应用，如果想向区块链添加新功能时，必须让所有参与方都达成共识，同时必须做大规模的升级，其间无尽的争议会极其地耗时。
  <br>
  <br>
  <br>BM理想中的新系统应该有更好的治理架构以及权责利安排。为此，他研究了博弈论，学了人们在类似投票的博弈过程中的各种纠结心理，最后发现这一系列东西都应该被重塑，可现在每个人都已经参与进这个系统，于是BM注定无法重塑它。
  <br>
  <br>
  <br>一个成熟的区块链公共应用平台至少需要满足以下条件：
  <br>
  <br>
  <br>1. 在低延迟的基础上支持大规模用户
  <br>2. 提供免费服务
  <br>
  <br>
  <br>3. 便利地升级与 Bug 恢复
  <br>
  <br>
  <br>EOS.IO 软件引入一种新的区块链架构设计，它使得去中心化的应用可以横向和纵向的扩展。这通过构建一个仿操作系统的方式来实现，在它之上可以构建应用程序。该软件提供帐户、身份验证、数据库、异步通信和跨越数百个 CPU 内核或集群的应用程序调度。由此产生的技术是一种区块链架构，它可以扩展至每秒处理百万级交易且用户可免费使用。
  <br>
  <br>
  <br>## 2.3 IMEOS解读EOS白皮书v2
  <br>
  <br>
  <br>相比较第一版EOS白皮书1.0的雄心壮志来说，EOS白皮书2.0就尽显中庸之道了，将1.0版本中立的flag：EOS.IO的区块链架构设计，可以达到数百万TPS。在2.0版本中改成了可能最终扩展到数百万TPS，目前EOS的主网还没有正式落地，一切都还只是在验证阶段。
  <br>
  <br>
  <br>目前阶段，EOS还远远没有达到其号称的万级TPS的地步，目前仅是1000TPS的水平，对于儿童节主网上线BM能不能兑现百万TPS的承诺，很多人表示怀疑。
  <br>
  <br>
  <br>但EOS合伙人Ian Grigg表示未来还有很多地方可以扩展如：单线程性能、多线程共享内存、多进程非共享内存，以及跨链交互等
  <br>
  <br>
  <br>## 2.4 EOS白皮书2.0之DPOS机制详细解读
  <br>
  <br>
  <br>基于这个算法，持有token的人可以通过持续的审批投票系统来选择出块者。
  <br>
  <br>
  <br>只要能获得token持有者的投票，任何人都可以参与区块的生产过程，也有机会独立的生产区块。
  <br>
  <br>
  <br>EOS.IO软件允许区块精准的以每0.5秒产生一个区块，只有一个生产者被授权在任何给定的时间点生产一个区块。如果区块在预定的时间没有被生产出来，那么，那个时间的区块将被跳过。当一个或多个区块被跳过，将会有0.5秒或更多秒的区块间隔。
  <br>
  <br>
  <br>使用EOS.IO软件，区块以126个区块为一轮（每个生产者可以生产6个，有21个生产者，二者相乘）。在每一轮的开始，21个区块生产者通过token持有者的投票被选中。选中的生产者依据商定好的顺序生产区块，这个顺序由15个或者更多的生产者商定。
  <br>
  <br>
  <br>如果一个生产者错过了一个区块，并且在24小时内没有生产任何区块，他们将会被移除。直到这些“宕机”的生产者们及时通知区块链，他们将打算再次生产区块才被重新加入。通过不安排那些不够可靠的节点，尽可能的减少错过区块创建，来让整个网络运行得更平稳。
  <br>
  <br>
  <br>在常规的情况下，DPOS区块链不太可能会产生分叉，因为区块的生产过程是一个合作的过程而不是一个相互竞争的过程。如果产生的分叉，共识将会自动转向最长的链。这一机制有效是因为一个区块被加入到区块链的速率与区块生产者的数量直接相关，而这些生产者都对这个最长链条达成共识。换句话说，一个分叉的区块链，如果有更多的生产者，长度将会比更少的生产者更快，因为更多生产者的那条链上错过创建的区块数要少很多。
  <br>
  <br>
  <br>传统DPOS中加入了拜占庭容错算法（BFT），只要没有生产者盖上相同的时间戳或相同区块高度的两个区块，便允许所有生产者签署所有区块。一旦15个生产者签署了一个区块，该区块就被认为是不可逆转的。任何拜占庭生产者会留下他们背叛的证据，因为他们用相同的时间戳或区块高度来签署两个区块。在这种模式下，不可逆转的共识应该在1秒内完成。
  <br>
  <br>
  <br>区块生产者（Block Producers）--简称BP，区块生产者(我们也可以把他们称为EOS矿工)会给每个需要的人提供存储服务。区块生产者代表了21个独特的独立的个人或组织，每个人或组织都能在全球的不同地区复制和托管数据。这些区块生产者可能已经位于数据中心了，它们能支持高吞吐量的EOS.IO 交易量。只要21个区块生产者中有一个在线，正常运作，提供文档访问服务，那么，每个人就能访问文件。即现在火热的21个超级节点。EOS生态系统中DAPP的运转都依赖这些这些节点。
  <br>
  <br>
  <br>运行EOS的节点需要一定的硬件性能才能维持网络的效率和安全。目前EOS公布的一个单台机器的费用，从AWS上可查到。单台以上配置的机器每小时 13.338美金，算下来，一小时86.697人民币，一年76万人民币。以上价格还没加带宽，据经验人士估算单台以上配置机器投入不会少于100万人民币。
  <br>
  <br>
  <br>生产区块（Produce Block）----与以太坊和比特币这些使用pow的系统不同，EOS使用dpos作为安全/挖矿机制来生产区块。这就意味着不需要购买专门的哈希硬件去与其他的矿工竞争。在EOS上，app创造者只需要选择他们的矿工，然后就会根据规则规定哪个矿工生产哪个区块。区块高度（Block Height）----与时间戳一样是EOS生产区块数据结构的一部分，表示当前区块是第几个区块。﻿
  <br>
  <br>
  <br>不可逆块（Irreversible Block） ---又叫最后不可逆块，就是最后一个区块，不能再修改的块。DPOS规定，这个区块被三分之二的节点确认，就是不可逆块。如果被最新出块的三分之二节点确认，就是最后不可逆块。通过最后不可逆块，就能确认这条链是不是由三分之二节点签名的最长的那条链。
  <br>
  <br>
  <br>
  <br>
  <br>DPOS是一种参照了美国的议会制度，在现实中被认为是一个能良好运⾏的机制，能够兼顾去中⼼化和效率之间关系。但也有很多其他的声音说DPOS违背了区块链去中心化的本质，但其实相比较基于POW的比特币矿池，和基于POS的以太坊来说，对手里拿着BTC和ETH的人他们对社区和整个生态，他们是没有确定的发言权的，在比特币的世界里算力就是王道，面对算力大量集中在部分矿场的现在，它真的实现了中本聪的本心了吗？同样需要挖矿POS也是一样，需要看概率来决定你能否发声，但是DPOS是有发言权的，不管持有多少，我都有发言权。这种看似由“直接民主”转为“间接民主”的机制，或许才是真正体现了去中心化精神。
  <br>
  <br>
  <br>但是随着EOS主网的即将上线，EOS研发团队为竞选制定了规则：每持有一个柚子的用户拥有30票的选票，每一个代币的选票不能给一个节点超过两票。这样的规则好处在于一些大户不仅可以将票投给符合自己意愿的代表，还可以通过其他方式与其他节点交互，获得选票，毕竟只要选上第1名与第21名是没有区别的（超级节点的收益平分）。
  <br>
  <br>
  <br>但是EOS节点竞选现在遇到的一个问题在于：持有柚子的大量散户选民对选举热情不高或者说漠不关心，正所谓：天下熙熙，皆为利来，天下攘攘，皆为利往，因为即使投票选择了符合自己意愿的代表，代表在执行其职责的短期内所做的决定对持有者的利益没有什么影响，如果这些大量的散户参与程度不足，很有可能导致一些大规模持有者控制了授权代表的选举，他们就有可能会投票选择自己或者“指定”代表来担任授权代表，而在官方禁止用分红贿选的情况下，要怎么增加散户正向参与（随便投导致选出不负责任的节点比不投还糟糕）的积极性，我们希望EOS官方在未来能给我们一些惊喜。
  <br>
  <br>
  <br>Token、令牌通证、代币三者的关系
  <br>
  <br>
  <br>很多时候Token被说成代币，数字货币，但是都不对。
  <br>
  <br>
  <br>token可以翻译成为代币也可以翻译成记号令牌，代表了一个权益证明，只是一个权益证明。
  <br>
  <br>
  <br>通证:意思是就是「可流通的加密数字权益证明」
  <br>
  <br>
  <br>通证有三个要素，缺一不可。
  <br>
  <br>
  <br>第一是数字权益证明，也就是说通证必须是以数字形式存在的权益凭证，它必须代表的是一种权利，一种固有和内在的价值（Intrinsicvalue）。
  <br>
  <br>
  <br>第二是加密，也就是说通证的真实性、防篡改性、保护隐私等能力，由密码学予以保障。
  <br>
  <br>
  <br>第三是可流通，也就是说通证必须能够在一个网络中流动，从而随时随地可以验证。
  <br>
  <br>
  <br>事实上，通证可以代表一切权益证明，从身份证到学历文凭，从货币到票据，从钥匙、门票到积分、卡券，从股票到债券，人类社会全部权益证明，都可以用通证来代表。
  <br>
  <br>
  <br>DPOS的特殊性，也是奠定拜占庭容错能力的基础框架，是它的算力节点是固定21个人，并且由大型的机构运营节点，其信息也相对透明，例如运营节点的地点、运营的情况等等。并且DPOS的算力节点是固定出块顺序的，固定地从A到B到C······。
  <br>
  <br>
  <br>在这种情况下，其实DPOS是拜占庭容错的特殊解，如何理解特殊解？原来的拜占庭容错（POW工作量证明），解决的是不限数量、随机广播同步的算力节点的容错能力，DPOS解决的拜占庭容错从两个维度降低了难度：
  <br>
  <br>
  <br>1、节点数量固定只有21个。并且节点信息透明。
  <br>
  <br>
  <br>2、固定出块顺序。每个节点跟接力棒一样，一个个往下接力出块。每个节点不能还没轮到它出块的时候，就出块。都是必须轮到再出块。如果出现出块故障，会跳过这个节点。
  <br>
  <br>
  <br>在POW或者其他的POS共识里，节点不限、随机出块顺序的问题，就变成只要解决「固定数量和固定出块顺序情况下的拜占庭问题」，其难度就大大降低。
  <br>
  <br>
  <br>
  <br>
  <br>## 2.5 解读EOS白皮书2.0之TPS性能奥秘
  <br>
  <br>
  <br>每秒交易数（transactions per second，简称TPS，又叫吞吐量），影响tps的因素有三个：出块速度、确认时间、容量。以比特币为例：其出块速度为10分钟、确认时间为60分钟（需要六个节点确认）、容量为1M。如果把出块速度由10分钟降为1分钟，则tps提升10倍；如果把容量1M扩容到8M，则tps提升8倍。比特币的分叉也正是因为扩容争端引起，可见tps对于区块链性能起着一个至关重要的作用。
  <br>
  <br>
  <br>对于用户体验来说，确认时间是他们更为关心的问题；而对于开发者来说，tps是一个更为关键的指标。目前许多区块链都声称百万级别的tps,这个tps很有可能没有考虑到确认时间，因为确认时间与共识算法有决定性的关系。只有采用DPOS的少数节点确认，才有可能达到百万级别的速度。
  <br>
  <br>
  <br>确定区块不可逆速度提升如此之大的原因在于在传统DPOS中加入了拜占庭容错算法（BFT），交易只用等待选举出来的代理节点确认和打包，不需要等待其他非信任节点的确认，大大节约了交易确认时间的消耗，而且只要没有生产者签署具有相同时间戳或相同区块高度的两个区块，便允许所有生产者签署所有区块从而实现更快的不可逆转。异步拜占庭容错（aBFT）算法可在1秒内实现100%的确认，并且不可逆转。&nbsp;
  <br>
  <br>
  <br>DAWN 3.0给出了不同条件下单条链的测试结果，最差情况是1000TPS，理论最优情况是8000TPS，平均性能则是3000TPS。
  <br>
  <br>
  <br>由于跨链通信，我们可以根据需要在不同链之间分配工作量。代币可以可靠并且安全的在不同链之间转移。由于相同（或不同）矿工并行运行1000条链，我们可以看到每秒数百万的交易。这就是其他区块链提出的理论扩展方案的实际实现。
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>## 2.6 解读EOS白皮书2.0之管理账户
  <br>
  <br>
  <br>能合约的业务逻辑便是通过账户系统来实现的
  <br>
  <br>
  <br>账户的创建者可以在创造账户时输入不超过12个字符的名称，可以类比为在创建账户时输入网名“Bob”等，相比较比特币和以太坊的一大串64位地址，更方便使用。EOS.IO更显体贴，创建账号所需要的RAM资源，是由EOS代币持有者等比例持有的，且这部分花费不需要用户承当，开发人员将承当这部分的费用，如果在同一条公链上，不同的用户是可以共用一个账号的，不需要再创建新账户。
  <br>
  <br>
  <br>每个帐户可以将结构化的Actions发送到其他帐户，并且可以定义脚本来处理收到的Action。EOS.IO软件为每个帐户提供自己的专用数据库，这个数据库只能由自己的Action处理程序访问。Action处理脚本还可以将操作发送到其他账户。Action和自动Action处理程序的组合定义了EOS.IO撰写智能合约方式。为支持并发执行操作，每个账户同样可以在他们数据库内定义任意数量的范围。区块生产者将以这样一种方式来安排事务，这种方式对存储器访问范围没有冲突, 因此他们可以并发执行。
  <br>
  <br>
  <br>这里的"Action"与白皮书1.0中“Messages”代表的意思相同，方便理解原理大家也可以用信息来理解，类比：妈妈发送一条信息让你回家吃饭，你收到信息后自动的喊上了身边的小伙伴，让他和你一起回家吃饭。在账户中这种收到消息，自动触发将消息发给第三个账户的例子就是智能合约的一种形式。并发执行的意思就是，多个相互独立的程序交叉执行的方式。类比：你要完成两项家务1.煮饭、2.拖地。怎么样才能最快速的完成？当然是先将米洗好放入电饭煲，在等待饭煮熟的过程中完成拖地任务。并发执行的多个程序的 起止时间是交叉重叠的，这样可以更高效的完成信息和信息处理，前提是并发执行的程序范围不能重合，你总不能在拖地的时候，把拖把放入电饭煲中洗。
  <br>
  <br>
  <br>EOS.IO提供了一个声明式权限管理系统，暨账户可以分类给其他个人或群体权限，权限的范围包括可以做什么和什么时候做什么，类比：在家设立一个保安队（分类），保安队有两个人保安A和保安B。给保安A的权限是早上6：00——晚上6:00拥有大开大门的权力，给保安B的权限是晚上6:00——次日早上6:00拥有大开大门的权力。这样做的好处就是权限可以足够细化且方便控制和检查。
  <br>
  <br>
  <br>业务逻辑与权限管理的分开是十分有必要的，运用上面的例子：不同的业务逻辑是保安队需要到其他的地方站岗，每换一个地方都要重新分配权限是不合理的，权限的分配是可以通用的，也就是说他们依然可以按照之前的分配工作。这样就开发者就可以将注意力集中在业务逻辑上，体现了权限管理的通用性。
  <br>
  <br>
  <br>通过权限的分配来使其他用户共同维护一个账户，多用户控制可以提升账户的安全性，如果你是账户的唯一用户，黑客只要黑了你就可以获得账户的控制权，但是通过账户和私钥加权组合，设置权重和阀值让多个用户来控制，黑客就要黑了所有的用户才能获得账户的控制权。
  <br>
  <br>
  <br>这段话说明了，EOS的权限分配的组合方式可以是多重多样的，具体可以根据用途来定义。
  <br>
  <br>
  <br>命名权限级别就是给固定的名称添加权限，也可以理解为一个分组名称，类比为：家中有主人、管家、保安。主人可以任命管家，管家可以任命保安。保安这个名称的权限仅仅为开门，而管家的权限为除了主人的行动和命令以外的所有权限，管家可以拥有保安开门的权限但保安不能拥有管家的权限，除非主人任命他为管家。在重大事务的抉择中，家里有要超过两个管家的同意才能执行的设定。这就涉及到权重和阀值的意义，不同的名称其实也就代表不同的权限等级，这样可以灵活的用于不同场景，不同用途。
  <br>
  <br>
  <br>阀值和权重的意义可参考下面这个Action﻿，Action执行，需要满足一个阈值。比如要完成一个转账操作，设定的许可阈值是2，则一定要达到这个阈值，才能转账。Bob、Stacy的权重都是1，因此要获得Bob和Stacy的授权才可以完成这个操作。
  <br>
  <br>
  <br>通过权限映射便可以实现多账户控制，让相应的账户做出合适的操作，但其他账户在执行该操作时，会留下“记录”---因为其他账户必须使用密钥来签名才能完成操作。
  <br>
  <br>
  <br>像管家与他所能做的事情，可以理解为账户权限与Action的映射，这个映射便决定了管家能做的事情；管家与保安的关系，可以理解为账户与账户之间权限的映射，这个映射决定了保安受管家控制，保安的权限由管家决定。管家、保安做的所有事情都会留下指纹痕迹，这个指纹痕迹便可以理解为密钥签名。
  <br>
  <br>
  <br>
  <br>
  <br>## 2.7 解读EOS白皮书2.0之账户权限映射
  <br>
  <br>
  <br>整个账户体系或者说智能合约的精华就在这里。
  <br>
  <br>
  <br>这一块比较复杂，需要根据图来理解。
  <br>
  <br>
  <br># 3 EOS Dawn3.0的新特性解读
  <br>
  <br>
  <br>## 3.1 系统合约
  <br>DAWN 3.0正式引入了系统合约的概念，整个区块链的最小系统只实现了一个权限系统，包含账户创建、合约部署和强制资源分配的功能，其DPOS业务逻辑都交由系统合约来定义。这种改变使得动态升级变得十分简便，只需部署新的系统合约即可完成，不再需要通过硬分叉来实现。这在应对安全问题、权限签名、资源分配和功能扩展等方面意义重大。
  <br>
  <br>
  <br>
  <br>
  <br># 4 EOSIO 开发者指南中文版
  <br>
  <br>
  <br>## 4.1 钱包由本地节点配置的eosio::wallet_api_plugin管理
  <br>
  <br>
  <br>## 4.2 系统合约 eosio.bios
  <br>
  <br>
  <br>为了开发的目的，默认可以使用eosio.bios 合约。此合约使你可以直接控制其他帐户的资源分配并访问其他特权API。在公链中，该合同将管理 Token 的 staking 和 unstaking，为合约预留cpu、网络活动和内存资源。智能合约eosio.bios 在eosio源代码的contracts文件夹里。cleos指令默认是在eosio源码根目录中执行，但可以通过指定 ${EOSIO_SOURCE}/contracts/eosio.bios 的全路径从任意位置来执行。
  <br>
  <br>
  <br>bios 合约：bios的全称是 Basic Input/Output System 「基本输入输出系统」。EOS 官方对它的定义是，通过此合约第一我们可以直接控制其它账户的资源分配，第二可以使用其它需要权限的API调用。
  <br>出于实用主义的角度我们先对此不做过多探讨——如果把 EOS 或者说 nodeos 看做一个操作系统，我们把 bios 合约看做启动计算式时按 F8 就能进入的 bios 系统就可以了。这东西必不可少，软件的运行建立在这个基础上，但我们一般情况下不用去管它，只要保证它顺利加载就行。
  <br>
  <br>
  <br>token 合约：token 合约提供了代币的发行与转账功能。所以我们才能实现一行代码发币，因为就是一个智能合约嘛！
  <br>
  <br>
  <br>cleos 用两个action产生一个交易， eosio::setcode 和eosio::setabi. &nbsp;
  <br>
  <br>
  <br>代码定义了合约如何运行，abi描述了如何在binary和参数的json描述文件之间转换。虽然abi文件是可选的，但是所有的eosio工具都依赖于它以便于使用。
  <br>
  <br>
  <br>执行一个交易都会看到如下输出：这可以理解为：由eosio所定义的action 'setcode'被eosio合约以参数{args...}执行。
  <br>
  <br>
  <br>正如我们稍后会看到的，actions可以被多个合约所处理。这次调用的最后一个参数是 -p eosio，这个参数告诉cleos使用我们之前导入的active权限私钥来签名这个action。
  <br>
  <br>
  <br>## 4.3 eosio::account_history_api_plugin 查询所有由我们的密钥控制的账户
  <br>
  <br>
  <br>## 4.4 &nbsp;eosio.token 合约
  <br>该合约允许创建许多不同的token，这些token都运行在同一个合约上，但可能由不同的用户管理。
  <br>
  <br>
  <br>首先需要创建一个账户来部署这个合约。接下来就可以开始部署了（合约代码位于 ${EOSIO_SOURCE}/contracts/eosio.token。要创建一个新的token，我们必须用合适的参数来调用 create(...) action。该命令将使用最大的符号，用来从其他token中，唯一地鉴别这个token。发行人将有权要求发行和执行其他action，例如冻结，召回以及将所有者列入白名单。
  <br>
  <br>
  <br>根据参数位置来调用这个方法：也可以使用参数名键值对来调用：该命令创建了一个名为EOS的新的token，其精密度为 4 位数，最大供应量为 1000000000.0000 EOS。为了创建这个 token，我们需要获得 eosio.token 合约的许可，因为它“拥有”符号（比如 EOS）的命名空间。该合约的未来版本可能允许其他地方自动购买符号名称。当前我们必须通过-p eosio.token 在此授权。
  <br>
  <br>
  <br>现在我们已经创建了token，发行者可以用我们之前创建的user账户发行新的token。我们根据参数位置来调用issue这个action。这次输出包含着几个不同的action， issue 和 3 次转账。尽管我们仅仅执行了 issue这个action，但是 &nbsp;issue action默认执行了"inline transfer"，"inline transfer"通知了发件人和收件人帐户。输出指明所有被调用的action 处理程序、被调用的顺序，以及是否生成任何输出。
  <br>
  <br>
  <br>从技术上说，eosio.token合约可以跳过inline transfer并选择直接修改余额，但在这种情况下，eosio.token合约遵循我们的token约定，该约定要求所有账户余额可以通过他们传输actions的总和推论出来。它还要求通知资金的发送者和收款人，以便他们能够自动处理存款和提款。如果你想要看到广播的实际交易，你可以使用 &nbsp;-d -j 选项来表示 "don't broadcast" 和 "return transaction as json".
  <br>
  <br>
  <br># 5 如何发行「新垣结衣币」
  <br>
  <br>
  <br>如果我们把 EOS 看做一个操作系统，那么 bios 合约就是让我们能进行最底层的操作的合约，其它合约的运行建立在 bios 合约的基础之上，所以我们先来加载 bios 合约。
  <br>
  <br>
  <br>
  <br>
  <br>现在有三个账户—— eosio 账户（默认）、currency 账户和 gakkifans 账户。现在我们用 currency 账户加载并执行「发币合约」，发行新垣结衣币。
  <br>
  <br>
  <br>我们先看一下 currency 账户的合约情况：
  <br>
  <br>
  <br>./cleos get code currency
  <br>
  <br>
  <br>返回的结果是一串为0的hash，说明合约还未创建。
  <br>
  <br>
  <br>加载系统自带的发币合约
  <br>
  <br>
  <br>./cleos set contract currency ../../contracts/currency
  <br>
  <br>
  <br>用 currency 账户执行「发币合约」，创建新垣结衣币
  <br>
  <br>
  <br>执行下面命令：
  <br>
  <br>
  <br>./cleos push action currency create '{"issuer":"currency", "maximum_supply": "1000000000.0000 GAKKI", "can_freeze": 1, "can_recall": 1, "can_whitelist": 1}' -p currency@active
  <br>
  <br>
  <br>虽然目前新垣结衣币创建成功了，但还没有账户持有新垣结衣币。所以，我们要给账户「发币」。
  <br>
  <br>
  <br>
  <br>
  <br>./cleos push action currency issue '{"to":"currency","quantity":"1000.0000 GAKKI","memo":""}' --permission currency@active
  <br>
  <br>
  <br>我们就给 currency 账户发了 1000 个 GAKKI 币。
  <br>
  <br>
  <br>验证一下，通过以下命令查看 currency 账户余额。
  <br>
  <br>
  <br>./cleos get table currency currency accounts
  <br>
  <br>
  <br>返回的结果告诉我们，currency 的账户里的确有 1000 个 GAKKI 了！
  <br>
  <br>
  <br>（1）通过如下命令，currency 账户会将 20 个 GAKKI币 转给 gakkifans 账户：
  <br>
  <br>
  <br>./cleos push action currency transfer '{"from":"currency","to":"gakkifans","quantity":"20.0000 GAKKI","memo":"my first transfer"}' --permission currency@active
  <br>
  <br>
  <br>（2）查看 currency 和 gakkifans 两个账户的余额。
  <br>
  <br>
  <br>./cleos get table currency gakkifans accounts
  <br>./cleos get table currency currency accounts
  <br>
  <br>
  <br># 6 eos中文社区
  <br>
  <br>
  <br>https://github.com/eostea/eos-tutorials
  <br>
  <br>
  <br>https://eosfans.io/
  <br>
  <br>
  <br>
  <br>
  <br># 7 bm在medium.com的账户
  <br>
  <br>
  <br>更新频繁&nbsp;
  <br>
  <br>
  <br>https://medium.com/@bytemaster
  <br>
  <br>
  <br># 8 BM为了更好地支持交易所发布相关文档
  <br>
  <br>
  <br>本教程使用 cleos 命令行工具来操作本地 nodeos 服务器。 nodeos 需要配置下列插件：
  <br>
  <br>
  <br>eosio::wallet_api_plugin
  <br>eosio::history_api_plugin
  <br>eosio::chain_api_plugin
  <br>默认情况下，history插件将保存所有帐户的历史记录，但这会在中期消耗几十GB的内存，所以不推荐直接这样配置。为了内存优化，应该将history插件设置为仅记录与你的帐户相关的活动。这可以通过以下配置参数来实现，这些参数放置在config.ini中，或者作为命令行参数。
  <br>
  <br>
  <br>&nbsp; $ nodeos --filter_on_accounts youraccount
  <br>
  <br>
  <br>如果你已经在没有history插件的情况下同步了这个块链，那么你能需要回放这个块链来收集所有的历史活动。
  <br>
  <br>
  <br>&nbsp;$ nodeos --replay --filter_on_accounts youraccount&nbsp;
  <br>你只需要回放一次，节点的后续运行不应该使用回放标记，否则你的启动时间将会变成非常长，而这是没有必要的。
  <br>
  <br>
  <br>
  <br>
  <br>在设计本教程时，我们假设一个交易所会为即将进行交易对 nodeos 进行遍历，并且可以知道一个转账在何时将会被认定为终止或者不可逆的。
  <br>
  <br>
  <br>在基于eosio的区块链中，一旦三分之二以上的BP确定了区块，区块中的交易就不可逆转了。这可能需要不到两分钟的时间，但无论哪种方式，节点会公布这个状态。
  <br>
  <br>
  <br>初始条件
  <br>
  <br>
  <br>./cleos get currency balance eosio.token scott EOS
  <br>900.0000 EOS
  <br>(获取一个帐号的EOS数量，其中，eosio.token表示操作EOS的智能合约，scott表示待查的账户的名称，EOS是token的名称)
  <br>
  <br>
  <br>这个输出表明action "eosio.token::transfer" 已经传递到 3 个账户/合约 (eosio.token, scott, 和交易所)。
  <br>eosio token 标准规定所有转账操作需要通知发送方和接收方帐户/合约，这样这些账户能够进行相应的操作。 此时，虽然 scott 和 exchange 没有任何关联操作，但是交易记录仍会标记他们已得到通知。
  <br>
  <br>
  <br>不管账户是授权操作还是接收操作，账户历史都包含了所有的活动，当交易所收到了 eosio.token::transfer action，它将被列出在历史记录中。如果你已使用控制台确认，那不可逆的交易将以“绿色”显示，而未经确认的交易则以“黄色”显示。如果没有颜色，你可以通过第一个字符“#”（表示不可逆）和“？”（表示可能是可逆的）来判断一个交易是否已被确认。
  <br>
  <br>
  <br>./cleos get actions exchange
  <br>
  <br>
  <br>&nbsp; seq &nbsp;when &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;contract::action =&gt; receiver &nbsp; &nbsp; &nbsp;trx id... &nbsp; args
  <br>
  <br>
  <br>&nbsp; &nbsp; 0 &nbsp; 2018-04-29T01:09:45.000 &nbsp; &nbsp; eosio.token::transfer =&gt; exchange &nbsp; &nbsp; &nbsp;5ec79717... {"from":"scott","to":"exchange","quantity":"1.0000 EOS","mem...
  <br>
  <br>
  <br>“seq”列表示你特定账户的action索引，会随着新的相关action增加而递增。
  <br>
  <br>
  <br>cleos get actions 指令支持筛选需要显示的action，使用-h参数来获取命令帮助。
  <br>
  <br>
  <br>机器可读的账户历史记录(JSON)
  <br>
  <br>
  <br>目前为止，此教程主要侧重于运用cleos抓取和显示历史记录，但是 cleos仅仅是一个调用json-rpc接口的轻量级客户端。 cleos 支持返回原始的json数据格式，你也可以封装自己的json-rpc请求。
  <br>
  <br>
  <br>这是查询序列2时返回的 JSON格式数据。
  <br>
  <br>
  <br>./cleos get actions exchange 2 0 -j
  <br>
  <br>
  <br>
  <br>
  <br># 9 用数据说话：在「EOS信仰度测试」中，寻找新鲜韭菜
  <br>
  <br>
  <br>## 9.1 EOS的共识机制是？答案：DPOS+BFT
  <br>
  <br>
  <br>很多童鞋的选择是DPOS，但其实这是BM在BTS和Steem上采用的共识机制。EOS刚刚发布时，也是只采用了DPOS机制，而后为了让EOS有更好的性能，BM对DPOS进行了改进，加入了BFT（拜占庭容错）。
  <br>
  <br>
  <br>传统的DPOS
  <br>
  <br>
  <br>采用随机的超级节点出块顺序，出块速度为 3 秒，交易不可逆需要45秒。为什么需要 45 秒呢？因为 DPoS 下，超级节点生产一个新区块，才表示他对之前的整条区块链进行了确认，表明这个超级节点认可目前的整条链。而一个交易要达到不可逆状态，需要 2/3 以上的超级节点确认，在 EOS 里就是 14 个超级节点。我们假设一个交易被包含在 1000 号区块中，需要其他13个超级节点轮流出块至 1013 号区块，这样才能“收集”到14个超级节点对此交易的确认（包括生产1000区块的超级节点）。2/3 以上的超级节点确认的交易，就是不可逆的交易了，这就是 45 秒确认时间的由来。
  <br>
  <br>
  <br>拜占庭容错（BFT）
  <br>
  <br>
  <br>为了改进传统的 DPoS 算法，借鉴了 PBFT（Practical Byzantine Fault Tolerance，拜占庭容错算法）的机制。在传统 DPoS 共识机制中，让每个超级节点在出块时向全网广播这个区块，但即使其他超级节点收到了目前的新区块，也无法对新区块进行确认，需要等待轮到自己出块时，才能通过生产区块来确认之前的区块。
  <br>
  <br>
  <br>在新的机制下，每个超级节点出块时依然全网广播，其他超级节点收到新区块后，立即对此区块进行验证，并将验证签名完成的区块立即返回出块超级节点，不需等待其他超级节点自己出块时再确认。从当前的出块超级节点看来，他生产了一个区块，并全网广播，然后陆续收到了其他超级节点对此区块的确认，在收到 2/3 超级节点确认的瞬间，区块（包括其中的交易）就不可逆了。交易确认时间大大缩短，从 45 秒缩短至 3 秒左右（主要为等待生产区块的时间）。这种机制可以称为初级版的 DPOS-BFT 共识机制。
  <br>
  <br>
  <br>DPoS-BFT
  <br>
  <br>
  <br>为了挖掘 EOS 系统的性能，BM在以上基础上又进行了修改。首先，他将出块速度由 3 秒 缩短至 0.5 秒，理论上这样可以极大提升系统性能，但带来了网络延迟问题：0.5 秒的确认时间会导致下一个出块者还没有收到上一个出块者的区块，就该生产下一个区块了，那么下一个出块者会忽略上一个区块，导致区块链分叉（相同区块高度有两个区块）。比如：中国超级节点后面可能就是美国超级节点，中美网络延迟有时高达 300ms，很有可能到时美国超级节点没有收到中国超级节点的区块时，就该出块了，那么中国超级节点的区块就会被略过。
  <br>
  <br>
  <br>为解决这个问题，BM将原先的随机出块顺序改为由超级节点商议后确定的出块顺序，这样网络连接延迟较低的超级节点之间就可以相邻出块。比如：日本超级节点后面是中国的超级节点，再后面是俄罗斯的超级节点，再后面是英国的超级节点，再后面是美国的超级节点。这样可以大大降低超级节点之间的网络延迟。使得 0.5 秒的出块速度有了理论上的可能。
  <br>
  <br>
  <br>为了保证万无一失，不让任何一个超级节点因为网络延迟的意外而被跳过，BM让每个超级节点连续生产 6 个区块，也就是每个超级节点还是负责 3 秒的区块生产，但是由最初的只生产 1 个变成生产 6 个。最恶劣的情况下，6 个区块中，最后一个或两个有可能因为网络延迟或其他意外被下一个超级节点略过，但 6 个区块中的前几个会有足够的时间传递给下一个超级节点。
  <br>
  <br>
  <br>再来讨论 DPOS-BFT 的交易确认时间问题：每个区块生产后立即进行全网广播，区块生产者一边等待 0.5 秒生产下一个区块，同时会接收其他超级节点对于上一个区块的确认结果。新区块的生产和旧区块确认的接收同时进行。大部分的情况下，交易会在 1 秒之内确认（不可逆）。这其中包括了 0.5 秒的区块生产，和要求其他超级节点确认的时间。
  <br>
  <br>
  <br>EOS 系统规定，一旦区块达到不可逆状态（2/3超级节点确认），就无法在此之前进行分叉，保证了交易的永久可信。另外，即使多数超级节点想分叉区块链，也只能以相同的速度（0.5秒）与主链竞争，就算主链只剩下一个超级节点，分叉链也永远不会追上主链，保证了系统的稳定。
  <br>
  <br>
  <br>——以上文段节选自：【许晓笛】详解 EOS 的新共识机制 BFT-DPoS
  <br>
  <br>
  <br>## 9.2 六月份EOS上线的版本为？ 答案：单线程
  <br>
  <br>
  <br>6月的主网上线并不是EOS的终点，而是一个新的起点。Block.one团队会在保证单线程1000 tps的性能和功能稳定的前提下，再继续开发多线程EOS网络。
  <br>
  <br>
  <br>Solidity不是EOS的底层语言，C，C++，WebAssembly都是目前EOS支持的底层语言。ETH是支持Solidity的。
  <br>
  <br>
  <br>## 9.3 EOS总共会产生121个节点，其中21个为超级节点，100个为备用节点。
  <br>&nbsp;
  <br># 10 逐字逐句解读 BM 最新发布的 EOSIO Dawn 4.0 版本介绍
  <br>
  <br>
  <br>时间一致性：EOSIO Dawn 4.0最大的变化之一是我们已将当前时间的定义从“头块的时间”改为“当前区块的时间”。 这种变化使得大量包含时间操作的案例可以在存在缺失区块的情况下执行，并且更精确地计算智能合约的运行时间。
  <br>
  <br>
  <br>新的内存分配模型：测试中我们发现了EOSIO系统合同分配RAM(数据库空间)的方式会导致未来资源的短缺。我们改用了一种基于市场的分配方法，使用Bancor算法。我们的计算表明，如果1TB RAM按比例分配给token持有者，那么每字节的成本将是0.018美元(假设每个token20美元)。事实上，大多数token持有者实际上并不需要使用他们可能拥有的RAM；因此，我们最初对RAM的定价是每字节0.000018美元(假设每个token20美元)。创建一个新帐户需要大约4KB的RAM，这意味着将花费约0.10美元。随着RAM被分配，价格会自动增加，这样在系统耗尽RAM之前价格就会接近无穷大。在Dawn 3.0系统合约中，您只能以您支付的价格出售RAM。 目的是抑制囤积和投机。 这种方法的缺点那些廉价购买RAM的人在RAM变得更紧缺后，没有为其他用户腾出RAM的经济激励。在Dawn 4.0之下，系统合约现在以当前市场价格购买和销售RAM分配。 这可能会导致交易商在预计明天可能出现短缺的情况下购买RAM。 总的来说，这将导致市场随着时间的推移平衡RAM的供需。
  <br>随着时间的推移，摩尔定律将允许超级节点升级到4TB甚至16TB的内存，并且这种供应增长将逐渐降低EOSIO RAM市场价格。
  <br>
  <br>
  <br>对智能合约开发者的影响：作为一名智能合约开发者，RAM是一项宝贵的资源，数据库记录需要消耗RAM。考虑到RAM的成本，将存储在内存数据库中的数据量减到最小，并且设定你的应用程序在用户使用完后释放RAM将是非常重要的。例如，Steem仅在RAM中存储了1周的内容，因此总体的量大小不会随着时间增长而增长。
  <br>
  <br>
  <br>尽量遏制投机：那么现在形成了一个RAM市场，投机者或许想要利用RAM价格的波动性获取盈利。而 EOSIO 系统合约设定RAM不可转让，并收取1％的交易费用。这笔费用的结果是通过将其退出市场来抵消Token 的自然通货膨胀。如果RAM的年度交易量等于 Token 供应量，则所有块生产者奖励的100％将由 RAM 市场费用支付。
  <br>
  <br>
  <br>链间通信效率的提高：高性能区块链需要RAM中的所有数据，因为访问磁盘的时间会使事务吞吐量迅速下降到几百TPS。 为了扩展RAM使用量，我们需要在独立硬件上运行独立内存区域的多个链。EOSIO区块生产者可以运行许多不同的链，它们都使用相同的token来购买RAM和持有带宽。超级节点选举将在主链上进行，所有相关的侧链将由同一组超级节点维护。 每个链可以拥有1 TB以上的RAM，DAPP可以在链间发送消息，仅需几秒钟的延迟。RAM的价格在所有的链上都会有所不同，这会告诉DAPP开发者哪里运行起来最便宜。
  <br>
  <br>
  <br>并行路线图：链间通信（IBC）涉及到两条链的merkle证明验证，这些证明大小在1KB以上，还涉及数十个密码散列函数以及15个以上的签名验证。换句话说，验证来自另一个链的消息的成本比验证正常事务的成本高出大约15到30倍。幸运的是，验证这些证明很容易并行化，因为它们不依赖于区块链状态。一条链仅仅只处理来自其他链的消息就很轻易需要消耗30核CPU，同时只能维持几千TPS。我们相信，通过链间通信的扩展，几乎可以释放无限的性能扩展潜能。这种方法同时扩展RAM、网络和CPU。考虑到签名验证、无上下文操作验证和IBC证明已经满足了大多数CPU的高单线程吞吐量，对多线程WASM执行的优化可能会受到其他资源限制的阻碍。在EOSIODaw3.0下，我们围绕未来多线程WASM执行的潜力做出了许多设计决策。不幸的是，在您真正实现一个完整的多线程实现之前，不可能知道我们是否涵盖了所有的个例。这意味着EOSIODaw3.0具有许多架构复杂性，而这些复杂性并没有立即带来任何好处。我们现在认为，从单线程升级到多线程执行的途径是启动一个具有多线程支持的新链，由相同的区块生产者运行，并使用相同的本地token。这使得新链可以完全自由地进行必要的设计调整，以支持多线程操作，而无需对现有活跃链进行就地升级。通过这个并行性路线图，我们可以简化EOSIO 1.0并优化它以实现最高的单线程性能和易于开发。 我们预计EOSIO的单线程版本有一天可能达到5,000-10,000 TPS。 我们也预计，许多应用程序将更倾向于多链方法来扩展，因为它会降低总体成本并加快扩展。
  <br>
  <br>
  <br>升级DPOS最后不可逆区块算法：参与过共识算法讨论的人可能听说过，使用最后一个不可逆块（LIB）算法（如 Steem＆BitShares 中存在的算法）的DPOS在某些极端网络连接中断时有可能失去共识。在过去，由于其纯粹的理论性质以及相对最低的成本和停机时间，我已经驳回了这种潜在的失败模式。LIB算法只是一个度量标准，就像比特币的6区块规则。纯粹的DPOS总是依赖最长链规则，这将永远达到最终的一致。LIB算法是一种捷径，旨在优化还原历史并为交易提供可信度度量。EOSIO的IBC算法依赖于DPOS LIB以确定最终结果。一旦你引入IBC，与LIB失败相关的成本和修复它的难度都会变高。我们的团队，特别是 Bart 和 Arhag，对LIB算法进行了优化改进，以保证不超过其中的1/3是拜占庭式的时，两个节点不可能达到不同的LIB。此外，有可能检测单个对等体的拜占庭行为。关于此的更多信息见：https://github.com/EOSIO/eos/issues/2718。比特币和以太坊区块的缺限导致区块链与传统链之间的沟通困难和/或非常高的延迟。对DPOS的新调整将其带到全新的拜占庭容错水平，并且在所有网络环境中都具有强大的可靠性。
  <br>
  <br>
  <br>账户名抢注：一些用户对EOSIO帐户上的12个字符名称限制表示担忧。 这12个字符名称是从64位整数的base-32编码派生的。 64位整数是本地机器字大小，因此非常有效。 在一个事务中，我们多次引用帐户名（代码，范围，权限等），而我们的数据库索引也是以这些64位整数为基础的。 增加帐户名称的长度将对性能和架构产生深远影响。也就是说，我们关于区块链的愿景是将帐户的概念与身份分开，并在帐户名称和更易读的显示名称之间建立动态链上映射。最好将帐户名称视为牌照，用户可以选择容易记住的个性名称。也就是说，绝大多数人应该能够找到一个有吸引力的12个字符（或更少）的名字。由于某些名称潜在的高价值，我们认为EOSIO系统应为帐户名称提供动态定价模式。 此外，诸如* .com之类的命名空间帐户的能力可以为用户或者群体提供额外的安全保护。由于从现在到EOSIO软件1.0版的开发时间有限，我们将建议所有帐户名都强制为12个字符，而不包含任何“.”字符。一旦确定了可行的定价和反名称抢占政策，社区就可以升级系统合约(不是通过硬分叉)。我们可能会提供一个类似于Bitshare的模式，其中帐户名的定价是根据长度和字符内容。
  <br>
  <br>
  <br>
  <br>
  <br>新区块生产者的收益范例：关于生产者收益的社区讨论以及如何分配最高5％的通货膨胀问题已经有很多。EOSIO 1.0中发布的参考系统合同将像这样分配通货膨胀。有21个活跃生产节点和任意数量的备选节点。排名前21节点按区块数量每块奖励分成0.25％。所有BP候选人（包括前21名）也将按照他们收到的总票数，以每票0.75％的比例提成。他们最多可以每天一次要求获得每票收益的份额。为了要求他们的份额，他们必须有资格获得至少每天100个token。如果没有资格，那么他们将不会收到任何费用。该算法背后的思想是确保所有候选生产者有足够的收益为社区提供全面节点服务，并确保没有人能够接受不足以支付其成本的资金。假设前200名生产者候选人都获得相同数量的选票，这将支持21名活跃生产者和179名备用生产者。实际上，一些BP会比其他人拥有更多的选票，这可能会减少达到收益资格的备选BP的数量。设定每日收益最低限额是至关重要的，因为那些无意生产区块的富裕人士不能试图通过为自己投票成为BP候选人来获益。
  <br>
  <br>
  <br>
  <br> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lizhe_dashuju/article/details/80670248,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/lizhe_dashuju/article/details/80670248,&quot;}">阅读更多</a> 
</div>